<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《计算机科学导论》-期末复习</title>
      <link href="/2025/06/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E3%80%8B-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/06/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E3%80%8B-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>HDU对于该课程使用教材为《计算机科学导论——以Python为舟（第三版）》沙行勉所著。</p><p>因此本文按照该课本行文顺序展开，且由于时间有限本文仅仅整理了笔者认为重要的知识点。</p><h1 id="第1章-计算机学什么">第1章 计算机学什么</h1><h2 id="历史上的计算机">1.4.1 历史上的计算机</h2><p>计算机的发展历史通常以电子元件的更新为标志，被划分为四代，每一代的技术革新都推动了计算机性能、体积和应用领域的巨大变革。以下是详细介绍：</p><h3id="第一代计算机19461956年电子管计算机"><strong>第一代计算机（1946—1956年）：电子管计算机</strong></h3><h4 id="核心特征"><strong>核心特征</strong></h4><ul><li><strong>电子元件</strong>：使用电子管作为主要逻辑元件，体积庞大、功耗高、可靠性差。</li><li><strong>运算速度</strong>：每秒仅能进行数千次到数万次基本运算。</li><li><strong>存储方式</strong>：采用汞延迟线或磁鼓存储数据，容量极小（几KB）。</li><li><strong>编程语言</strong>：使用机器语言（二进制代码），编程难度极高。</li></ul><h4 id="代表机型"><strong>代表机型</strong></h4><ul><li><strong>ENIAC</strong>（电子数字积分计算机）：1946年由美国研制，是世界上第一台通用电子计算机，重达30吨，占地170平方米。</li><li><strong>EDVAC</strong>（电子离散变量自动计算机）：首次提出“存储程序”概念，奠定了现代计算机体系结构基础。</li></ul><h4 id="应用领域"><strong>应用领域</strong></h4><ul><li>主要用于军事和科学计算，如弹道计算、原子弹研发等。</li></ul><h3id="第二代计算机19561964年晶体管计算机"><strong>第二代计算机（1956—1964年）：晶体管计算机</strong></h3><h4 id="核心特征-1"><strong>核心特征</strong></h4><ul><li><strong>电子元件</strong>：用晶体管取代电子管，体积缩小、功耗降低、可靠性显著提高。</li><li><strong>运算速度</strong>：提升至每秒数万次到几十万次。</li><li><strong>存储方式</strong>：引入磁芯存储器，容量扩大到几十KB；外部存储使用磁带和磁盘。</li><li><strong>编程语言</strong>：出现高级语言（如FORTRAN、COBOL）和汇编语言，编程效率提升。</li></ul><h4 id="代表机型-1"><strong>代表机型</strong></h4><ul><li><strong>IBM7094</strong>：美国IBM公司研制的大型科学计算机，用于气象预报和太空探索。</li><li><strong>UNIVAC1107</strong>：首次应用于商业数据处理，如人口普查和企业财务计算。</li></ul><h4 id="应用领域-1"><strong>应用领域</strong></h4><ul><li>扩展到商业、工程设计和数据处理，如银行记账、企业库存管理等。</li></ul><h3id="第三代计算机19641970年集成电路计算机"><strong>第三代计算机（1964—1970年）：集成电路计算机</strong></h3><h4 id="核心特征-2"><strong>核心特征</strong></h4><ul><li><strong>电子元件</strong>：采用中小规模集成电路（SSI/MSI），将多个晶体管集成在一块硅片上，体积进一步缩小，性能大幅提升。</li><li><strong>运算速度</strong>：达到每秒几十万次到几百万次。</li><li><strong>存储方式</strong>：半导体存储器逐步取代磁芯存储器，容量扩展到MB级别。</li><li><strong>编程语言</strong>：高级语言广泛应用（如BASIC），操作系统和数据库管理系统开始发展。</li></ul><h4 id="代表机型-2"><strong>代表机型</strong></h4><ul><li><strong>IBMSystem/360</strong>：IBM推出的第一代通用计算机系列，支持多种应用场景，奠定了现代计算机兼容性标准。</li><li><strong>PDP-8</strong>：DEC公司的小型计算机，价格低廉，进入科研机构和中小企业。</li></ul><h4 id="应用领域-2"><strong>应用领域</strong></h4><ul><li>普及到工业控制、交通管理、教育等领域，小型计算机开始商业化。</li></ul><h3id="第四代计算机1970年至今大规模集成电路计算机"><strong>第四代计算机（1970年至今）：大规模集成电路计算机</strong></h3><h4 id="核心特征-3"><strong>核心特征</strong></h4><ul><li><strong>电子元件</strong>：使用大规模集成电路（LSI）和超大规模集成电路（VLSI），单个芯片可集成数百万到数十亿个晶体管，性能呈指数级增长。</li><li><strong>运算速度</strong>：从每秒几百万次提升至万亿次（如超级计算机），个人计算机（PC）普及。</li><li><strong>存储方式</strong>：内存容量达GB/TB级别，硬盘、固态硬盘（SSD）成为主流外部存储，云存储技术兴起。</li><li><strong>编程语言</strong>：高级语言（如C++、Java、Python）和可视化编程工具普及，人工智能编程语言（如Lisp、Prolog）发展。</li></ul><h4 id="代表机型-3"><strong>代表机型</strong></h4><ul><li><strong>个人计算机（PC）</strong>：1971年Intel推出4004微处理器，1981年IBM推出PC/XT，开启个人计算时代。</li><li><strong>超级计算机</strong>：如中国的“天河”系列、美国的“顶点”（Summit），用于气候模拟、密码破解等尖端领域。</li></ul><h4 id="应用领域-3"><strong>应用领域</strong></h4><ul><li>渗透到社会各个层面：互联网、人工智能、大数据、物联网、移动计算（如智能手机、平板电脑）、虚拟现实（VR）等。</li></ul><h3id="延伸第五代计算机的探索"><strong>延伸：第五代计算机的探索</strong></h3><ul><li><strong>目标</strong>：以人工智能为核心，具备自主学习、推理和自然语言处理能力，突破冯·诺依曼体系结构的限制。</li><li><strong>技术方向</strong>：神经网络计算机、量子计算机、生物计算机等，目前仍处于研究和实验阶段。</li></ul><p>计算机的发展史本质上是电子技术和计算理论的迭代史，每一代变革都重塑了人类的工作、生活和思考方式。</p><h1 id="第2章-神奇的0与1">第2章 神奇的0与1</h1><h2 id="不同进制间的转换">2.2 不同进制间的转换</h2><p>2、8、10、16进制是计算机领域常用的数值表示方式，它们之间的转换可以通过特定算法或借助工具完成。以下是详细的转换方法和示例：</p><h3 id="十进制decimal转其他进制"><strong>1.十进制（Decimal）转其他进制</strong></h3><h4 id="原理"><strong>原理</strong>：</h4><ul><li><strong>整数部分</strong>：除基取余，倒序排列。</li><li><strong>小数部分</strong>：乘基取整，顺序排列。</li></ul><h4 id="示例"><strong>示例</strong>：</h4><p><strong>十进制 → 二进制</strong><br />将 <code>25.625</code> 转换为二进制：<br />- <strong>整数部分</strong>：<br /><code>25 ÷ 2 = 12 余 1</code><br /><code>12 ÷ 2 = 6 余 0</code><br /><code>6 ÷ 2 = 3 余 0</code><br /><code>3 ÷ 2 = 1 余 1</code><br /><code>1 ÷ 2 = 0 余 1</code><br /><strong>结果</strong>：<code>11001</code>（倒序）。</p><ul><li><p><strong>小数部分</strong>：<br /><code>0.625 × 2 = 1.25 → 取整 1</code><br /><code>0.25 × 2 = 0.5 → 取整 0</code><br /><code>0.5 × 2 = 1.0 → 取整 1</code><br /><strong>结果</strong>：<code>0.101</code>（顺序）。</p></li><li><p><strong>合并</strong>：<code>25.625₁₀ = 11001.101₂</code>。</p></li></ul><p><strong>十进制 → 八进制/十六进制</strong><br />同理，将基数替换为8或16，余数对应八进制（0-7）或十六进制（0-9,A-F）符号。<br />例如：<br />- <code>25₁₀ ÷ 8 = 3 余 1 → 31₈</code><br />- <code>25₁₀ ÷ 16 = 1 余 9 → 19₁₆</code></p><h3 id="二进制binary转其他进制"><strong>2.二进制（Binary）转其他进制</strong></h3><h4 id="原理-1"><strong>原理</strong>：</h4><ul><li><strong>二进制 →八进制</strong>：每3位二进制数对应1位八进制数（不足补0）。<br /></li><li><strong>二进制 →十六进制</strong>：每4位二进制数对应1位十六进制数（不足补0）。<br /></li><li><strong>二进制 → 十进制</strong>：按位权展开求和。</li></ul><h4 id="示例-1"><strong>示例</strong>：</h4><p><strong>二进制 → 八进制</strong><br /><code>11001.101₂</code> → 分组：<code>011 001 . 101</code> →转换：<code>3 1 . 5</code> →<strong>结果</strong>：<code>31.5₈</code>。</p><p><strong>二进制 → 十六进制</strong><br /><code>11001.101₂</code> → 分组：<code>0001 1001 . 1010</code> →转换：<code>1 9 . A</code> →<strong>结果</strong>：<code>19.A₁₆</code>。</p><p><strong>二进制 → 十进制</strong><br /><code>11001.101₂</code> → 展开：<br /><code>1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰ + 1×2⁻¹ + 0×2⁻² + 1×2⁻³ = 25.625₁₀</code>。</p><h3 id="八进制octal转其他进制"><strong>3.八进制（Octal）转其他进制</strong></h3><h4 id="原理-2"><strong>原理</strong>：</h4><ul><li><strong>八进制 →二进制</strong>：每1位八进制数展开为3位二进制数。<br /></li><li><strong>八进制 →十进制/十六进制</strong>：先转二进制，再按二进制规则转换。</li></ul><h4 id="示例-2"><strong>示例</strong>：</h4><p><strong>八进制 → 二进制</strong><br /><code>31.5₈</code> → 展开：<code>011 001 . 101</code> →<strong>结果</strong>：<code>11001.101₂</code>。</p><p><strong>八进制 → 十进制</strong><br /><code>31.5₈</code> →展开：<code>3×8¹ + 1×8⁰ + 5×8⁻¹ = 25.625₁₀</code>。</p><h3 id="十六进制hexadecimal转其他进制"><strong>4.十六进制（Hexadecimal）转其他进制</strong></h3><h4 id="原理-3"><strong>原理</strong>：</h4><ul><li><strong>十六进制 →二进制</strong>：每1位十六进制数展开为4位二进制数。<br /></li><li><strong>十六进制 →十进制/八进制</strong>：先转二进制，再按二进制规则转换。</li></ul><h4 id="示例-3"><strong>示例</strong>：</h4><p><strong>十六进制 → 二进制</strong><br /><code>19.A₁₆</code> → 展开：<code>0001 1001 . 1010</code> →<strong>结果</strong>：<code>11001.101₂</code>。</p><p><strong>十六进制 → 十进制</strong><br /><code>19.A₁₆</code> →展开：<code>1×16¹ + 9×16⁰ + 10×16⁻¹ = 25.625₁₀</code>。</p><h3 id="快速转换工具"><strong>快速转换工具</strong></h3><p>在编程中，可使用内置函数直接转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 示例</span></span><br><span class="line">num = <span class="number">25.625</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制 → 其他进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">25</span>))      <span class="comment"># 0b11001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">25</span>))      <span class="comment"># 0o31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">25</span>))      <span class="comment"># 0x19</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他进制 → 十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;11001&#x27;</span>, <span class="number">2</span>))  <span class="comment"># 25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;31&#x27;</span>, <span class="number">8</span>))     <span class="comment"># 25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;19&#x27;</span>, <span class="number">16</span>))    <span class="comment"># 25</span></span><br></pre></td></tr></table></figure><h3 id="总结"><strong>总结</strong></h3><table style="width:100%;"><colgroup><col style="width: 18%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th><strong>原进制  目标进制</strong></th><th><strong>二进制</strong></th><th><strong>八进制</strong></th><th><strong>十进制</strong></th><th><strong>十六进制</strong></th></tr></thead><tbody><tr class="odd"><td><strong>二进制</strong></td><td>-</td><td>3位分组转八进制</td><td>按位权展开求和</td><td>4位分组转十六进制</td></tr><tr class="even"><td><strong>八进制</strong></td><td>每位展开为3位二进制</td><td>-</td><td>按位权展开求和</td><td>先转二进制，再转十六进制</td></tr><tr class="odd"><td><strong>十进制</strong></td><td>除2取余，倒序排列</td><td>除8取余，倒序排列</td><td>-</td><td>除16取余，倒序排列</td></tr><tr class="even"><td><strong>十六进制</strong></td><td>每位展开为4位二进制</td><td>先转二进制，再转八进制</td><td>按位权展开求和</td><td>-</td></tr></tbody></table><p>掌握这些转换方法，有助于理解计算机底层数据表示和编程中的位运算。</p><h2 id="无符号整数与加法">2.3.1 无符号整数与加法</h2><p>无符号整数是计算机中一种不表示负数的数值类型，其所有二进制位都用于表示数值大小。在加法运算中，无符号整数遵循严格的二进制规则，且需特别注意溢出问题。以下是详细解析：</p><h3id="一无符号整数的定义与表示"><strong>一、无符号整数的定义与表示</strong></h3><h4 id="基本概念"><strong>1. 基本概念</strong></h4><ul><li><strong>无符号性</strong>：不使用最高位作为符号位（如 signed类型），所有位均表示数值本身。<br /></li><li><strong>取值范围</strong>：对于 n 位无符号整数，范围为<code>0</code> 到 <code>2ⁿ - 1</code>。<ul><li>例：8 位无符号整数范围是<code>0 ~ 255</code>（<code>0000 0000₂ ~ 1111 1111₂</code>）。</li></ul></li></ul><h4 id="二进制表示"><strong>2. 二进制表示</strong></h4><ul><li>直接以二进制补码形式存储（无符号数的补码即其本身）。<ul><li>例：<code>13₁₀ = 0000 1101₂</code>（8 位）。</li></ul></li></ul><h3id="二无符号整数的加法规则"><strong>二、无符号整数的加法规则</strong></h3><h4 id="运算规则与二进制加法一致"><strong>1.运算规则（与二进制加法一致）</strong></h4><ul><li>按位相加，逢 2 进 1，不考虑符号位。<br /></li><li>例：计算 <code>5₁₀ + 7₁₀</code>（8 位无符号整数）：<br /><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">  0000 0101  (5)</span></span><br><span class="line"><span class="section">+ 0000 0111  (7)</span></span><br><span class="line"><span class="section">-----------</span></span><br><span class="line">0000 1100  (12)</span><br></pre></td></tr></table></figure></li></ul><h4 id="溢出overflow处理"><strong>2. 溢出（Overflow）处理</strong></h4><ul><li>当运算结果超过 n位无符号整数的最大值（<code>2ⁿ - 1</code>）时，发生溢出，高位直接丢弃，仅保留低n 位。<br /></li><li>例：计算 <code>255₁₀ + 1₁₀</code>（8 位无符号整数）：<br /><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1111</span> <span class="number">1111</span>  (<span class="number">255</span>)</span><br><span class="line">+ <span class="number">0000</span> <span class="number">0001</span>  (<span class="number">1</span>)</span><br><span class="line">-----------</span><br><span class="line"><span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span>  (溢出，保留低 <span class="number">8</span> 位为 <span class="number">0</span>)</span><br><span class="line">  ```  </span><br><span class="line">  结果为 `<span class="number">0</span>₁₀`，而非 `<span class="number">256</span>₁₀`，溢出时通常会触发硬件标志位（如 CF 进位标志）。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **三、无符号整数加法的硬件实现**</span><br><span class="line">#### **<span class="number">1.</span> 加法器结构**  </span><br><span class="line">- 由多个全加器（Full Adder）级联组成，每个全加器处理 <span class="number">1</span> 位二进制加法，包含：  </span><br><span class="line">  - 两个输入位（A, B）和一个进位输入（Cin）；  </span><br><span class="line">  - 输出和位（Sum）和进位输出（Cout）。  </span><br><span class="line"></span><br><span class="line">#### **<span class="number">2.</span> 进位传递**  </span><br><span class="line">- 例：n 位加法器中，第 i 位的进位输出 `Cout_i` 依赖于当前位输入和前一位的进位 `Cin_i`，最终最高位的进位 `Cout_&#123;n<span class="number">-1</span>&#125;` 即溢出标志。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **四、无符号整数加法的应用场景**  </span><br><span class="line">#### **<span class="number">1.</span> 计数与寻址**  </span><br><span class="line">- 内存地址、循环计数器（如 `for (unsigned int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)`）、文件大小记录等，需确保数值非负。  </span><br><span class="line"></span><br><span class="line">#### **<span class="number">2.</span> 位运算与数据处理**  </span><br><span class="line">- 与逻辑运算符（&amp;、|、^）结合处理二进制数据，如掩码操作：  </span><br><span class="line">  ```c</span><br><span class="line">  unsigned int a = <span class="number">0x0F</span>;  <span class="comment">// 0000 1111</span></span><br><span class="line">  unsigned int b = <span class="number">0xF0</span>;  <span class="comment">// 1111 0000</span></span><br><span class="line">  unsigned int c = a + b; <span class="comment">// 1111 1111 = 255</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="无符号与有符号整数的混合运算"><strong>3.无符号与有符号整数的混合运算</strong></h4><ul><li>在 C/C++等语言中，无符号数与有符号数相加时，有符号数会隐式转换为无符号数，可能导致意外结果：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-1</span>;       <span class="comment">// 有符号数，补码为 1111 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a + b &gt; <span class="number">0</span>) &#123;  <span class="comment">// 实际计算：1111 1111 + 0000 0001 = 1 0000 0000 → 无符号数为 256，但溢出后为 0，条件为假</span></span><br><span class="line">  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3id="五溢出检测与编程注意事项"><strong>五、溢出检测与编程注意事项</strong></h3><h4 id="硬件标志检测"><strong>1. 硬件标志检测</strong></h4><ul><li>在汇编语言中，可通过检查进位标志（CF）判断无符号加法是否溢出：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD AX, BX     ; 执行加法</span><br><span class="line">JC overflow    ; 若 CF=1（进位），跳转至溢出处理</span><br></pre></td></tr></table></figure></li></ul><h4 id="编程中的预防措施"><strong>2. 编程中的预防措施</strong></h4><ul><li>在高级语言中，可通过“先判断后运算”避免溢出：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算两个无符号整数之和，假设 n 为位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_unsigned</span>(<span class="params">a, b, n</span>):</span><br><span class="line">    max_val = <span class="number">2</span> ** n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; max_val <span class="keyword">or</span> b &gt; max_val:</span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">&quot;输入超出范围&quot;</span>)</span><br><span class="line">    result = a + b</span><br><span class="line">    <span class="keyword">if</span> result &gt; max_val:</span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">&quot;加法溢出&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul><h4 id="语言特性注意"><strong>3. 语言特性注意</strong></h4><ul><li>Java 等语言中，无符号整数需手动处理（如使用 <code>long</code>类型存储溢出位），而 C++11 引入<code>uint8_t</code>/<code>uint32_t</code> 等明确无符号类型。</li></ul><h3id="总结无符号整数加法的核心特点"><strong>总结：无符号整数加法的核心特点</strong></h3><table><colgroup><col style="width: 17%" /><col style="width: 82%" /></colgroup><thead><tr class="header"><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr class="odd"><td><strong>运算规则</strong></td><td>纯二进制加法，逢 2 进 1，不考虑符号。</td></tr><tr class="even"><td><strong>溢出行为</strong></td><td>结果超过范围时丢弃高位，仅保留低 n 位，需通过进位标志检测溢出。</td></tr><tr class="odd"><td><strong>应用场景</strong></td><td>适用于非负数值场景（计数、寻址、位操作），避免符号位带来的逻辑复杂度。</td></tr><tr class="even"><td><strong>编程注意</strong></td><td>混合运算时需注意类型转换，必要时显式检测溢出，避免逻辑错误。</td></tr></tbody></table><p>理解无符号整数加法是掌握计算机底层数值计算的基础，尤其在嵌入式开发、系统编程中至关重要。</p><h2 id="乘法与除法">2.3.2 乘法与除法</h2><h3id="一无符号整数乘法的基本原理"><strong>一、无符号整数乘法的基本原理</strong></h3><h4 id="二进制乘法规则"><strong>1. 二进制乘法规则</strong></h4><p>与十进制乘法类似，逐位相乘后累加：</p><ul><li><strong>步骤</strong>：<ol type="1"><li>被乘数与乘数的每一位相乘（0× 任何数 = 0，1× 任何数 = 原数）。</li><li>每次相乘结果左移对应位数（相当于乘以 2 的幂）。</li><li>将所有中间结果累加。</li></ol></li></ul><h4 id="示例计算-5₁₀-3₁₀4-位无符号整数"><strong>2.示例：计算 <code>5₁₀ × 3₁₀</code>（4 位无符号整数）</strong></h4><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    0101  (5)</span><br><span class="line">×   0011  (3)</span><br><span class="line">-----------</span><br><span class="line">    0101  (0101 × 1，不移位)</span><br><span class="line">+  0101   (0101 × 1，左移1位)</span><br><span class="line">-----------</span><br><span class="line">  01111  (15) → 结果需扩展为5位</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>n 位 ×n 位无符号整数的结果可能需要 2n 位存储（如 4 位 ×4位最大结果为<code>15×15=225 → 1110 0001₂</code>，需 8 位）。</li></ul><h2 id="浮点数">2.3.4 浮点数</h2><h3 id="ieee754浮点数标准详解">IEEE754浮点数标准详解</h3><h4 id="一ieee754的定义与背景">一、IEEE754的定义与背景</h4><p>IEEE754是由电气和电子工程师协会（IEEE）于1985年制定的浮点数算术标准，旨在统一计算机中浮点数的表示、运算和精度处理。它解决了早期不同计算机系统中浮点数表示不兼容的问题，目前广泛应用于CPU、编程语言（如C、Java）和硬件加速器中。</p><h4id="二ieee754的核心结构浮点数的组成">二、IEEE754的核心结构：浮点数的组成</h4><p>IEEE754通过<strong>符号位（Sign）、指数位（Exponent）、尾数位（Mantissa/Fraction）</strong>三部分表示浮点数，不同精度格式的位数分配如下：</p><table><colgroup><col style="width: 16%" /><col style="width: 11%" /><col style="width: 18%" /><col style="width: 18%" /><col style="width: 18%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th>类型</th><th>总位数</th><th>符号位（S）</th><th>指数位（E）</th><th>尾数位（M）</th><th>指数偏移量</th></tr></thead><tbody><tr class="odd"><td>单精度（float）</td><td>32</td><td>1</td><td>8</td><td>23</td><td>127</td></tr><tr class="even"><td>双精度（double）</td><td>64</td><td>1</td><td>11</td><td>52</td><td>1023</td></tr><tr class="odd"><td>半精度（half）</td><td>16</td><td>1</td><td>5</td><td>10</td><td>15</td></tr></tbody></table><p><strong>核心规则</strong>： -<strong>符号位（S）</strong>：0表示正数，1表示负数。 -<strong>指数位（E）</strong>：存储指数值，但采用<strong>偏移码</strong>表示，用于支持正负指数。-<strong>尾数位（M）</strong>：存储小数部分，隐含最高位为1（规格化数），因此实际精度比位数多1位。</p><h4 id="三ieee754的数值计算方式">三、IEEE754的数值计算方式</h4><p>对于规格化浮点数（最常见情况），其数值公式为： [ = (-1)^S 1.M ^{(E -)} ]</p><p><strong>示例：单精度浮点数的解析</strong><br />假设一个32位二进制数为：<code>0 10000001 10010000000000000000000</code><br />- <strong>符号位（S）</strong>：0 → 正数<br />- <strong>指数位（E）</strong>：10000001 → 十进制为129<br />- <strong>尾数位（M）</strong>：10010000... → 二进制小数为0.1001<br />- 偏移量：127<br />- 计算：<br />指数值 = 129 - 127 = 2<br />尾数 = 1 + 0.1001 = 1.5625<br />最终值 = (1.5625 ^2 = 6.25)</p><h4id="四十进制浮点数转ieee754的步骤">四、十进制浮点数转IEEE754的步骤</h4><p>以单精度浮点数<code>3.25</code>为例： 1.<strong>转二进制整数部分</strong>：3 → <code>11</code><br />2. <strong>转二进制小数部分</strong>：0.25 →<code>0.01</code>（0.25×2=0.5→0，0.5×2=1→1）<br />3. <strong>合并为二进制浮点数</strong>：<code>11.01</code> → 规格化后为<code>1.101 × 2^1</code><br />4. <strong>提取符号位</strong>：正数→S=0<br />5. <strong>计算指数</strong>：1 + 127 = 128 →二进制<code>10000000</code><br />6.<strong>提取尾数</strong>：规格化数的尾数为<code>101</code>，补至23位→<code>10100000000000000000000</code><br />7. <strong>组合三部分</strong>：<br />符号位<code>0</code> + 指数位<code>10000000</code> +尾数位<code>10100000000000000000000</code><br />→ 二进制表示：<code>0 10000000 10100000000000000000000</code></p><h4 id="五特殊值与非规格化数">五、特殊值与非规格化数</h4><ol type="1"><li><p><strong>规格化数（Normal Numbers）</strong>：<br />指数位E≠0且E≠255（单精度），满足<code>1.M × 2^(E-偏移量)</code>。</p></li><li><p><strong>非规格化数（Denormal Numbers）</strong>：</p><ul><li>指数位E=0，尾数M≠0<br /></li><li>数值公式：((-1)^S 0.M ^{(1 - )})<br /></li><li>作用：处理接近0的小数，避免“零间隙”问题。</li></ul></li><li><p><strong>特殊值</strong>：</p><ul><li><strong>无穷大（Infinity）</strong>：S=0/1，E=255（单精度），M=0<br />示例：正无穷<code>0 11111111 000...0</code>，负无穷<code>1 11111111 000...0</code><br /></li><li><strong>非数（NaN, Not a Number）</strong>：S任意，E=255，M≠0<br />示例：<code>0 11111111 000...1</code>（表示无效运算结果，如0/0）</li></ul></li></ol><h4 id="六ieee754的精度与范围">六、IEEE754的精度与范围</h4><ol type="1"><li><strong>精度限制</strong>：<ul><li>单精度：约7位十进制有效数字（2^23≈838万，尾数23位+隐含1位）<br /></li><li>双精度：约15-17位十进制有效数字（2^52≈4.5万亿）<br /></li><li>示例：0.1无法用二进制精确表示，存储为近似值，导致计算误差（如0.1+0.2≠0.3）。</li></ul></li><li><strong>数值范围</strong>：<ul><li>单精度：最小值约(1.18×10<sup>{-38})，最大值约(3.40×10</sup>{38})<br /></li><li>双精度：最小值约(2.23×10<sup>{-308})，最大值约(1.79×10</sup>{308})</li></ul></li></ol><h4 id="七ieee754的运算与舍入">七、IEEE754的运算与舍入</h4><ol type="1"><li><strong>四则运算流程</strong>：<ul><li>对阶（调整指数使小数点对齐）→ 尾数运算 → 规格化 → 舍入 →检查溢出。</li></ul></li><li><strong>舍入模式</strong>：<ul><li>就近舍入（默认）：向最近的可表示数舍入，偶数优先（如1.5→2，2.5→2）<br /></li><li>向下舍入（朝-∞）、向上舍入（朝+∞）、向零舍入（截断）。</li></ul></li></ol><h4 id="八ieee754的意义与应用">八、IEEE754的意义与应用</h4><ul><li><strong>标准化</strong>：统一了不同硬件和软件的浮点数表示，确保跨平台兼容性。<br /></li><li><strong>科学计算</strong>：广泛用于物理、工程、机器学习等领域的浮点运算。<br /></li><li><strong>硬件支持</strong>：CPU（如x86的SSE指令集）和GPU内置IEEE754运算单元。</li></ul><p>通过IEEE754标准，计算机得以高效处理浮点数的精度、范围和特殊值问题，成为现代计算体系的重要基础。</p><h2 id="笔者补充">笔者补充</h2><p>原码、反码和补码是计算机中表示有符号整数的三种编码方式，它们各有特点，但补码是现代计算机最常用的表示方法。以下是详细介绍：</p><h3 id="原码sign-magnitude"><strong>1.原码（Sign-Magnitude）</strong></h3><h4 id="定义"><strong>定义</strong></h4><ul><li><strong>符号位</strong>：最高位表示符号（0为正，1为负），其余位表示数值大小。</li><li><strong>数值范围</strong>：对于n位原码，范围为<code>-(2ⁿ⁻¹-1)</code> 到 <code>2ⁿ⁻¹-1</code>。</li></ul><h4 id="示例8位"><strong>示例（8位）</strong></h4><ul><li><code>+5</code>：<code>0 000 0101</code><br /></li><li><code>-5</code>：<code>1 000 0101</code><br /></li><li><strong>特殊值</strong>：<code>0</code> 有两种表示：<ul><li><code>+0</code>：<code>0 000 0000</code><br /></li><li><code>-0</code>：<code>1 000 0000</code></li></ul></li></ul><h4 id="优缺点"><strong>优缺点</strong></h4><ul><li><strong>优点</strong>：直观易懂，与十进制转换简单。<br /></li><li><strong>缺点</strong>：<ol type="1"><li><code>0</code> 的表示不唯一，造成冗余。<br /></li><li>加减法运算复杂（需先判断符号，再处理绝对值）。<br /></li><li>硬件实现困难。</li></ol></li></ul><h3 id="反码ones-complement"><strong>2. 反码（One'sComplement）</strong></h3><h4 id="定义-1"><strong>定义</strong></h4><ul><li><strong>正数</strong>：与原码相同。<br /></li><li><strong>负数</strong>：符号位为1，其余位是原码的按位取反。</li></ul><h4 id="示例8位-1"><strong>示例（8位）</strong></h4><ul><li><code>+5</code>：<code>0 000 0101</code>（同原码）<br /></li><li><code>-5</code>：<code>1 111 1010</code>（原码<code>1 000 0101</code> 取反）<br /></li><li><strong>特殊值</strong>：<code>0</code> 有两种表示：<ul><li><code>+0</code>：<code>0 000 0000</code><br /></li><li><code>-0</code>：<code>1 111 1111</code></li></ul></li></ul><h4 id="优缺点-1"><strong>优缺点</strong></h4><ul><li><strong>优点</strong>：符号位可参与运算，减法可转换为加法（如<code>A-B = A + (-B)</code> 的反码）。<br /></li><li><strong>缺点</strong>：<ol type="1"><li><code>0</code> 的表示仍不唯一。<br /></li><li>存在“循环进位”问题（加法溢出时需额外加1）。<br /></li><li>计算效率低，现已淘汰。</li></ol></li></ul><h3 id="补码twos-complement"><strong>3. 补码（Two'sComplement）</strong></h3><h4 id="定义-2"><strong>定义</strong></h4><ul><li><strong>正数</strong>：与原码相同。<br /></li><li><strong>负数</strong>：符号位为1，其余位是原码的按位取反后加1（即反码+1）。</li></ul><h4 id="示例8位-2"><strong>示例（8位）</strong></h4><ul><li><code>+5</code>：<code>0 000 0101</code>（同原码）<br /></li><li><code>-5</code>：<ol type="1"><li>原码：<code>1 000 0101</code><br /></li><li>反码：<code>1 111 1010</code><br /></li><li>补码：<code>1 111 1011</code>（反码+1）<br /></li></ol></li><li><strong>特殊值</strong>：<ul><li><code>0</code> 只有一种表示：<code>0 000 0000</code><br /></li><li><code>-128</code>：<code>1 000 0000</code>（原码无法表示，补码特有的表示方式）</li></ul></li></ul><h4 id="数值范围"><strong>数值范围</strong></h4><ul><li>对于n位补码，范围为 <code>-2ⁿ⁻¹</code> 到<code>2ⁿ⁻¹-1</code>。<br />例：8位补码范围是 <code>-128</code> 到 <code>127</code>。</li></ul><h4 id="优缺点-2"><strong>优缺点</strong></h4><ul><li><strong>优点</strong>：<ol type="1"><li><code>0</code> 的表示唯一，消除冗余。<br /></li><li>加减法统一为加法运算，无需额外判断符号。<br /></li><li>溢出处理简单（直接丢弃最高位进位）。<br /></li></ol></li><li><strong>缺点</strong>：负数转换为十进制时需按规则计算，不够直观。</li></ul><h3 id="补码的数学原理"><strong>4. 补码的数学原理</strong></h3><h4 id="模运算modulo-operation"><strong>模运算（ModuloOperation）</strong></h4><ul><li>补码本质是模运算的应用。对于n位二进制数，模为<code>2ⁿ</code>。<br /></li><li><strong>负数的补码</strong>：<code>-x ≡ 2ⁿ - x (mod 2ⁿ)</code>。<br />例：8位中 <code>-5 ≡ 256 - 5 = 251 ≡ 1111 1011₂</code>。</li></ul><h4 id="示例计算-5---3补码加法"><strong>示例：计算<code>5 - 3</code>（补码加法）</strong></h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5  →  0000 0101</span><br><span class="line"><span class="section">-3 →  1111 1101  (-3的补码)</span></span><br><span class="line"><span class="section">-----------------</span></span><br><span class="line"><span class="code">      1 0000 0010  → 溢出位丢弃，结果为 0000 0010 (2)</span></span><br></pre></td></tr></table></figure><h3 id="原码反码补码的对比"><strong>5.原码、反码、补码的对比</strong></h3><table><colgroup><col style="width: 9%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 17%" /><col style="width: 18%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th><strong>编码</strong></th><th><strong>+5（8位）</strong></th><th><strong>-5（8位）</strong></th><th><strong>0的表示</strong></th><th><strong>范围（8位）</strong></th><th><strong>运算特点</strong></th></tr></thead><tbody><tr class="odd"><td><strong>原码</strong></td><td>0000 0101</td><td>1000 0101</td><td>+0: 0000 0000<br>-0: 1000 0000</td><td>-127 ~ +127</td><td>符号位不参与运算，需单独处理</td></tr><tr class="even"><td><strong>反码</strong></td><td>0000 0101</td><td>1111 1010</td><td>+0: 0000 0000<br>-0: 1111 1111</td><td>-127 ~ +127</td><td>符号位参与运算，需循环进位</td></tr><tr class="odd"><td><strong>补码</strong></td><td>0000 0101</td><td>1111 1011</td><td>0: 0000 0000</td><td>-128 ~ +127</td><td>符号位参与运算，直接丢弃溢出位</td></tr></tbody></table><h3 id="为什么现代计算机使用补码"><strong>6.为什么现代计算机使用补码？</strong></h3><ol type="1"><li><strong>统一加减法</strong>：硬件只需实现加法器，减法通过补码转换为加法。<br /></li><li><strong>无符号与有符号运算兼容</strong>：同一套二进制电路可处理无符号数和补码有符号数。<br /></li><li><strong>消除零的歧义</strong>：补码中 <code>0</code>唯一，节省一个编码位（用于表示 <code>-2ⁿ⁻¹</code>）。<br /></li><li><strong>简化溢出判断</strong>：补码溢出规则明确（符号位进位与最高数值位进位不一致时溢出）。</li></ol><h3 id="编程中的补码应用"><strong>7. 编程中的补码应用</strong></h3><h4 id="cc-示例"><strong>C/C++ 示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> a = <span class="number">-5</span>;  <span class="comment">// 补码表示：1111 1011</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b = a;  <span class="comment">// 按位解释为无符号数：251</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);      <span class="comment">// 输出：-5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %u\n&quot;</span>, b);      <span class="comment">// 输出：251</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Binary of a: %x\n&quot;</span>, a);  <span class="comment">// 输出：0xfb (1111 1011)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-示例"><strong>Python 示例</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取整数的补码表示（以8位为例）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_twos_complement</span>(<span class="params">num, bits=<span class="number">8</span></span>):</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        num = (<span class="number">1</span> &lt;&lt; bits) + num  <span class="comment"># 2^bits + num</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(num &amp; ((<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span>))[<span class="number">2</span>:].zfill(bits)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(to_twos_complement(<span class="number">5</span>))   <span class="comment"># 输出：00000101</span></span><br><span class="line"><span class="built_in">print</span>(to_twos_complement(-<span class="number">5</span>))  <span class="comment"># 输出：11111011</span></span><br></pre></td></tr></table></figure><h3 id="总结-1"><strong>总结</strong></h3><ul><li><strong>原码</strong>：直观但运算复杂，有零的歧义。<br /></li><li><strong>反码</strong>：符号位可参与运算，但存在循环进位和零的歧义。<br /></li><li><strong>补码</strong>：现代计算机的标准表示法，统一加减法，消除零的歧义，高效处理负数。</li></ul><p>理解补码是掌握计算机底层数据表示和运算的基础，尤其在嵌入式开发、系统编程和数字电路设计中至关重要。</p><h2 id="用逻辑做加法">2.4.3 用逻辑做加法</h2><h3 id="半加器half-adder与全加器full-adder详解">半加器（HalfAdder）与全加器（Full Adder）详解</h3><h4 id="一基本概念与定义">一、基本概念与定义</h4><p><strong>半加器（Half Adder）</strong><br />-功能：对两个1位二进制数进行相加，产生<strong>和（Sum）</strong>与<strong>进位（Carry）</strong>。<br />- 输入：两个1位二进制数A、B<br />- 输出：和位S、进位位C<br />- 应用：仅适用于不需要处理低位进位的场景（如二进制加法的最低位）。</p><p><strong>全加器（Full Adder）</strong><br />-功能：对三个1位二进制数进行相加，包括两个输入位和一个来自低位的进位，产生<strong>和（Sum）</strong>与<strong>进位（Carry）</strong>。<br />- 输入：两个1位二进制数A、B，以及来自<strong>低位的进位Cin </strong> -输出：和位S、进位位Cout<br />- 应用：构建多位加法器（如4位、8位加法器）的基本单元。</p><h4 id="二半加器的设计与实现">二、半加器的设计与实现</h4><p><strong>逻辑表达式</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd><mtext>Sum</mtext></mtd><mtd><mi></mi><mo>=</mo><mi>A</mi><mo>⊕</mo><mi>B</mi><mstyle scriptlevel="0"><mspace width="1em"></mspace></mstyle><mtext>（异或运算）</mtext></mtd></mtr><mtr><mtd><mtext>Carry</mtext></mtd><mtd><mi></mi><mo>=</mo><mi>A</mi><mo>⋅</mo><mi>B</mi><mstyle scriptlevel="0"><mspace width="1em"></mspace></mstyle><mtext>（与运算）</mtext></mtd></mtr></mtable></math></p><p><strong>真值表</strong></p><table><thead><tr class="header"><th>A</th><th>B</th><th>Sum</th><th>Carry</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p><strong>逻辑门实现</strong><br />由一个异或门（XOR）和一个与门（AND）组成：<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span> ────┬─────⊕───── Sum</span><br><span class="line">      │      │</span><br><span class="line">      └───&amp;──┘</span><br><span class="line">      │      │</span><br><span class="line"><span class="selector-tag">B</span> ────┴─────┘───── Carry</span><br></pre></td></tr></table></figure></p><h4 id="三全加器的设计与实现">三、全加器的设计与实现</h4><p><strong>逻辑表达式</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd><mtext>Sum</mtext></mtd><mtd><mi></mi><mo>=</mo><mi>A</mi><mo>⊕</mo><mi>B</mi><mo>⊕</mo><mtext>Cin</mtext></mtd></mtr><mtr><mtd><mtext>Cout</mtext></mtd><mtd><mi></mi><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⋅</mo><mi>B</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>B</mi><mo>⋅</mo><mtext>Cin</mtext><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⋅</mo><mtext>Cin</mtext><mo stretchy="false">)</mo></mtd></mtr></mtable></math></p><p><strong>真值表</strong></p><table><thead><tr class="header"><th>A</th><th>B</th><th>Cin</th><th>Sum</th><th>Cout</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr class="odd"><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr class="odd"><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p><strong>逻辑门实现（两种方式）</strong><br />1. <strong>使用两个半加器级联</strong>：<br /><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A ────┬─────⊕─────┬─────⊕───── Sum</span><br><span class="line">      │      │    │      │</span><br><span class="line">      └───<span class="meta">&amp;──┘    │      │</span></span><br><span class="line">      │      │    │      │</span><br><span class="line">B ────┴─────┘    │      │</span><br><span class="line">                │      │</span><br><span class="line">            ┌───⊕──────┘</span><br><span class="line">            │   │</span><br><span class="line">            └───<span class="meta">&amp;───────── Cout</span></span><br><span class="line">            │   │</span><br><span class="line">Cin ────────┴───┘</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li><strong>直接实现</strong>：<br />由三个异或门和三个与门组成，结构更复杂但延迟更低。</li></ol><h4 id="四半加器与全加器的对比">四、半加器与全加器的对比</h4><table><thead><tr class="header"><th><strong>特性</strong></th><th><strong>半加器</strong></th><th><strong>全加器</strong></th></tr></thead><tbody><tr class="odd"><td><strong>输入数</strong></td><td>2个（A、B）</td><td>3个（A、B、Cin）</td></tr><tr class="even"><td><strong>输出数</strong></td><td>2个（Sum、Carry）</td><td>2个（Sum、Cout）</td></tr><tr class="odd"><td><strong>进位处理</strong></td><td>不处理低位进位</td><td>处理低位进位</td></tr><tr class="even"><td><strong>逻辑门数量</strong></td><td>2个（1个XOR + 1个AND）</td><td>5个（2个XOR + 3个AND）</td></tr><tr class="odd"><td><strong>应用场景</strong></td><td>二进制加法的最低位</td><td>构建多位加法器的基本单元</td></tr></tbody></table><h4 id="五多位加法器的构建">五、多位加法器的构建</h4><p><strong>4位行波进位加法器（Ripple Carry Adder）</strong><br />由4个全加器级联组成，每个全加器的进位输出连接到下一个全加器的进位输入：<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>₀ ────┐    <span class="selector-tag">A</span>₁ ────┐    <span class="selector-tag">A</span>₂ ────┐    <span class="selector-tag">A</span>₃ ────┐</span><br><span class="line">       │           │           │           │</span><br><span class="line"><span class="selector-tag">B</span>₀ ────┼── FA₀ ────┼── FA₁ ────┼── FA₂ ────┼── FA₃ ──── Cout₃</span><br><span class="line">       │           │           │           │</span><br><span class="line">Cin ───┘    Cout₀──┘    Cout₁──┘    Cout₂──┘</span><br><span class="line">       │           │           │           │</span><br><span class="line">       └── Sum₀ ───┘    └── Sum₁ ───┘    └── Sum₂ ───┘    └── Sum₃</span><br></pre></td></tr></table></figure></p><p><strong>特点</strong>：<br />- 结构简单，但进位信号需逐级传递，导致延迟较长（称为“行波延迟”）。<br />- 适用于对速度要求不高的场景，更高速的加法器可采用超前进位（CarryLookahead）设计。</p><h4 id="六应用场景">六、应用场景</h4><ol type="1"><li><strong>半加器</strong>：<ul><li>计算器的最低位加法。<br /></li><li>简单数字电路中不需要处理进位的场景。</li></ul></li><li><strong>全加器</strong>：<ul><li>CPU中的算术逻辑单元（ALU）。<br /></li><li>数字信号处理器（DSP）的运算单元。<br /></li><li>计算机内存地址计算。</li></ul></li></ol><h4 id="七verilog代码实现">七、Verilog代码实现</h4><p><strong>半加器</strong><br /><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> half_adder (</span><br><span class="line">    <span class="keyword">input</span> a, b,</span><br><span class="line">    <span class="keyword">output</span> sum, carry</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> sum = a ^ b;</span><br><span class="line">    <span class="keyword">assign</span> carry = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p><p><strong>全加器（使用半加器实例化）</strong><br /><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> full_adder (</span><br><span class="line">    <span class="keyword">input</span> a, b, cin,</span><br><span class="line">    <span class="keyword">output</span> sum, cout</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> s1, c1, c2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个半加器计算a和b</span></span><br><span class="line">    half_adder ha1 (<span class="variable">.a</span>(a), <span class="variable">.b</span>(b), <span class="variable">.sum</span>(s1), <span class="variable">.carry</span>(c1));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个半加器计算s1和cin</span></span><br><span class="line">    half_adder ha2 (<span class="variable">.a</span>(s1), <span class="variable">.b</span>(cin), <span class="variable">.sum</span>(sum), <span class="variable">.carry</span>(c2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终进位</span></span><br><span class="line">    <span class="keyword">assign</span> cout = c1 | c2;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p><h4 id="八总结">八、总结</h4><ul><li><strong>半加器</strong>是最基本的加法单元，只能处理两个1位二进制数的相加。<br /></li><li><strong>全加器</strong>通过引入进位输入，解决了多位加法中的级联问题，是构建更复杂加法器的核心。<br /></li><li>多位加法器的性能受进位传递延迟影响，现代设计通过优化进位逻辑（如超前进位）提升速度。</li></ul><p>理解半加器和全加器是掌握计算机算术运算硬件实现的基础。</p><h1 id="第3章-程序是如何执行的">第3章 程序是如何执行的</h1><h2 id="cpu中的核心部件">3.2.2 CPU中的核心部件</h2><h3id="cpu中的核心部件算术逻辑单元alu程序计数器pc与指令寄存器ir">CPU中的核心部件：算术逻辑单元（ALU）、程序计数器（PC）与指令寄存器（IR）</h3><h4id="一算术逻辑单元alu-arithmetic-logic-unit"><strong>一、算术逻辑单元（ALU,Arithmetic Logic Unit）</strong></h4><h5 id="定义与功能"><strong>1. 定义与功能</strong></h5><ul><li><strong>核心作用</strong>：执行算术运算（如加减乘除）和逻辑运算（如与、或、非、异或），是CPU数据处理的核心部件。<br /></li><li><strong>典型操作</strong>：<ul><li>算术运算：加法（ADD）、减法（SUB）、乘法（MUL）、除法（DIV）。<br /></li><li>逻辑运算：按位与（AND）、按位或（OR）、按位非（NOT）、异或（XOR）。<br /></li><li>移位操作：左移（SHL）、右移（SHR）、算术右移（SAR）。</li></ul></li></ul><h5 id="结构与工作原理"><strong>2. 结构与工作原理</strong></h5><ul><li><strong>组成部分</strong>：<ul><li><strong>运算器电路</strong>：由加法器、逻辑门（与门、或门、非门等）、多路选择器构成。<br /></li><li><strong>标志寄存器</strong>：存储运算结果的状态（如进位标志CF、零标志ZF、溢出标志OF等），供条件判断使用。<br /></li></ul></li><li><strong>工作流程</strong>：<ol type="1"><li><strong>接收操作数</strong>：从寄存器组（如R1、R2）或指令中获取数据。<br /></li><li><strong>执行运算</strong>：根据控制信号（来自控制单元）选择运算类型。<br /></li><li><strong>存储结果</strong>：将运算结果写回寄存器或内存，并更新标志位。</li></ol></li></ul><h5 id="与其他部件的协作"><strong>3. 与其他部件的协作</strong></h5><ul><li><strong>与IR的交互</strong>：IR中的指令操作码（如<code>ADD</code>）决定ALU执行的运算类型。<br /></li><li><strong>与PC的交互</strong>：运算结果影响标志位，进而控制PC是否跳转（如<code>CMP</code>指令后接<code>JZ</code>跳转）。<br /></li><li><strong>与寄存器组的交互</strong>：通过内部数据总线读取操作数，写入运算结果。</li></ul><h5 id="典型架构实现"><strong>4. 典型架构实现</strong></h5><ul><li><strong>x86架构</strong>：ALU集成在CPU核心中，支持32位/64位运算，标志寄存器为EFLAGS/RFLAGS。<br /></li><li><strong>ARM架构</strong>：ALU与移位器结合，支持流水线中的执行阶段（EX），标志位存储在CPSR寄存器。<br /></li><li><strong>RISC-V架构</strong>：ALU设计简洁，通过指令格式（如R型）直接指定操作数寄存器。</li></ul><h4id="二程序计数器pc与指令寄存器ir的补充说明"><strong>二、程序计数器（PC）与指令寄存器（IR）的补充说明</strong></h4><h5 id="pc与ir的核心定位"><strong>1. PC与IR的核心定位</strong></h5><ul><li><strong>PC</strong>：作为指令执行的“指针”，确保程序按顺序或跳转执行，是控制流的核心。<br /></li><li><strong>IR</strong>：作为指令的“暂存器”，解析当前指令的操作码和操作数，驱动ALU等部件动作。</li></ul><h5 id="三者的协同流程以add-r1-r2为例"><strong>2.三者的协同流程（以<code>ADD R1, R2</code>为例）</strong></h5><ol type="1"><li><strong>PC指向指令地址</strong>（如0x1000），内存将指令读取到IR。<br /></li><li><strong>IR解析操作码<code>ADD</code></strong>，并获取操作数寄存器R1、R2。<br /></li><li><strong>控制单元发送信号</strong>：让ALU从寄存器组读取R1和R2的值。<br /></li><li><strong>ALU执行加法运算</strong>，结果存入R1，并更新标志位（如CF、ZF）。<br /></li><li><strong>PC自动递增</strong>（如0x1000+4=0x1004），指向下一条指令。</li></ol><h4id="三alu在流水线中的作用"><strong>三、ALU在流水线中的作用</strong></h4><p>在现代CPU的多级流水线（如5级流水线）中：<br />-<strong>执行阶段（EX）</strong>：ALU在此阶段完成运算，是流水线的关键节点。<br />-<strong>数据冒险处理</strong>：若当前指令的操作数依赖前一条指令的结果（如<code>ADD R1, R2; SUB R1, R3</code>），需通过<strong>数据转发</strong>（将ALU的结果直接传给下一条指令）或暂停流水线避免错误。</p><h4 id="四核心部件对比表"><strong>四、核心部件对比表</strong></h4><table><colgroup><col style="width: 10%" /><col style="width: 31%" /><col style="width: 25%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th><strong>部件</strong></th><th><strong>功能</strong></th><th><strong>关键交互对象</strong></th><th><strong>典型架构实现</strong></th></tr></thead><tbody><tr class="odd"><td><strong>ALU</strong></td><td>执行算术/逻辑运算，更新标志位</td><td>IR、寄存器组、控制单元</td><td>x86的EAX寄存器参与运算</td></tr><tr class="even"><td><strong>PC</strong></td><td>存储下一条指令地址，控制流程</td><td>内存、控制单元</td><td>ARM的R15寄存器作为PC</td></tr><tr class="odd"><td><strong>IR</strong></td><td>存储并解析当前指令</td><td>控制单元、ALU</td><td>RISC-V流水线中的ID阶段寄存器</td></tr></tbody></table><h4id="五扩展cpu核心部件的完整体系"><strong>五、扩展：CPU核心部件的完整体系</strong></h4><p>CPU的核心部件通常包括：<br />1.<strong>控制单元（CU）</strong>：解析指令，生成控制信号，协调各部件工作。<br />2. <strong>算术逻辑单元（ALU）</strong>：处理数据运算。<br />3.<strong>寄存器组</strong>：暂存操作数和中间结果（如通用寄存器、标志寄存器）。<br />4. <strong>程序计数器（PC）</strong>：追踪指令地址。<br />5. <strong>指令寄存器（IR）</strong>：暂存当前指令。<br />6. <strong>内部总线</strong>：连接各部件，传输数据和控制信号。</p><p>这六大部件通过<strong>指令周期</strong>（取指→译码→执行→写回）协同工作，构成CPU的核心执行逻辑。</p><h2 id="汇编指令的概念">3.2.3 汇编指令的概念</h2><h3id="汇编指令详解以loadmovaddsubshiftstore为例">汇编指令详解：以LOAD、MOV、ADD、SUB、SHIFT、STORE为例</h3><h4 id="一指令分类与核心功能">一、指令分类与核心功能</h4><p>以下指令是汇编语言中最基础的操作，广泛应用于数据处理和流程控制：</p><table><colgroup><col style="width: 17%" /><col style="width: 41%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th><strong>指令类型</strong></th><th><strong>功能描述</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr class="odd"><td><strong>LOAD</strong></td><td>从内存读取数据到寄存器</td><td>初始化变量、读取数组元素</td></tr><tr class="even"><td><strong>MOV</strong></td><td>在寄存器/内存之间复制数据</td><td>数据传递、参数赋值</td></tr><tr class="odd"><td><strong>ADD/SUB</strong></td><td>执行加减法运算</td><td>数值计算、地址偏移</td></tr><tr class="even"><td><strong>SHIFT</strong></td><td>二进制移位操作（左移/右移）</td><td>快速乘除2的幂、位操作</td></tr><tr class="odd"><td><strong>STORE</strong></td><td>将寄存器数据写入内存</td><td>保存计算结果、更新数组元素</td></tr></tbody></table><h4 id="二各指令详解与示例">二、各指令详解与示例</h4><h5 id="load从内存加载数据到寄存器">1.<strong>LOAD（从内存加载数据到寄存器）</strong></h5><p><strong>功能</strong>：将内存地址中的值读取到寄存器。<br /><strong>典型语法</strong>：<code>LOAD 寄存器, [内存地址]</code><br /><strong>寻址方式</strong>：直接寻址、间接寻址、变址寻址等。</p><p><strong>示例（x86汇编）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD EAX, [1000H]      ; 直接寻址：从内存地址0x1000加载数据到EAX</span><br><span class="line">LOAD EBX, [ESI]        ; 间接寻址：从ESI指向的地址加载数据到EBX</span><br><span class="line">LOAD ECX, [ESI+4]      ; 基址+偏移：从ESI+4的地址加载数据到ECX</span><br><span class="line">LOAD EDX, [ESI+EDI*4]  ; 变址寻址：常用于数组访问（ESI为基址，EDI为索引）</span><br></pre></td></tr></table></figure></p><p><strong>等价高级语言</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = *(<span class="type">int</span>*)<span class="number">0x1000</span>;    <span class="comment">// 对应LOAD EAX, [1000H]</span></span><br><span class="line"><span class="type">int</span> b = *(<span class="type">int</span>*)esi;       <span class="comment">// 对应LOAD EBX, [ESI]</span></span><br></pre></td></tr></table></figure></p><h5 id="mov数据复制">2. <strong>MOV（数据复制）</strong></h5><p><strong>功能</strong>：在寄存器、内存、立即数之间复制数据。<br /><strong>限制</strong>：<strong>不能直接从内存到内存</strong>，必须通过寄存器中转。<br /><strong>典型语法</strong>：<code>MOV 目标, 源</code></p><p><strong>示例（x86汇编）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 10           ; 立即数→寄存器：EAX = 10</span><br><span class="line">MOV [1000H], EAX      ; 寄存器→内存：将EAX的值写入地址0x1000</span><br><span class="line">MOV EBX, EAX          ; 寄存器→寄存器：EBX = EAX</span><br><span class="line">MOV [EBX], ECX        ; 寄存器→内存：将ECX的值写入EBX指向的地址</span><br></pre></td></tr></table></figure></p><p><strong>等价高级语言</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;           <span class="comment">// 对应MOV EAX, 10</span></span><br><span class="line">*(<span class="type">int</span>*)<span class="number">0x1000</span> = a;    <span class="comment">// 对应MOV [1000H], EAX</span></span><br><span class="line"><span class="type">int</span> b = a;            <span class="comment">// 对应MOV EBX, EAX</span></span><br><span class="line">*(<span class="type">int</span>*)b = c;         <span class="comment">// 对应MOV [EBX], ECX</span></span><br></pre></td></tr></table></figure></p><h5 id="addsub加减法运算">3. <strong>ADD/SUB（加减法运算）</strong></h5><p><strong>功能</strong>：执行算术加减，结果覆盖目标操作数。<br /><strong>典型语法</strong>：<code>ADD/SUB 目标, 源</code> → 目标 = 目标 ±源</p><p><strong>示例（x86汇编）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD EAX, 5            ; EAX = EAX + 5</span><br><span class="line">SUB EBX, EAX          ; EBX = EBX - EAX</span><br><span class="line">ADD [1000H], 1        ; 内存值+1：*(int*)0x1000 += 1</span><br><span class="line">SUB ECX, [EBX]        ; ECX = ECX - *(int*)EBX</span><br></pre></td></tr></table></figure></p><p><strong>标志位影响</strong>：<br />-<strong>CF（进位标志）</strong>：无符号运算溢出时置1（如加法结果超过寄存器位宽）。<br />-<strong>OF（溢出标志）</strong>：有符号运算溢出时置1（如两个正数相加得负数）。</p><p><strong>等价高级语言</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a += <span class="number">5</span>;               <span class="comment">// 对应ADD EAX, 5</span></span><br><span class="line">b -= a;               <span class="comment">// 对应SUB EBX, EAX</span></span><br><span class="line">*(<span class="type">int</span>*)<span class="number">0x1000</span> += <span class="number">1</span>;   <span class="comment">// 对应ADD [1000H], 1</span></span><br><span class="line">c -= *(<span class="type">int</span>*)b;        <span class="comment">// 对应SUB ECX, [EBX]</span></span><br></pre></td></tr></table></figure></p><h5 id="shift移位操作">4. <strong>SHIFT（移位操作）</strong></h5><p><strong>功能</strong>：将二进制数左移/右移，可实现快速乘除2的幂。<br /><strong>典型语法</strong>：<br />- <code>SHL 目标, 位数</code> → 逻辑左移（低位补0）<br />- <code>SHR 目标, 位数</code> → 逻辑右移（高位补0）<br />- <code>SAR 目标, 位数</code> → 算术右移（保留符号位）</p><p><strong>示例（x86汇编）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHL EAX, 2            ; EAX = EAX * 4（左移2位等价于乘以2²）</span><br><span class="line">SHR EBX, 1            ; EBX = EBX / 2（无符号数）</span><br><span class="line">SAR ECX, 1            ; ECX = ECX / 2（有符号数，保留符号位）</span><br></pre></td></tr></table></figure></p><p><strong>应用场景</strong>：<br />- 快速计算乘除（如<code>x*8</code> → <code>SHL x, 3</code>）。<br />- 位掩码操作（如提取特定位）。</p><p><strong>等价高级语言</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a &lt;&lt; <span class="number">2</span>;           <span class="comment">// 对应SHL EAX, 2</span></span><br><span class="line">b = b &gt;&gt; <span class="number">1</span>;           <span class="comment">// 对应SHR EBX, 1（假设b为无符号数）</span></span><br><span class="line">c = c &gt;&gt; <span class="number">1</span>;           <span class="comment">// 对应SAR ECX, 1（假设c为有符号数）</span></span><br></pre></td></tr></table></figure></p><h5 id="store从寄存器保存数据到内存">5.<strong>STORE（从寄存器保存数据到内存）</strong></h5><p><strong>功能</strong>：将寄存器中的值写入内存地址。<br /><strong>典型语法</strong>：<code>STORE [内存地址], 寄存器</code></p><p><strong>示例（x86汇编）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STORE [1000H], EAX    ; 将EAX的值写入内存地址0x1000</span><br><span class="line">STORE [ESI+EDI*4], EBX  ; 将EBX的值写入数组索引位置（ESI为基址，EDI为索引）</span><br></pre></td></tr></table></figure></p><p><strong>等价高级语言</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">int</span>*)<span class="number">0x1000</span> = a;    <span class="comment">// 对应STORE [1000H], EAX</span></span><br><span class="line"><span class="built_in">array</span>[edi] = b;       <span class="comment">// 对应STORE [ESI+EDI*4], EBX（假设ESI指向array）</span></span><br></pre></td></tr></table></figure></p><h4id="三指令组合示例计算数组元素和">三、指令组合示例：计算数组元素和</h4><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>对应的x86汇编</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; 初始化</span><br><span class="line">MOV EAX, 0            ; EAX = sum = 0</span><br><span class="line">MOV EBX, offset array ; EBX = 数组基址</span><br><span class="line">MOV ECX, 0            ; ECX = i = 0</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">CMP ECX, 5            ; 比较i与5</span><br><span class="line">JGE end               ; 如果i≥5，跳转到end</span><br><span class="line"></span><br><span class="line">MOV EDX, [EBX+ECX*4]  ; EDX = array[i]（4字节整数）</span><br><span class="line">ADD EAX, EDX          ; sum += array[i]</span><br><span class="line">INC ECX               ; i++</span><br><span class="line">JMP loop              ; 循环</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">STORE [sum], EAX      ; 将sum结果存入内存</span><br></pre></td></tr></table></figure></p><h4 id="四不同架构的语法差异">四、不同架构的语法差异</h4><p>以<code>ADD EAX, 1</code>为例：</p><table><thead><tr class="header"><th><strong>架构</strong></th><th><strong>汇编语法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr class="odd"><td><strong>x86</strong></td><td><code>ADD EAX, 1</code></td><td>Intel风格，目标在前</td></tr><tr class="even"><td><strong>ARM</strong></td><td><code>ADD R0, R0, #1</code></td><td>AT&amp;T风格，目标在最后</td></tr><tr class="odd"><td><strong>RISC-V</strong></td><td><code>ADDI X1, X1, 1</code></td><td>立即数加法需用ADDI指令</td></tr></tbody></table><h4 id="五性能与优化考量">五、性能与优化考量</h4><ol type="1"><li><strong>LOAD/STORE延迟</strong>：内存访问比寄存器慢100倍以上，应尽量减少。<ul><li>优化方法：循环展开、数据预取。</li></ul></li><li><strong>移位替代乘除</strong>：<ul><li><code>x*8</code> → <code>SHL x, 3</code>（性能提升约3倍）。</li></ul></li><li><strong>指令流水线</strong>：<ul><li>避免指令依赖（如<code>ADD EAX, EBX; SUB ECX, EAX</code>需等待ADD完成）。</li></ul></li></ol><h4 id="六常见错误与陷阱">六、常见错误与陷阱</h4><ol type="1"><li><strong>内存对齐</strong>：<ul><li>非对齐内存访问（如读取未按4字节对齐的int）可能导致性能下降。</li></ul></li><li><strong>符号扩展</strong>：<ul><li>有符号数右移需用<code>SAR</code>，无符号数用<code>SHR</code>。</li></ul></li><li><strong>溢出处理</strong>：<ul><li>无符号运算溢出检查CF标志，有符号检查OF标志。</li></ul></li></ol><h4 id="总结-2">总结</h4><p>掌握<code>LOAD/MOV/ADD/SUB/SHIFT/STORE</code>这些基础指令是理解汇编语言的关键。它们构成了数据传输、运算和内存操作的核心，是编写高效底层代码的基石。通过合理组合这些指令，可实现从简单计算到复杂算法的各种功能，同时需注意不同架构的语法差异和性能优化技巧。</p><h2 id="控制结构的执行">3.3 控制结构的执行</h2><h3id="使用sltslebeqzgoto实现分支与循环">使用SLT、SLE、BEQZ、GOTO实现分支与循环</h3><h4 id="一指令说明">一、指令说明</h4><p>在类MIPS/RISC-V的汇编中，这些指令的功能如下： - <strong>SLT rd, rs1,rs2</strong>：如果rs1 &lt; rs2，rd=1；否则rd=0（Set on Less Than） -<strong>SLE rd, rs1, rs2</strong>：如果rs1 ≤ rs2，rd=1；否则rd=0（Set onLess or Equal） - <strong>BEQZ rs,label</strong>：如果rs=0，跳转到label（Branch if Equal to Zero） -<strong>GOTOlabel</strong>：无条件跳转到label（某些汇编中用JMP或BRA表示）</p><h4 id="二分支结构实现">二、分支结构实现</h4><h5 id="if-else结构">1. IF-ELSE结构</h5><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    c = a + b;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>汇编实现</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    SLT t0, a, b    # 如果a &lt; b，t0=1；否则t0=0</span><br><span class="line">    BEQZ t0, ELSE   # 如果t0=0（即a ≥ b），跳转到ELSE</span><br><span class="line">    ADD c, a, b     # 执行：c = a + b</span><br><span class="line">    GOTO ENDIF      # 跳过ELSE分支</span><br><span class="line">ELSE:</span><br><span class="line">    SUB c, a, b     # 执行：c = a - b</span><br><span class="line">ENDIF:</span><br><span class="line">    # 继续后续代码</span><br></pre></td></tr></table></figure></p><h5 id="多条件分支if-else-if">2. 多条件分支（IF-ELSE IF）</h5><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    b = <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>汇编实现</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    SLT t0, a, zero # 如果a &lt; 0，t0=1；否则t0=0</span><br><span class="line">    BNEZ t0, NEG    # 如果t0≠0（即a &lt; 0），跳转到NEG</span><br><span class="line">    BEQZ a, ZERO    # 如果a=0，跳转到ZERO</span><br><span class="line">    # 否则a &gt; 0</span><br><span class="line">    LI b, 1         # b = 1</span><br><span class="line">    GOTO ENDIF</span><br><span class="line">NEG:</span><br><span class="line">    LI b, -1        # b = -1</span><br><span class="line">    GOTO ENDIF</span><br><span class="line">ZERO:</span><br><span class="line">    LI b, 0         # b = 0</span><br><span class="line">ENDIF:</span><br><span class="line">    # 继续后续代码</span><br></pre></td></tr></table></figure></p><h4 id="三循环结构实现">三、循环结构实现</h4><h5 id="for循环">1. FOR循环</h5><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>汇编实现</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    LI sum, 0       # sum = 0</span><br><span class="line">    LI i, 1         # i = 1</span><br><span class="line">FOR_LOOP:</span><br><span class="line">    SLE t0, i, 10   # 如果i ≤ 10，t0=1；否则t0=0</span><br><span class="line">    BEQZ t0, END_FOR # 如果t0=0（即i &gt; 10），结束循环</span><br><span class="line">    ADD sum, sum, i # sum += i</span><br><span class="line">    ADD i, i, 1     # i++</span><br><span class="line">    GOTO FOR_LOOP   # 继续循环</span><br><span class="line">END_FOR:</span><br><span class="line">    # 继续后续代码</span><br></pre></td></tr></table></figure></p><h5 id="while循环">2. WHILE循环</h5><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fact = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    fact *= n;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>汇编实现</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    LI n, 5         # n = 5</span><br><span class="line">    LI fact, 1      # fact = 1</span><br><span class="line">WHILE_LOOP:</span><br><span class="line">    SLT t0, 1, n    # 如果1 &lt; n，t0=1；否则t0=0</span><br><span class="line">    BEQZ t0, END_WHILE # 如果t0=0（即n ≤ 1），结束循环</span><br><span class="line">    MUL fact, fact, n # fact *= n</span><br><span class="line">    SUB n, n, 1     # n--</span><br><span class="line">    GOTO WHILE_LOOP # 继续循环</span><br><span class="line">END_WHILE:</span><br><span class="line">    # 继续后续代码</span><br></pre></td></tr></table></figure></p><h5 id="do-while循环">3. DO-WHILE循环</h5><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p><strong>汇编实现</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    LI i, 1         # i = 1</span><br><span class="line">DO_LOOP:</span><br><span class="line">    # 此处为printf调用的汇编代码（略）</span><br><span class="line">    ADD i, i, 1     # i++</span><br><span class="line">    SLE t0, i, 5    # 如果i ≤ 5，t0=1；否则t0=0</span><br><span class="line">    BNEZ t0, DO_LOOP # 如果t0≠0（即i ≤ 5），继续循环</span><br><span class="line">    # 继续后续代码</span><br></pre></td></tr></table></figure></p><h4 id="四高级优化示例">四、高级优化示例</h4><h5 id="循环展开loop-unrolling">1. 循环展开（Loop Unrolling）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    LI sum, 0       # sum = 0</span><br><span class="line">    LI i, 1         # i = 1</span><br><span class="line">FOR_LOOP:</span><br><span class="line">    SLE t0, i, 10   # 检查循环条件</span><br><span class="line">    BEQZ t0, END_FOR</span><br><span class="line">    </span><br><span class="line">    # 展开两次迭代</span><br><span class="line">    ADD sum, sum, i     # sum += i</span><br><span class="line">    ADD i, i, 1         # i++</span><br><span class="line">    </span><br><span class="line">    SLE t0, i, 10       # 再次检查条件</span><br><span class="line">    BEQZ t0, END_FOR</span><br><span class="line">    </span><br><span class="line">    ADD sum, sum, i     # sum += i</span><br><span class="line">    ADD i, i, 1         # i++</span><br><span class="line">    </span><br><span class="line">    GOTO FOR_LOOP</span><br><span class="line">END_FOR:</span><br></pre></td></tr></table></figure><h5 id="条件移动替代分支">2. 条件移动替代分支</h5><p><strong>C代码</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    min = a;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    min = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>优化后的汇编</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    SLT t0, a, b    # 如果a &lt; b，t0=1；否则t0=0</span><br><span class="line">    BEQZ t0, ELSE_MIN</span><br><span class="line">    LI min, a       # min = a</span><br><span class="line">    GOTO ENDIF_MIN</span><br><span class="line">ELSE_MIN:</span><br><span class="line">    LI min, b       # min = b</span><br><span class="line">ENDIF_MIN:</span><br></pre></td></tr></table></figure></p><h4 id="五注意事项">五、注意事项</h4><ol type="1"><li><strong>标志位与条件判断</strong>：<ul><li>SLT/SLE生成临时值（0或1），需配合BEQZ使用。<br /></li><li>避免直接使用标志寄存器（如ZF），需显式比较。</li></ul></li><li><strong>无限循环风险</strong>：<ul><li>确保循环体内有更新循环变量的操作（如i++）。</li></ul></li><li><strong>指令依赖</strong>：<ul><li>避免后续指令依赖SLT/SLE的结果，可通过寄存器重命名优化。</li></ul></li></ol><h4 id="总结-3">总结</h4><p>通过SLT、SLE、BEQZ和GOTO指令，可以灵活实现分支和循环结构。关键在于：1. 使用SLT/SLE生成条件判断结果（0/1） 2. 通过BEQZ判断是否跳转 3.合理安排GOTO实现循环控制</p><p>这些指令是RISC架构中实现控制流的基础，理解其工作机制对编写高效汇编代码至关重要。</p><h2 id="函数调用过程的分析">3.5 函数调用过程的分析</h2><h3 id="函数调用过程的底层机制分析">函数调用过程的底层机制分析</h3><h4id="一函数调用的核心步骤从汇编视角">一、函数调用的核心步骤（从汇编视角）</h4><p>函数调用在底层主要通过<strong>栈操作</strong>和<strong>指令跳转</strong>实现，以类MIPS架构为例，完整流程可拆解为5个阶段：</p><ol type="1"><li><strong>参数传递</strong><ul><li>将参数按约定压入栈或存入指定寄存器（如MIPS使用<spanclass="math inline">\(a0-\)</span>a3传递前4个参数）</li><li>示例（C语言<code>int add(int a, int b)</code>）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li $a0, 5     # 第一个参数a=5存入$a0</span><br><span class="line">li $a1, 3     # 第二个参数b=3存入$a1</span><br><span class="line">jal add_func  # 跳转到add_func并保存返回地址到$ra</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>栈帧创建</strong><ul><li>被调用函数在栈中分配空间保存：<ul><li>调用者栈帧指针（$fp）</li><li>局部变量</li><li>被修改的寄存器值 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_func:</span><br><span class="line">  addi $sp, $sp, -12  # 为栈帧分配12字节空间</span><br><span class="line">  sw $fp, 8($sp)      # 保存旧栈帧指针</span><br><span class="line">  sw $ra, 4($sp)      # 保存返回地址</span><br><span class="line">  sw $s0, 0($sp)      # 保存需要保留的寄存器</span><br><span class="line">  move $fp, $sp       # 设置新栈帧指针</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><strong>指令执行</strong><ul><li>执行函数体内的逻辑，使用局部变量和参数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add $s0, $a0, $a1  # 计算a+b并存入$s0</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>返回值处理</strong><ul><li>将结果存入约定寄存器（MIPS使用<spanclass="math inline">\(v0/\)</span>v1） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move $v0, $s0      # 将计算结果存入$v0作为返回值</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>栈帧销毁与返回</strong><ul><li>恢复寄存器和栈指针，跳转回调用点 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">move $sp, $fp      # 恢复栈指针</span><br><span class="line">lw $fp, 8($sp)     # 恢复旧栈帧指针</span><br><span class="line">lw $ra, 4($sp)     # 恢复返回地址</span><br><span class="line">lw $s0, 0($sp)     # 恢复寄存器</span><br><span class="line">addi $sp, $sp, 12  # 释放栈帧空间</span><br><span class="line">jr $ra             # 跳转到返回地址继续执行</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="二栈帧stack-frame的结构解析">二、栈帧（StackFrame）的结构解析</h4><p>函数调用时栈的布局（以32位架构为例）：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>高地址</th><th>低地址</th></tr></thead><tbody><tr class="odd"><td>调用者栈帧</td><td>被调用者栈帧</td></tr><tr class="even"><td>...</td><td>$fp（旧栈帧指针）</td></tr><tr class="odd"><td></td><td><span class="math inline">\(ra（返回地址） | | |被保存的寄存器（如\)</span>s0）</td></tr><tr class="even"><td></td><td>局部变量</td></tr><tr class="odd"><td></td><td>函数参数（若超过寄存器数量）</td></tr><tr class="even"><td></td><td>...</td></tr></tbody></table><h4 id="三寄存器角色与调用约定">三、寄存器角色与调用约定</h4><p>不同寄存器在函数调用中的分工：</p><table><colgroup><col style="width: 17%" /><col style="width: 11%" /><col style="width: 71%" /></colgroup><thead><tr class="header"><th>寄存器类型</th><th>MIPS示例</th><th>作用说明</th></tr></thead><tbody><tr class="odd"><td><strong>参数寄存器</strong></td><td><span class="math inline">\(a0-\)</span>a3</td><td>传递前4个整数/指针参数，超过的参数通过栈传递</td></tr><tr class="even"><td><strong>返回值寄存器</strong></td><td><span class="math inline">\(v0-\)</span>v1</td><td>存放函数返回值，<spanclass="math inline">\(v0存整数结果，\)</span>v1存额外结果</td></tr><tr class="odd"><td><strong>链接寄存器</strong></td><td>$ra</td><td>保存调用者的下一条指令地址，用于函数返回</td></tr><tr class="even"><td><strong>栈帧指针</strong></td><td>$fp</td><td>指向当前栈帧底部，用于定位局部变量和保存的寄存器</td></tr><tr class="odd"><td><strong>调用者保存寄存器</strong></td><td><span class="math inline">\(t0-\)</span>t9</td><td>调用函数时需保存其值，被调用函数可直接修改</td></tr><tr class="even"><td><strong>被调用者保存寄存器</strong></td><td><span class="math inline">\(s0-\)</span>s7</td><td>被调用函数必须保存其原值，否则需从栈中恢复</td></tr></tbody></table><h4 id="四函数调用优化技术">四、函数调用优化技术</h4><ol type="1"><li><strong>尾调用优化（Tail Call Optimization）</strong><ul><li>当函数最后一条指令是调用另一个函数时，可复用当前栈帧<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line">func1:</span><br><span class="line">  jal func2</span><br><span class="line">  jr $ra        # 需返回func1再跳转func2</span><br><span class="line"></span><br><span class="line"># 优化后（尾调用）</span><br><span class="line">func1:</span><br><span class="line">  jr func2      # 直接跳转到func2，无需保存$ra</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>内联函数（Inlining）</strong><ul><li>将函数代码直接嵌入调用处，避免栈操作开销 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内联前</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = add(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 产生函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联后（汇编层面）</span></span><br><span class="line">main:</span><br><span class="line">  add $v0, <span class="number">1</span>, <span class="number">2</span>      # 直接执行加法，无调用开销</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>寄存器传递优化</strong><ul><li>对频繁调用的小函数，使用更多寄存器传递参数（如ARM的X0-X7）</li></ul></li></ol><h4 id="五递归函数的调用特点">五、递归函数的调用特点</h4><p>递归调用的特殊之处： 1.<strong>栈帧嵌套</strong>：每次递归调用都会创建新栈帧，需注意栈溢出风险2. <strong>参数传递</strong>：递归参数通过栈或寄存器层层传递 3.<strong>终止条件</strong>：必须有分支指令（如BEQZ）跳出递归<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 递归计算n!的汇编片段</span><br><span class="line">fact:</span><br><span class="line">  beqz $a0, base_case  # 若n=0，跳转到基准情况</span><br><span class="line">  addi $sp, $sp, -8    # 分配栈空间</span><br><span class="line">  sw $a0, 4($sp)       # 保存n</span><br><span class="line">  addi $a0, $a0, -1    # n = n-1</span><br><span class="line">  jal fact             # 递归调用fact(n-1)</span><br><span class="line">  lw $a0, 4($sp)       # 恢复n</span><br><span class="line">  addi $sp, $sp, 8     # 释放栈空间</span><br><span class="line">  mul $v0, $v0, $a0    # result = n * fact(n-1)</span><br><span class="line">  jr $ra</span><br><span class="line">base_case:</span><br><span class="line">  li $v0, 1            # 0! = 1</span><br><span class="line">  jr $ra</span><br></pre></td></tr></table></figure></p><h4 id="六不同架构的调用约定差异">六、不同架构的调用约定差异</h4><table><colgroup><col style="width: 16%" /><col style="width: 39%" /><col style="width: 16%" /><col style="width: 27%" /></colgroup><thead><tr class="header"><th>架构</th><th>参数传递方式</th><th>栈增长方向</th><th>调用约定名称</th></tr></thead><tbody><tr class="odd"><td>x86-64</td><td>前4个参数存寄存器（RCX, RDX, R8, R9），其余栈传递</td><td>高→低</td><td>System V AMD64</td></tr><tr class="even"><td>ARM64</td><td>前8个参数存X0-X7，其余栈传递</td><td>高→低</td><td>AAPCS64</td></tr><tr class="odd"><td>MIPS</td><td>前4个参数存<spanclass="math inline">\(a0-\)</span>a3，其余栈传递</td><td>低→高</td><td>O32/N32约定</td></tr><tr class="even"><td>Java VM</td><td>通过操作数栈传递参数</td><td>低→高</td><td>Java字节码约定</td></tr></tbody></table><h4 id="七函数调用的性能开销">七、函数调用的性能开销</h4><p>一次函数调用的典型开销包括： -<strong>时间开销</strong>：栈操作（约20-50周期）、指令跳转（5-10周期） -<strong>空间开销</strong>：每个栈帧约16-64字节 -<strong>流水线开销</strong>：跳转导致流水线冲刷（约15-30周期）</p><p>优化策略： 1. 减少小函数调用（如内联） 2. 使用寄存器传递更多参数 3.避免递归深度过大 4. 合并频繁调用的函数</p><h4 id="总结-4">总结</h4><p>函数调用的本质是<strong>执行上下文的切换</strong>，通过栈和寄存器完成：1. 用栈帧管理局部状态 2. 用寄存器传递关键数据 3.用跳转指令控制执行流</p><p>理解这一机制对优化程序性能、调试段错误（SegmentationFault）、分析递归问题至关重要。不同架构的差异主要体现在寄存器分配和栈操作细节上，但核心原理一致。</p><h1 id="第4章-学习python语言">第4章 学习Python语言</h1><p>由于本内容在另一课程中已有讲述，故不在此复习。</p><h1 id="第5章-计算思维的核心算法">第5章 计算思维的核心——算法</h1><h2 id="递归法">5.2 递归法</h2><h3 id="递归法的全面解析">递归法的全面解析</h3><h4 id="一递归法的基本定义">一、递归法的基本定义</h4><p>递归法是一种通过将复杂问题分解为<strong>相同类型的子问题</strong>来求解的方法。其核心思想是让函数<strong>直接或间接调用自身</strong>，直到满足特定的终止条件。递归法在数学和计算机科学中广泛应用，本质上是利用<strong>自相似性</strong>将问题层层分解。</p><h4 id="二递归法的三大要素">二、递归法的三大要素</h4><ol type="1"><li><strong>递归终止条件</strong><br />必须存在明确的条件，使递归过程停止，避免无限循环。例如计算阶乘时，<code>n=0</code>或<code>n=1</code>时返回1。</li><li><strong>递归关系式</strong><br />定义大问题与子问题之间的关系，如斐波那契数列中<code>f(n) = f(n-1) + f(n-2)</code>。</li><li><strong>数据规模递减</strong><br />每次递归调用必须使问题的规模严格减小，确保终止条件最终被触发。</li></ol><h4id="三递归法的执行原理以阶乘计算为例">三、递归法的执行原理（以阶乘计算为例）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:  <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n-<span class="number">1</span>)  <span class="comment"># 递归调用</span></span><br></pre></td></tr></table></figure><ul><li><strong>执行过程</strong>：<br />计算<code>factorial(3)</code>时，会分解为：<br /><code>3 * factorial(2)</code> → <code>3 * (2 * factorial(1))</code> →<code>3 * (2 * 1)</code> → 最终结果为6。</li><li><strong>调用栈机制</strong>：<br />每次递归调用会在内存栈中压入当前状态，直到终止条件触发后逐层返回结果，类似“递推-回归”的过程。</li></ul><h4 id="四递归法的典型应用场景">四、递归法的典型应用场景</h4><table><colgroup><col style="width: 17%" /><col style="width: 38%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th>应用领域</th><th>具体案例</th><th>递归实现优势</th></tr></thead><tbody><tr class="odd"><td>数学问题</td><td>阶乘、斐波那契数列、汉诺塔</td><td>直接对应数学定义，代码简洁</td></tr><tr class="even"><td>数据结构</td><td>树/图的遍历（前序、中序、后序）</td><td>天然匹配树形结构的自相似特性</td></tr><tr class="odd"><td>算法设计</td><td>分治法（归并排序、快速排序）</td><td>将问题分解为子问题，降低设计复杂度</td></tr><tr class="even"><td>字符串处理</td><td>回文字符串检测、括号匹配</td><td>递归处理嵌套结构更直观</td></tr><tr class="odd"><td>动态规划</td><td>最优子结构问题的状态转移</td><td>递归+记忆化可优化重复计算</td></tr></tbody></table><h4 id="五递归法的优缺点分析">五、递归法的优缺点分析</h4><ul><li><strong>优点</strong>：<ul><li>代码逻辑简洁，符合人类对问题的分解思维。<br /></li><li>适合处理具有自相似结构的问题（如分形几何、递归图形）。<br /></li><li>便于证明算法正确性（数学归纳法思想）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>空间复杂度高</strong>：递归调用会占用栈空间，可能导致栈溢出（如深度过大的树遍历）。<br /></li><li><strong>时间效率低</strong>：存在重复计算（如斐波那契数列递归实现的时间复杂度为指数级）。<br /></li><li>调试困难：多层调用链难以追踪中间状态。</li></ul></li></ul><h4 id="六递归优化技巧">六、递归优化技巧</h4><ol type="1"><li><strong>记忆化递归（Memoization）</strong><ul><li>存储已计算的子问题结果，避免重复计算。<br /></li><li>示例：斐波那契数列优化（时间复杂度从O(2ⁿ)降至O(n)）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n, memo=&#123;&#125;</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    memo[n] = fib(n-<span class="number">1</span>, memo) + fib(n-<span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>尾递归优化（Tail Recursion）</strong><ul><li>若递归调用是函数的最后一步操作，编译器可将其优化为循环，避免栈增长。<br /></li><li>示例（阶乘的尾递归实现）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_tail</span>(<span class="params">n, result=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> factorial_tail(n-<span class="number">1</span>, n * result)</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>递归转迭代</strong><ul><li>手动使用栈模拟递归过程，降低空间复杂度。<br /></li><li>例如二叉树后序遍历的递归转迭代实现。</li></ul></li></ol><h4 id="七经典递归问题示例">七、经典递归问题示例</h4><ol type="1"><li><strong>汉诺塔问题</strong><ul><li>规则：将n个盘子从柱A移到柱C，每次只能移动一个盘子，且小盘子必须在大盘子上方。<br /></li><li>递归思路：先将n-1个盘子从A移到B，再将第n个盘子从A移到C，最后将n-1个盘子从B移到C。</li></ul></li><li><strong>分形图形（谢尔宾斯基三角形）</strong><ul><li>递归过程：将三角形分成4个小三角形，递归绘制每个小三角形的内部结构。</li></ul></li><li><strong>八皇后问题</strong><ul><li>使用递归回溯算法，逐行放置皇后并检查冲突，不满足条件时回退重试。</li></ul></li></ol><h4 id="八递归与迭代的选择策略">八、递归与迭代的选择策略</h4><ul><li><strong>优先使用递归</strong>：<ul><li>问题具有明显的递归结构（如树、分形）。<br /></li><li>代码可读性比性能更重要（如教学场景）。</li></ul></li><li><strong>优先使用迭代</strong>：<ul><li>对时间/空间效率要求高（如生产环境算法）。<br /></li><li>递归深度可能超过系统栈限制（如处理大规模数据）。</li></ul></li></ul><h4 id="九递归法的思维训练建议">九、递归法的思维训练建议</h4><ol type="1"><li><strong>从数学归纳法切入</strong>：理解“假设n=k时成立，证明n=k+1时成立”与递归终止条件+递归式的对应关系。<br /></li><li><strong>绘制调用栈图</strong>：通过可视化递归过程，理解参数传递和返回值的流动。<br /></li><li><strong>从小问题开始实践</strong>：先实现阶乘、斐波那契等简单案例，再挑战汉诺塔、回溯算法等复杂问题。<br /></li><li><strong>对比递归与迭代实现</strong>：分析同一问题两种解法的效率差异，加深对递归代价的理解。</li></ol><p>递归法是计算机科学中的核心思想之一，掌握其原理不仅能提升算法设计能力，还能培养分解复杂问题的思维方式。在实际应用中，需根据问题特性和性能要求灵活选择递归或迭代方案。</p><h2 id="分治法">5.3 分治法</h2><h3id="分治法的深度解析从理论到实践">分治法的深度解析：从理论到实践</h3><h4 id="一分治法的核心定义与思想">一、分治法的核心定义与思想</h4><p>分治法（Divide andConquer）是一种将<strong>复杂问题分解为若干相似子问题</strong>，通过求解子问题再合并结果的算法策略。其核心流程遵循三步法则：1.<strong>分解（Divide）</strong>：将原问题拆分为若干规模更小、结构相同的子问题2.<strong>解决（Conquer）</strong>：递归求解每个子问题（若子问题足够小则直接求解）3. <strong>合并（Combine）</strong>：将子问题的解合并为原问题的解</p><p>分治法与递归法的关系：<strong>分治法通常通过递归实现</strong>，但更强调子问题的独立性和结果合并的策略。</p><h4 id="二分治法的三大关键要素">二、分治法的三大关键要素</h4><ol type="1"><li><strong>子问题的独立性</strong><br />分解后的子问题应相互独立，避免重复计算（与动态规划的重叠子问题不同）。</li><li><strong>平衡的子问题划分</strong><br />理想情况下子问题规模相等，以最小化递归深度（如二分法）。</li><li><strong>高效的合并策略</strong><br />合并操作的时间复杂度直接影响分治法的整体效率，例如归并排序的合并步骤为O(n)。</li></ol><h4id="三分治法的执行原理以归并排序为例">三、分治法的执行原理（以归并排序为例）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="comment"># 分解：找到中点将数组分为两半</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(arr[:mid])</span><br><span class="line">    right = merge_sort(arr[mid:])</span><br><span class="line">    <span class="comment"># 合并：将两个有序数组合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li><strong>分解过程</strong>：将长度为n的数组不断二分，直到子数组长度为1（直接解决）</li><li><strong>合并过程</strong>：通过双指针法将两个有序子数组合并，时间复杂度O(n)</li><li><strong>整体复杂度</strong>：O(n logn)，满足主定理T(n)=2T(n/2)+O(n)</li></ul><h4 id="四分治法的典型应用场景">四、分治法的典型应用场景</h4><table><colgroup><col style="width: 18%" /><col style="width: 36%" /><col style="width: 45%" /></colgroup><thead><tr class="header"><th>应用领域</th><th>具体算法/问题</th><th>分治策略解析</th></tr></thead><tbody><tr class="odd"><td>排序与查找</td><td>归并排序、快速排序、二分查找</td><td>排序：分解为子数组排序+合并；查找：每次排除一半数据</td></tr><tr class="even"><td>数学计算</td><td>大数乘法（Karatsuba算法）</td><td>将n位乘法分解为3次n/2位乘法</td></tr><tr class="odd"><td>几何问题</td><td>凸包计算（Graham扫描法）</td><td>分解平面点集为上下凸包再合并</td></tr><tr class="even"><td>矩阵运算</td><td>Strassen矩阵乘法</td><td>将n×n矩阵乘法分解为7次n/2×n/2乘法</td></tr><tr class="odd"><td>数据结构</td><td>线段树构建</td><td>递归划分区间并存储区间信息</td></tr></tbody></table><h4id="五分治法的复杂度分析与优缺点">五、分治法的复杂度分析与优缺点</h4><ul><li><strong>时间复杂度分析</strong><br />利用<strong>主定理（Master Theorem）</strong> 求解递归式：<br />若T(n)=aT(n/b)+f(n)，其中a≥1,b&gt;1：<ul><li>若f(n)=O(n^c)且c&lt;log_b a，则T(n)=Θ(n^log_b a)</li><li>若f(n)=Θ(n^log_b a)，则T(n)=Θ(n^log_b a log n)</li><li>若f(n)=Ω(n^c)且c&gt;log_b a，且af(n/b)≤kf(n)，则T(n)=Θ(f(n))</li></ul></li><li><strong>优点</strong>：<ul><li>算法逻辑清晰，符合结构化问题分解思维<br /></li><li>可利用并行计算优化（子问题独立可并行求解）<br /></li><li>适合处理具有空间局部性的数据（如二维分治）</li></ul></li><li><strong>缺点</strong>：<ul><li>合并步骤可能带来额外开销（如归并排序的空间O(n)）<br /></li><li>小问题场景下效率可能低于简单算法（如n较小时插入排序比归并排序更快）<br /></li><li>递归深度过大会导致栈溢出（需手动优化为迭代）</li></ul></li></ul><h4 id="六分治法的优化策略">六、分治法的优化策略</h4><ol type="1"><li><strong>减少子问题数量</strong><ul><li>例：Strassen矩阵乘法将传统8次子矩阵乘法优化为7次，复杂度从O(n³)降至O(n^2.807)</li></ul></li><li><strong>优化合并过程</strong><ul><li>例：在二维最近点对问题中，合并步骤通过排序预处理将O(n²)优化为O(n logn)</li></ul></li><li><strong>设定递归终止阈值</strong><ul><li>当问题规模小于阈值时改用迭代算法（如归并排序中n&lt;16时改用插入排序）</li></ul></li></ol><h4 id="七经典分治问题示例">七、经典分治问题示例</h4><ol type="1"><li><strong>棋盘覆盖问题</strong><ul><li>问题：用L型骨牌覆盖2<sup>n×2</sup>n棋盘上除一个特殊点外的所有格子<br /></li><li>分治策略：将棋盘分为4个子棋盘，在交汇点放置骨牌，递归处理每个子棋盘</li></ul></li><li><strong>快速排序的分治实现</strong><ul><li>分解：通过枢轴元素将数组分为小于/大于两部分<br /></li><li>解决：递归排序左右子数组<br /></li><li>合并：无需合并（原地排序）</li></ul></li><li><strong>二维平面最接近点对</strong><ul><li>分解：按x坐标排序后用中线分为左右两部分<br /></li><li>解决：递归求左右子区域最接近点对d1,d2，取d=min(d1,d2)<br /></li><li>合并：检查中线左右d范围内的点，计算跨区域点对距离</li></ul></li></ol><h4 id="八分治法与动态规划的对比">八、分治法与动态规划的对比</h4><table><colgroup><col style="width: 21%" /><col style="width: 40%" /><col style="width: 38%" /></colgroup><thead><tr class="header"><th>特征</th><th>分治法</th><th>动态规划</th></tr></thead><tbody><tr class="odd"><td>子问题性质</td><td>相互独立</td><td>存在重叠子问题</td></tr><tr class="even"><td>存储需求</td><td>无需存储中间结果</td><td>需要存储子问题解（表格）</td></tr><tr class="odd"><td>递归方向</td><td>自顶向下（Top-Down）</td><td>自底向上（Bottom-Up）</td></tr><tr class="even"><td>典型应用</td><td>归并排序、二分查找</td><td>斐波那契数列、背包问题</td></tr><tr class="odd"><td>复杂度关键</td><td>合并效率</td><td>状态转移方程设计</td></tr></tbody></table><h4 id="九分治法的实践与思维训练">九、分治法的实践与思维训练</h4><ol type="1"><li><strong>从二分法入手</strong>：掌握最基础的分治思想（每次排除一半解空间）</li><li><strong>绘制递归树</strong>：通过可视化分解过程理解复杂度来源（如归并排序的递归树深度为logn）</li><li><strong>对比不同分治策略</strong>：例如快速排序的随机枢轴与三数取中策略对效率的影响</li><li><strong>挑战高级问题</strong>：尝试实现Strassen算法或二维凸包计算，理解多维分治的复杂性</li></ol><h4 id="十分治法的现实应用拓展">十、分治法的现实应用拓展</h4><ul><li><strong>大数据处理</strong>：MapReduce框架本质上是分治思想的分布式实现（Map分解任务，Reduce合并结果）</li><li><strong>图像处理</strong>：金字塔分层处理、图像压缩（如JPEG的DCT变换分块）</li><li><strong>网络路由</strong>：层次化路由协议（如OSPF将网络分解为区域）</li></ul><p>分治法作为算法设计的核心范式，其思想不仅适用于编程问题，还能帮助解决现实中的复杂决策场景。通过理解“分解-求解-合并”的递归逻辑，可有效提升处理大规模问题的系统性思维能力。</p><h2 id="动态规划">5.5 动态规划</h2><h3id="动态规划dynamic-programming深度解析从原理到实战">动态规划（DynamicProgramming）深度解析：从原理到实战</h3><h4 id="一动态规划的核心定义与思想">一、动态规划的核心定义与思想</h4><p>动态规划（DP）是一种通过将<strong>复杂问题分解为重叠子问题</strong>，并利用子问题的解避免重复计算的算法策略。其核心思想可概括为：1. <strong>重叠子问题</strong>：问题包含大量重复计算的子问题 2.<strong>最优子结构</strong>：问题的最优解包含子问题的最优解 3.<strong>状态转移</strong>：通过定义状态和转移方程连接子问题的解</p><p>与分治法的本质区别：<br />-分治法处理<strong>独立子问题</strong>（如归并排序），无需存储中间结果<br />-动态规划处理<strong>重叠子问题</strong>，必须存储子问题解以避免重复计算</p><h4 id="二动态规划的三大核心要素">二、动态规划的三大核心要素</h4><ol type="1"><li><strong>状态定义</strong><ul><li>用数学符号（如<code>dp[i]</code>、<code>dp[i][j]</code>）表示子问题的解<br /></li><li>例：<code>dp[i]</code>表示长度为i的字符串的解码方式数<br /></li></ul></li><li><strong>状态转移方程</strong><ul><li>描述大问题与子问题之间的关系，是DP的核心<br /></li><li>例：斐波那契数列<code>dp[i] = dp[i-1] + dp[i-2]</code><br /></li></ul></li><li><strong>边界条件</strong><ul><li>最小子问题的直接解（递归终止条件）<br /></li><li>例：<code>dp[0] = 0</code>,<code>dp[1] = 1</code>（斐波那契初始条件）</li></ul></li></ol><h4 id="三动态规划的两种实现方式">三、动态规划的两种实现方式</h4><h5 id="自顶向下记忆化搜索">1. 自顶向下（记忆化搜索）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记忆化搜索实现斐波那契数列</span></span><br><span class="line">memo = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_memo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        result = n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = fib_memo(n-<span class="number">1</span>) + fib_memo(n-<span class="number">2</span>)</span><br><span class="line">    memo[n] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：代码逻辑接近递归，易于理解<br /></li><li><strong>缺点</strong>：递归可能导致栈溢出，空间开销较大（存储备忘录）</li></ul><h5 id="自底向上表格法">2. 自底向上（表格法）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表格法实现斐波那契数列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_table</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：无递归开销，空间可优化（如滚动数组）<br /></li><li><strong>缺点</strong>：状态转移逻辑需显式推导</li></ul><h4id="四动态规划的解题步骤以0-1背包问题为例">四、动态规划的解题步骤（以0-1背包问题为例）</h4><ol type="1"><li><strong>问题定义</strong><ul><li>有n个物品，重量<code>w[i]</code>，价值<code>v[i]</code>，背包容量W，求最大价值<br /></li></ul></li><li><strong>状态定义</strong><ul><li><code>dp[i][j]</code>：前i个物品放入容量j的背包的最大价值<br /></li></ul></li><li><strong>状态转移方程</strong><ul><li>不选第i个物品：<code>dp[i][j] = dp[i-1][j]</code><br /></li><li>选第i个物品：<code>dp[i][j] = dp[i-1][j-w[i]] + v[i]</code>（当j≥w[i]）<br /></li><li>最终方程：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])</code><br /></li></ul></li><li><strong>边界条件</strong><ul><li><code>dp[0][j] = 0</code>（无物品时价值为0），<code>dp[i][0] = 0</code>（容量为0时价值为0）<br /></li></ul></li><li><strong>填表顺序</strong><ul><li>按行i从1到n，列j从1到W依次计算</li></ul></li></ol><h5 id="表格法实现代码">表格法实现代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_01</span>(<span class="params">w, v, W</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(w)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> w[i-<span class="number">1</span>] &lt;= j:  <span class="comment"># 第i个物品可放入</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]] + v[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br></pre></td></tr></table></figure><h4 id="五动态规划的典型应用场景">五、动态规划的典型应用场景</h4><table><colgroup><col style="width: 19%" /><col style="width: 32%" /><col style="width: 47%" /></colgroup><thead><tr class="header"><th>问题类型</th><th>经典问题</th><th>状态定义示例</th></tr></thead><tbody><tr class="odd"><td><strong>优化问题</strong></td><td>0-1背包、最长递增子序列</td><td><code>dp[i]</code>：以第i个元素结尾的最长长度</td></tr><tr class="even"><td><strong>计数问题</strong></td><td>不同路径、字符串解码</td><td><code>dp[i]</code>：前i个字符的解码方式数</td></tr><tr class="odd"><td><strong>决策问题</strong></td><td>硬币找零、矩阵链乘法</td><td><code>dp[i][j]</code>：i到j矩阵链的最小乘法次数</td></tr><tr class="even"><td><strong>字符串问题</strong></td><td>编辑距离、最长公共子序列</td><td><code>dp[i][j]</code>：前i和前j个字符的最优解</td></tr><tr class="odd"><td><strong>图论问题</strong></td><td>最短路径（Floyd-Warshall）</td><td><code>dp[i][j][k]</code>：i到j经k的最短路径</td></tr></tbody></table><h4id="六动态规划的复杂度分析与优化">六、动态规划的复杂度分析与优化</h4><ul><li><strong>时间复杂度</strong><br />由状态数×每个状态的转移次数决定：<ul><li>例：0-1背包状态数O(nW)，转移O(1)，总复杂度O(nW)<br /></li><li>例：最长公共子序列（LCS）状态数O(mn)，转移O(1)，总复杂度O(mn)</li></ul></li><li><strong>空间优化技巧</strong><ol type="1"><li><strong>滚动数组</strong>：将二维状态压缩为一维（如0-1背包可优化为O(W)空间）<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_01_optimized</span>(<span class="params">w, v, W</span>):</span><br><span class="line">    dp = [<span class="number">0</span>]*(W+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">        <span class="comment"># 逆序遍历避免重复使用当前物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W, w[i]-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i]] + v[i])</span><br><span class="line">    <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure></li><li><strong>只保留必要历史状态</strong>：如斐波那契数列仅需保存前两个值</li></ol></li></ul><h4 id="七动态规划与分治法的对比">七、动态规划与分治法的对比</h4><table><colgroup><col style="width: 21%" /><col style="width: 38%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th>特征</th><th>动态规划</th><th>分治法</th></tr></thead><tbody><tr class="odd"><td><strong>子问题性质</strong></td><td>重叠子问题（重复计算）</td><td>独立子问题</td></tr><tr class="even"><td><strong>存储需求</strong></td><td>必须存储子问题解（表格）</td><td>无需存储中间结果</td></tr><tr class="odd"><td><strong>递归方向</strong></td><td>自底向上（表格法为主）</td><td>自顶向下（递归分解）</td></tr><tr class="even"><td><strong>典型应用</strong></td><td>背包问题、LCS</td><td>归并排序、二分查找</td></tr><tr class="odd"><td><strong>关键步骤</strong></td><td>状态转移方程设计</td><td>子问题合并策略</td></tr></tbody></table><h4 id="八动态规划的难点与突破策略">八、动态规划的难点与突破策略</h4><ol type="1"><li><strong>状态定义的核心技巧</strong><ul><li>从问题目标倒推：如“求前i个元素的最优解”<br /></li><li>引入维度表示“决策”：如背包问题中的“选/不选第i个物品”</li></ul></li><li><strong>转移方程推导方法</strong><ul><li><strong>分类讨论</strong>：枚举最后一步决策（如选或不选某个物品）<br /></li><li><strong>数学归纳</strong>：假设<code>dp[i-1]</code>已知，推导<code>dp[i]</code>的关系<br /></li><li><strong>参考经典模型</strong>：如完全背包、区间DP、树形DP</li></ul></li><li><strong>常见错误与规避</strong><ul><li>遗漏边界条件：通过小数据手动验证（如n=0, n=1的情况）<br /></li><li>状态转移顺序错误：确保计算<code>dp[i]</code>时依赖的<code>dp[j]</code>已求解<br /></li><li>维度冗余：用滚动数组简化状态表示</li></ul></li></ol><h4 id="九经典动态规划问题解析">九、经典动态规划问题解析</h4><ol type="1"><li><strong>最长公共子序列（LCS）</strong><ul><li>状态：<code>dp[i][j]</code>为字符串A前i个字符与B前j个字符的LCS长度<br /></li><li>转移：若A[i]=B[j]，则<code>dp[i][j]=dp[i-1][j-1]+1</code>；否则<code>dp[i][j]=max(dp[i-1][j], dp[i][j-1])</code><br /></li><li>复杂度：O(mn)</li></ul></li><li><strong>编辑距离（Levenshtein Distance）</strong><ul><li>状态：<code>dp[i][j]</code>为将A前i字符转为B前j字符的最小操作数<br /></li><li>转移：插入<code>dp[i][j]=dp[i][j-1]+1</code>，删除<code>dp[i][j]=dp[i-1][j]+1</code>，替换<code>dp[i][j]=dp[i-1][j-1]+(A[i]≠B[j])</code><br /></li><li>复杂度：O(mn)</li></ul></li><li><strong>硬币找零（最少硬币数）</strong><ul><li>状态：<code>dp[j]</code>为组成金额j的最少硬币数<br /></li><li>转移：<code>dp[j] = min(dp[j-coin]+1 for coin in coins if j≥coin)</code><br /></li><li>复杂度：O(n×amount)，n为硬币种类</li></ul></li></ol><h4 id="十动态规划的现实应用拓展">十、动态规划的现实应用拓展</h4><ul><li><strong>金融领域</strong>：期权定价（Black-Scholes模型的离散化求解）<br /></li><li><strong>自然语言处理</strong>：分词算法（如维特比算法求解最优分词路径）<br /></li><li><strong>计算机视觉</strong>：图像分割（基于能量函数的动态规划优化）<br /></li><li><strong>资源分配</strong>：任务调度、网络带宽分配的最优决策</li></ul><p>动态规划的核心魅力在于将“重复计算”转化为“记忆复用”，其思维方式不仅适用于算法问题，更能帮助解决现实中具有递推性质的复杂决策。掌握状态定义与转移方程的设计，需要通过大量经典问题的练习（如LeetCode动态规划专题）积累经验，逐步形成“从子问题构建全局解”的系统性思维。</p><h1 id="第6章-操作系统简介">第6章 操作系统简介</h1><h2 id="操作系统对硬件资源的管理硬件中断与异常">6.3操作系统对硬件资源的管理——硬件中断与异常</h2><h3id="操作系统对io设备cpu内存的管理">操作系统对IO设备、CPU、内存的管理</h3><h4 id="一io设备管理">一、IO设备管理</h4><p><strong>核心目标</strong>：隐藏硬件细节，提供统一接口，优化IO效率，确保设备资源的合理分配。</p><h5 id="io设备分类">1. IO设备分类</h5><table><colgroup><col style="width: 26%" /><col style="width: 40%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th><strong>分类维度</strong></th><th><strong>类型</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr class="odd"><td><strong>传输速率</strong></td><td>低速设备</td><td>键盘、鼠标</td></tr><tr class="even"><td></td><td>中速设备</td><td>打印机、扫描仪</td></tr><tr class="odd"><td></td><td>高速设备</td><td>硬盘、网卡、SSD</td></tr><tr class="even"><td><strong>数据传输方式</strong></td><td>块设备（按块读写）</td><td>硬盘、U盘</td></tr><tr class="odd"><td></td><td>字符设备（按字符读写）</td><td>键盘、串口</td></tr><tr class="even"><td><strong>共享属性</strong></td><td>独占设备</td><td>打印机、磁带机</td></tr><tr class="odd"><td></td><td>共享设备</td><td>硬盘、网卡</td></tr></tbody></table><h5 id="设备管理关键机制">2. 设备管理关键机制</h5><ul><li><strong>设备驱动程序（Device Driver）</strong><ul><li><strong>作用</strong>：屏蔽硬件差异，为上层提供统一接口（如Linux的<code>read/write</code>系统调用）。<br /></li><li><strong>层次结构</strong>：用户层驱动（如CUPS打印系统）→内核层驱动（如块设备驱动）→ 硬件抽象层。</li></ul></li><li><strong>IO控制方式</strong><ol type="1"><li><strong>程序直接控制（轮询）</strong>：CPU持续查询设备状态，效率低（如早期打印机控制）。<br /></li><li><strong>中断驱动</strong>：设备完成任务后发送中断，CPU无需轮询（如键盘输入）。<br /></li><li><strong>DMA（直接内存访问）</strong>：设备通过DMA控制器直接与内存交互，减少CPU干预（如硬盘读写）。</li></ol></li><li><strong>缓冲技术</strong><ul><li><strong>单缓冲/双缓冲</strong>：缓解CPU与低速设备的速度不匹配（如打印缓冲区）。<br /></li><li><strong>循环缓冲</strong>：适用于连续数据传输（如音频流处理）。<br /></li><li><strong>缓冲池</strong>：多个缓冲区共享，提高资源利用率（如Linux的pagecache）。</li></ul></li></ul><h5 id="io调度算法">3. IO调度算法</h5><ul><li><strong>FCFS（先来先服务）</strong>：按请求顺序处理，简单但可能导致“磁臂抖动”。<br /></li><li><strong>SSTF（最短寻道时间优先）</strong>：优先处理离当前磁头最近的请求，可能导致某些请求饥饿。<br /></li><li><strong>SCAN（电梯算法）</strong>：磁头沿一个方向移动，处理所有请求后反转方向（如硬盘调度）。<br /></li><li><strong>CFQ（完全公平队列）</strong>：Linux默认算法，按进程分组调度，兼顾公平性与性能。</li></ul><h5 id="现代io优化技术">4. 现代IO优化技术</h5><ul><li><strong>异步IO（AIO）</strong>：允许应用程序提交IO请求后继续执行，完成时通过回调通知（如Node.js的IO模型）。<br /></li><li><strong>零拷贝（ZeroCopy）</strong>：数据不经过用户态内存拷贝，直接在内核空间传输（如Linux的<code>sendfile</code>系统调用）。<br /></li><li><strong>热插拔（HotPlug）</strong>：支持设备在运行时插入/移除（如USB、PCIe热插拔），通过<code>udev</code>机制动态管理。</li></ul><h4 id="二cpu管理进程与线程调度">二、CPU管理（进程与线程调度）</h4><p><strong>核心目标</strong>：实现多任务并发执行，最大化CPU利用率，保证响应时间与公平性。</p><h5 id="进程调度层级">1. 进程调度层级</h5><ul><li><strong>长程调度（作业调度）</strong>：决定哪些进程从外存调入内存（如批处理系统中的作业队列管理）。<br /></li><li><strong>中程调度（内存调度）</strong>：决定进程是否换出到外存（如虚拟内存中的页面置换）。<br /></li><li><strong>短程调度（CPU调度）</strong>：决定哪个就绪进程占用CPU（如时间片轮转、优先级调度）。</li></ul><h5 id="进程调度算法">2. 进程调度算法</h5><table><colgroup><col style="width: 14%" /><col style="width: 27%" /><col style="width: 19%" /><col style="width: 19%" /><col style="width: 19%" /></colgroup><thead><tr class="header"><th><strong>算法类型</strong></th><th><strong>核心思想</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr class="odd"><td><strong>FCFS</strong></td><td>按进程到达顺序调度</td><td>实现简单</td><td>平均等待时间长</td><td>批处理系统</td></tr><tr class="even"><td><strong>时间片轮转（RR）</strong></td><td>每个进程分配固定时间片（如10ms）</td><td>响应时间短</td><td>上下文切换开销大</td><td>交互式系统（如Linux的SCHED_OTHER）</td></tr><tr class="odd"><td><strong>优先级调度</strong></td><td>按优先级分配CPU</td><td>重要任务优先执行</td><td>低优先级可能饥饿</td><td>实时系统（如SCHED_FIFO）</td></tr><tr class="even"><td><strong>多级反馈队列</strong></td><td>动态调整进程优先级与时间片</td><td>兼顾响应时间与吞吐量</td><td>算法复杂</td><td>通用操作系统</td></tr></tbody></table><h5 id="上下文切换context-switch">3. 上下文切换（Context Switch）</h5><ul><li><strong>过程</strong>：<ol type="1"><li>保存当前进程的CPU状态（寄存器、程序计数器、栈指针等）。<br /></li><li>加载新进程的CPU状态。<br /></li><li>更新MMU（内存管理单元）映射，切换地址空间。<br /></li></ol></li><li><strong>开销</strong>：一次切换约耗时1-10微秒，频繁切换会导致“调度开销”（如RR算法的时间片过短）。</li></ul><h5 id="多核cpu调度优化">4. 多核CPU调度优化</h5><ul><li><strong>处理器亲和性（ProcessorAffinity）</strong>：将进程固定在特定CPU核心，减少缓存失效（如Linux的<code>sched_setaffinity</code>）。<br /></li><li><strong>负载均衡（LoadBalancing）</strong>：在多核间动态分配就绪进程，避免核心闲置（如Linux的<code>load_balance</code>机制）。<br /></li><li><strong>超线程（Hyper-Threading）</strong>：单个物理核心模拟多个逻辑核心，提高指令级并行（如Intel的HT技术）。</li></ul><h5 id="实时调度">5. 实时调度</h5><ul><li><strong>硬实时</strong>：必须在截止时间内完成（如工业控制系统），采用固定优先级调度（如SCHED_FIFO）。<br /></li><li><strong>软实时</strong>：尽量在截止时间内完成（如视频播放），采用动态优先级调度（如Linux的SCHED_RR）。</li></ul><h4 id="三内存管理">三、内存管理</h4><p><strong>核心目标</strong>：高效分配内存空间，隔离进程地址空间，支持大程序运行（虚拟内存）。</p><h5 id="内存管理模式">1. 内存管理模式</h5><ul><li><strong>连续分配</strong><ul><li><strong>单一分区</strong>：内存分为系统区和用户区，仅支持单进程（如早期DOS）。<br /></li><li><strong>固定分区</strong>：内存划分为多个固定大小分区，进程装入匹配分区（效率低）。<br /></li><li><strong>动态分区</strong>：根据进程需求划分分区，采用首次适应（FF）、最佳适应（BF）等算法。</li></ul></li><li><strong>非连续分配（现代主流）</strong><ul><li><strong>分页（Paging）</strong>：内存划分为固定大小页（如4KB），进程逻辑地址映射为物理页（如x86的页表机制）。<br /></li><li><strong>分段（Segmentation）</strong>：按逻辑段（代码段、数据段）分配，段大小可变（如Linux的段机制已简化）。<br /></li><li><strong>段页式</strong>：结合分段与分页，先分段再分页（如IBMSystem/370）。</li></ul></li></ul><h5 id="虚拟内存virtual-memory">2. 虚拟内存（Virtual Memory）</h5><ul><li><strong>核心机制</strong>：将物理内存与外存（硬盘）结合，为进程提供更大的逻辑地址空间。<br /></li><li><strong>页表映射</strong>：<ul><li>逻辑地址 → 页号 + 页内偏移 → 通过页表找到物理页帧号 →物理地址。<br /></li><li><strong>多级页表</strong>：减少页表占用内存（如x86-64的四级页表）。<br /></li></ul></li><li><strong>缺页异常（PageFault）</strong>：访问的页面不在物理内存时，内核从硬盘加载页面（如前文案例）。</li></ul><h5 id="页面置换算法">3. 页面置换算法</h5><table><colgroup><col style="width: 13%" /><col style="width: 26%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th><strong>算法</strong></th><th><strong>策略</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>实现</strong></th></tr></thead><tbody><tr class="odd"><td><strong>FIFO（先进先出）</strong></td><td>替换最早进入内存的页面</td><td>实现简单</td><td>可能淘汰频繁使用的页面</td><td>队列记录页面进入顺序</td></tr><tr class="even"><td><strong>LRU（最近最少使用）</strong></td><td>替换最长时间未访问的页面</td><td>理论性能优</td><td>需记录页面访问历史</td><td>哈希表+双向链表</td></tr><tr class="odd"><td><strong>LFU（最不常用）</strong></td><td>替换访问次数最少的页面</td><td>适应长期访问模式</td><td>无法处理突发访问</td><td>计数器记录访问次数</td></tr><tr class="even"><td><strong>Clock（时钟算法）</strong></td><td>简化版LRU，用环形链表模拟时钟指针</td><td>开销低</td><td>性能略低于LRU</td><td>标记位+环形指针</td></tr></tbody></table><h5 id="内存分配与回收">4. 内存分配与回收</h5><ul><li><strong>用户态内存分配</strong>：<ul><li><strong>堆分配</strong>：通过<code>malloc/free</code>动态申请内存（如C语言的glibc堆分配器）。<br /></li><li>**slab分配器**：为频繁创建/销毁的对象（如文件描述符）预分配小块内存，减少碎片（如Linux的slab分配器）。<br /></li></ul></li><li><strong>内核态内存分配</strong>：<ul><li><strong>buddysystem</strong>：按2的幂次分配物理页帧，避免外部碎片（如Linux的伙伴系统）。</li></ul></li></ul><h5 id="内存保护与隔离">5. 内存保护与隔离</h5><ul><li><strong>地址空间隔离</strong>：每个进程拥有独立的虚拟地址空间，禁止越界访问（通过MMU硬件实现）。<br /></li><li><strong>访问权限控制</strong>：页表项包含读/写/执行权限位（如x86的PTE权限位）。<br /></li><li><strong>内存屏障（MemoryBarrier）</strong>：确保多处理器环境下内存操作的顺序性（如<code>mfence</code>指令）。</li></ul><h4 id="四三大资源管理的协同作用">四、三大资源管理的协同作用</h4><ol type="1"><li><strong>IO与内存协同</strong>：DMA技术减少IO对CPU的占用，页缓存（PageCache）加速磁盘数据读取。<br /></li><li><strong>CPU与内存协同</strong>：缓存（Cache）层级减少内存访问延迟，虚拟内存通过CPU的MMU实现地址映射。<br /></li><li><strong>IO与CPU协同</strong>：中断机制让IO设备异步通知CPU，避免CPU空转等待。</li></ol><p>操作系统通过调度算法、缓存机制和资源抽象，将硬件资源的物理特性与上层软件需求解耦，实现高效、安全的系统运行。</p><h2 id="进程">6.5.1 进程</h2><h3id="进程的结构操作系统中运行实体的核心组成">进程的结构：操作系统中运行实体的核心组成</h3><p>进程作为操作系统中资源分配和调度的基本单位，其结构是理解操作系统内核机制的关键。进程结构不仅定义了进程的运行状态，还包含了操作系统管理进程所需的全部信息。以下从多个维度解析进程的核心结构：</p><h4id="一进程控制块pcbprocess-control-block进程的身份证"><strong>一、进程控制块（PCB，ProcessControl Block）：进程的“身份证”</strong></h4><p>PCB是操作系统管理进程的核心数据结构，包含了进程的所有状态信息，通常被称为进程的“灵魂”。其主要内容包括：</p><ol type="1"><li><strong>标识信息</strong><ul><li><strong>进程ID（PID）</strong>：唯一标识系统中的每个进程，用于进程通信和资源分配。<br /></li><li><strong>用户ID（UID）和组ID（GID）</strong>：标识进程的所有者和所属组，用于权限控制。<br /></li><li><strong>父进程ID（PPID）</strong>：形成进程树结构（如Linux中init进程为所有进程的祖先）。</li></ul></li><li><strong>状态信息</strong><ul><li><strong>进程状态</strong>：运行（Running）、就绪（Ready）、阻塞（Blocked）、终止（Terminated）等。<br /></li><li><strong>状态转换时间戳</strong>：记录进程状态变化的时间，用于性能分析和调度优化。</li></ul></li><li><strong>调度信息</strong><ul><li><strong>优先级</strong>：确定进程在CPU调度中的优先级（如Linux的nice值）。<br /></li><li><strong>调度类</strong>：实时进程或普通进程（对应不同的调度算法，如FIFO、RR）。<br /></li><li><strong>时间片剩余量</strong>：针对时间片轮转调度算法，记录进程剩余的CPU使用时间。</li></ul></li><li><strong>资源占用信息</strong><ul><li><strong>内存指针</strong>：指向进程地址空间的起始和结束位置，以及页表地址。<br /></li><li><strong>文件描述符表</strong>：记录进程打开的文件句柄及对应文件的状态（如Linux的fd数组）。<br /></li><li><strong>I/O设备分配情况</strong>：当前占用的设备（如打印机、磁盘）及锁状态。</li></ul></li><li><strong>上下文信息（CPU状态）</strong><ul><li><strong>通用寄存器值</strong>：如EAX、EBX等，保存进程暂停时的计算中间结果。<br /></li><li><strong>程序计数器（PC）</strong>：指向下一条待执行的指令地址。<br /></li><li><strong>栈指针（SP）</strong>：指向进程栈的当前位置。<br /></li><li><strong>状态寄存器（PSW）</strong>：记录CPU的状态标志（如溢出、中断允许位）。</li></ul></li></ol><p><strong>示例：Linux PCB（task_struct）</strong><br />在Linux内核中，PCB由<code>task_struct</code>结构体实现，包含上千个字段，如：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">long</span> state;               <span class="comment">// 进程状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>     <span class="comment">// 内存管理指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_struct</span> *<span class="title">files</span>;</span><span class="comment">// 文件描述符表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span><span class="comment">// 子进程链表</span></span><br><span class="line">    <span class="comment">// 更多字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4id="二进程地址空间程序运行的虚拟舞台"><strong>二、进程地址空间：程序运行的“虚拟舞台”</strong></h4><p>进程地址空间是进程可访问的内存范围，通常分为多个逻辑段，不同操作系统的分段方式略有差异，但核心结构相似：</p><ol type="1"><li><strong>代码段（Text Segment）</strong><ul><li>存储进程的可执行指令（机器码），通常为只读（防止程序运行时被修改）。<br /></li><li>可被多个进程共享（如多个文本编辑器进程共享同一个二进制文件）。</li></ul></li><li><strong>数据段（Data Segment）</strong><ul><li>存储已初始化的全局变量和静态变量（如<code>int global_var = 10;</code>）。<br /></li><li>分为初始化数据段（InitializedData）和未初始化数据段（BSS段，如未赋值的全局变量）。</li></ul></li><li><strong>堆（Heap）</strong><ul><li>动态内存分配区域，由进程通过<code>malloc</code>、<code>new</code>等函数申请。<br /></li><li>向上增长（地址由低到高），分配和释放由程序控制，易产生内存碎片。</li></ul></li><li><strong>栈（Stack）</strong><ul><li>存储函数调用的局部变量、参数、返回地址等，遵循“后进先出（LIFO）”原则。<br /></li><li>向下增长（地址由高到低），由编译器自动管理，大小通常受限（如Linux默认栈大小为8MB）。</li></ul></li><li><strong>共享库映射区</strong><ul><li>映射动态链接库（如Linux的.so文件、Windows的.dll文件），实现代码共享和内存优化。</li></ul></li></ol><p><strong>地址空间布局示例（Linux x86-64）</strong><br /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">┌──────────────────────────────────────────────────┐</span><br><span class="line">│                 内核地址空间（1GB）               │</span><br><span class="line">├──────────────────────────────────────────────────┤</span><br><span class="line">│             共享库映射区（动态加载）             │</span><br><span class="line">├──────────────────────────────────────────────────┤</span><br><span class="line">│                   堆（向上增长）                 │</span><br><span class="line">├──────────────────────────────────────────────────┤</span><br><span class="line">│              内存映射区（mmap）                 │</span><br><span class="line">├──────────────────────────────────────────────────┤</span><br><span class="line">│                   栈（向下增长）                 │</span><br><span class="line">├──────────────────────────────────────────────────┤</span><br><span class="line">│                   代码段                         │</span><br><span class="line">│                   数据段                         │</span><br><span class="line">└──────────────────────────────────────────────────┘</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></p><h4id="三进程栈函数调用的执行轨迹"><strong>三、进程栈：函数调用的“执行轨迹”</strong></h4><p>进程栈是进程运行时的关键组件，主要用于：<br />- 保存函数调用的参数、局部变量和返回地址。<br />- 实现函数递归调用和嵌套调用。</p><p>栈的基本单元是<strong>栈帧（StackFrame）</strong>，每个函数调用对应一个栈帧，包含：<br />1. <strong>函数参数</strong>：调用函数时传递的参数值。<br />2. <strong>返回地址</strong>：函数执行完毕后返回的指令位置。<br />3.<strong>局部变量</strong>：函数内部定义的变量（如<code>int x = 5;</code>）。<br />4.<strong>前栈帧指针（ebp）</strong>：指向上一个栈帧的地址，用于栈回溯。</p><p><strong>函数调用示例：栈帧变化</strong><br />当调用函数<code>f(a, b)</code>时，栈的操作过程如下：<br />1. 将参数<code>b</code>、<code>a</code>压入栈。<br />2. 将当前指令地址（返回地址）压入栈。<br />3. 保存当前栈帧指针（ebp），并将ebp指向新栈帧。<br />4. 为局部变量分配空间，执行函数体。<br />5. 函数返回时，弹出栈帧，恢复ebp和PC（程序计数器）。</p><h4id="四进程资源集合操作系统管理的核心对象"><strong>四、进程资源集合：操作系统管理的核心对象</strong></h4><p>进程除了代码和数据外，还包含一系列系统资源，这些资源由操作系统统一管理：<br />1. <strong>文件资源</strong><br />- 通过文件描述符（FileDescriptor）访问，如Linux中<code>open()</code>返回的整数句柄。<br />-每个进程默认打开3个文件描述符：标准输入（0）、标准输出（1）、标准错误（2）。</p><ol start="2" type="1"><li><strong>设备资源</strong><ul><li>已占用的硬件设备（如打印机、串口），通过设备驱动程序访问。<br /></li><li>设备锁机制防止多个进程同时访问同一设备（如并发写磁盘导致数据错乱）。</li></ul></li><li><strong>信号处理机制</strong><ul><li>进程接收的异步事件（如Ctrl+C触发SIGINT信号），对应信号处理函数。</li></ul></li><li><strong>线程信息（多线程进程）</strong><ul><li>若进程包含多个线程，PCB中还需记录线程控制块（TCB）列表，如线程ID、线程状态等。</li></ul></li></ol><h4id="五进程结构的操作系统实现差异"><strong>五、进程结构的操作系统实现差异</strong></h4><p>不同操作系统对进程结构的实现存在差异，典型例子：<br />| 操作系统 | PCB实现 | 地址空间管理方式 ||----------------|-----------------------------|--------------------------------|| Linux | task_struct结构体 | 分段+分页（4GB虚拟地址空间） | | Windows |_EPROCESS结构体 | 分页机制（用户态2GB/3GB空间） | | Unix（System V）|struct proc | 固定分段（代码段、数据段、栈） |</p><h4id="六进程结构的核心作用"><strong>六、进程结构的核心作用</strong></h4><ol type="1"><li><strong>状态保存与恢复</strong>：通过PCB的上下文信息，实现进程切换时的现场保存（如CPU寄存器值）。<br /></li><li><strong>资源隔离</strong>：进程地址空间确保不同进程的内存互不干扰，提升系统安全性。<br /></li><li><strong>调度依据</strong>：PCB中的优先级和状态是CPU调度算法的核心输入。<br /></li><li><strong>故障处理</strong>：当进程异常终止时，操作系统可通过PCB信息定位问题（如段错误时的内存地址）。</li></ol><h3 id="总结-5">总结</h3><p>进程的结构是操作系统内核设计的基础，从PCB的元数据管理到地址空间的逻辑分段，再到栈和资源的动态分配，共同构成了进程作为“活实体”的运行基础。理解进程结构不仅有助于掌握操作系统原理，也为进程调试、性能优化和并发编程提供了理论支撑。</p><h2 id="进程状态">6.5.2 进程状态</h2><h3id="进程三状态模型操作系统中的进程生命周期核心框架">进程三状态模型：操作系统中的进程生命周期核心框架</h3><h4id="一三状态模型的基本概念"><strong>一、三状态模型的基本概念</strong></h4><p>三状态模型是描述进程在操作系统中运行状态转换的基础模型，将进程的生命周期抽象为三种核心状态：<strong>运行态（Running）</strong>、<strong>就绪态（Ready）</strong>和<strong>阻塞态（Blocked）</strong>。该模型通过状态转换图清晰展示了进程在CPU调度、资源等待等场景下的行为变化。</p><h4id="二三状态模型的核心状态解析"><strong>二、三状态模型的核心状态解析</strong></h4><table><colgroup><col style="width: 9%" /><col style="width: 44%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th><strong>状态</strong></th><th><strong>定义</strong></th><th><strong>关键特征</strong></th></tr></thead><tbody><tr class="odd"><td><strong>运行态</strong></td><td>进程当前正在CPU上执行</td><td>- 同一时刻单CPU系统中仅一个进程处于运行态<br>-进程占用CPU资源，执行指令流</td></tr><tr class="even"><td><strong>就绪态</strong></td><td>进程已准备好执行，但因CPU资源不足等待调度</td><td>- 具备运行条件（如已获取除CPU外的所有资源）<br>-存在于就绪队列中，等待调度器分配CPU</td></tr><tr class="odd"><td><strong>阻塞态</strong></td><td>进程因等待某一事件（如I/O完成、信号量获取）而暂停执行</td><td>- 不占用CPU资源<br>- 事件未完成时无法主动转换为其他状态<br>-存在于阻塞队列中，事件触发后转入就绪态</td></tr></tbody></table><h4id="三状态转换触发条件与流程"><strong>三、状态转换：触发条件与流程</strong></h4><h5 id="状态转换图"><strong>1. 状态转换图</strong></h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">               +-----------+</span><br><span class="line">               |<span class="string">  运行态   </span>|</span><br><span class="line">               +-----------+</span><br><span class="line">                  ^    ^</span><br><span class="line">                  |<span class="string">    </span>|</span><br><span class="line">                  |<span class="string">    </span>|<span class="string"> 时间片用完 / 更高优先级进程就绪</span></span><br><span class="line"><span class="string">                  </span>|<span class="string">    v</span></span><br><span class="line"><span class="string">      +-----------+-----------+</span></span><br><span class="line"><span class="string">      </span>|<span class="string">                       </span>|</span><br><span class="line">      v                       v</span><br><span class="line">+-----------+           +-----------+</span><br><span class="line">|<span class="string">  就绪态   </span>|<span class="string">           </span>|<span class="string">  阻塞态   </span>|</span><br><span class="line">+-----------+           +-----------+</span><br><span class="line">   ^   ^                     ^   ^</span><br><span class="line">   |<span class="string">   </span>|<span class="string"> 调度器选择          </span>|<span class="string">   </span>|<span class="string"> 等待事件完成</span></span><br><span class="line"><span class="string">   </span>|<span class="string">   v                     </span>|<span class="string">   v</span></span><br><span class="line"><span class="string">   +-----------+           +-----------+</span></span><br><span class="line"><span class="string">               </span>|<span class="string">           </span>|</span><br><span class="line">               v           v</span><br><span class="line">           进程创建         事件触发</span><br><span class="line">               |<span class="string">           </span>|</span><br><span class="line">               +-----------+</span><br></pre></td></tr></table></figure><h5 id="关键转换场景与触发条件"><strong>2.关键转换场景与触发条件</strong></h5><ul><li><strong>运行态→就绪态</strong>：<ul><li><strong>时间片耗尽</strong>：在时间片轮转调度算法中，进程使用完CPU分配的时间片后，被迫让出CPU，进入就绪队列等待下一次调度。<br /></li><li><strong>优先级抢占</strong>：高优先级进程进入就绪队列时，当前运行的低优先级进程被抢占，转入就绪态。<br /></li><li><strong>进程主动让步</strong>：某些系统中，进程可通过系统调用（如<code>yield</code>）主动放弃CPU，进入就绪态。</li></ul></li><li><strong>运行态→阻塞态</strong>：<ul><li><strong>等待I/O操作</strong>：进程发起磁盘读写、网络请求等I/O操作时，因操作耗时较长，主动阻塞直至I/O完成（如<code>read()</code>函数调用）。<br /></li><li><strong>等待资源锁</strong>：进程尝试获取被其他进程占用的互斥锁、信号量等同步资源时，若资源不可用则进入阻塞态。<br /></li><li><strong>等待信号</strong>：进程等待特定信号（如键盘中断<code>Ctrl+C</code>）或事件（如子进程终止）时，进入阻塞状态。</li></ul></li><li><strong>阻塞态→就绪态</strong>：<ul><li><strong>I/O操作完成</strong>：磁盘或网络I/O操作结束，操作系统向进程发送完成信号，进程从阻塞队列转入就绪队列。<br /></li><li><strong>资源锁释放</strong>：其他进程释放互斥锁或信号量，等待该资源的阻塞进程被唤醒，进入就绪态。<br /></li><li><strong>等待事件触发</strong>：如等待的子进程终止、信号到达等，进程被唤醒并转为就绪态。</li></ul></li><li><strong>就绪态→运行态</strong>：<ul><li><strong>调度器选择</strong>：操作系统的调度器从就绪队列中选择一个进程（通常基于优先级、时间片等策略），将其状态切换为运行态，并分配CPU资源。</li></ul></li></ul><h4id="四三状态模型的扩展与实际应用"><strong>四、三状态模型的扩展与实际应用</strong></h4><h5 id="模型的局限性"><strong>1. 模型的局限性</strong></h5><ul><li><strong>未覆盖进程创建与终止</strong>：实际进程还存在“新建态（New）”（进程正在创建中）和“终止态（Terminated）”（进程已结束，等待资源回收），三状态模型通常需结合这两个状态扩展为五状态模型。<br /></li><li><strong>无法描述细化场景</strong>：如“挂起态（Suspended）”（进程被暂时移出内存至磁盘，以释放内存资源），需通过扩展状态进一步完善模型。</li></ul><h5 id="三状态模型的核心价值"><strong>2.三状态模型的核心价值</strong></h5><ul><li><strong>调度算法的基础</strong>：操作系统通过状态转换判断进程是否可被调度，如仅就绪态进程可被选中执行。<br /></li><li><strong>资源管理的依据</strong>：阻塞态进程不占用CPU，可释放资源给其他进程，提升系统并发效率。<br /></li><li><strong>性能优化的参考</strong>：通过分析进程在各状态的停留时间（如阻塞态占比过高），可定位I/O瓶颈或调度策略问题。</li></ul><h4id="五示例从三状态模型看程序执行流程"><strong>五、示例：从三状态模型看程序执行流程</strong></h4><p>以“用户点击打开浏览器”为例：<br />1.<strong>新建态→就绪态</strong>：操作系统创建浏览器进程，分配PCB和内存资源，进程进入就绪队列。<br />2.<strong>就绪态→运行态</strong>：调度器选中浏览器进程，加载至CPU执行，开始初始化界面。<br />3.<strong>运行态→阻塞态</strong>：浏览器向磁盘读取缓存文件时，发起I/O请求，进入阻塞态等待读取完成。<br />4.<strong>阻塞态→就绪态</strong>：磁盘I/O完成，进程被唤醒，重新进入就绪队列。<br />5.<strong>就绪态→运行态</strong>：调度器再次选中进程，继续执行界面渲染逻辑，直至用户交互触发新的状态转换。</p><h4 id="总结-6"><strong>总结</strong></h4><p>三状态模型通过运行、就绪、阻塞三种状态及对应的转换规则，简洁而清晰地勾勒了进程在操作系统中的生命周期。它不仅是理解CPU调度、资源竞争等核心机制的基础，也为操作系统设计提供了理论框架——后续更复杂的状态模型（如五状态、七状态模型）均基于此扩展，以适应多进程并发、内存管理等更复杂的场景。</p><h2 id="进程调度">6.5.3 进程调度</h2><h3id="进程调度算法fcfs与sjf的原理对比及应用">进程调度算法：FCFS与SJF的原理、对比及应用</h3><h4id="一fcfsfirst-come-first-served先来先服务算法"><strong>一、FCFS（First-Come-First-Served，先来先服务）算法</strong></h4><h5 id="基本原理"><strong>1. 基本原理</strong></h5><ul><li><strong>核心逻辑</strong>：按进程到达就绪队列的顺序依次调度，先到达的进程优先获得CPU资源，直至执行完毕或阻塞。<br /></li><li><strong>非抢占式</strong>：一旦进程开始执行，除非主动放弃CPU（如阻塞），否则不会被中断。</li></ul><h5 id="执行流程示例"><strong>2. 执行流程示例</strong></h5><p>假设3个进程到达时间和执行时间如下：<br />| 进程 | 到达时间 | 执行时间（ms） |<br />|------|----------|----------------|<br />| P1 | 0 | 24 |<br />| P2 | 1 | 3 |<br />| P3 | 2 | 3 |</p><ul><li><strong>调度顺序</strong>：P1 → P2 → P3<br /></li><li><strong>各进程完成时间与等待时间</strong>：<ul><li>P1：完成时间24，等待时间0<br /></li><li>P2：完成时间27，等待时间24-1=23<br /></li><li>P3：完成时间30，等待时间27-2=25<br /></li><li><strong>平均等待时间</strong>：(0+23+25)/3 ≈ 15.67 ms</li></ul></li></ul><h5 id="优缺点分析"><strong>3. 优缺点分析</strong></h5><table><colgroup><col style="width: 32%" /><col style="width: 67%" /></colgroup><thead><tr class="header"><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr class="odd"><td>1. 实现简单，公平性强（按到达顺序调度）。</td><td>1.<strong>平均等待时间长</strong>：长进程会导致短进程等待，产生“护航效应”（如上述例子中P2、P3需等待P1执行24ms）。</td></tr><tr class="even"><td>2. 无饥饿现象（所有进程按顺序执行，必被调度）。</td><td>2.<strong>CPU和I/O设备利用率低</strong>：长进程可能独占CPU，导致I/O设备空闲（如CPU密集型进程阻塞I/O型进程）。</td></tr></tbody></table><h4id="二sjfshortest-job-first最短作业优先算法"><strong>二、SJF（ShortestJob First，最短作业优先）算法</strong></h4><h5 id="基本原理-1"><strong>1. 基本原理</strong></h5><ul><li><strong>核心逻辑</strong>：从就绪队列中选择执行时间最短的进程优先调度，以最小化平均等待时间。<br /></li><li><strong>分类</strong>：<ul><li><strong>非抢占式SJF</strong>：一旦进程开始执行，直至完成或阻塞才释放CPU。<br /></li><li><strong>抢占式SJF（最短剩余时间优先，SRTF）</strong>：若新进程的剩余执行时间比当前运行进程更短，则抢占CPU。</li></ul></li></ul><h5 id="非抢占式sjf示例沿用上述进程"><strong>2.非抢占式SJF示例（沿用上述进程）</strong></h5><table><thead><tr class="header"><th>进程</th><th>到达时间</th><th>执行时间（ms）</th></tr></thead><tbody><tr class="odd"><td>P1</td><td>0</td><td>24</td></tr><tr class="even"><td>P2</td><td>1</td><td>3</td></tr><tr class="odd"><td>P3</td><td>2</td><td>3</td></tr></tbody></table><ul><li><strong>调度顺序</strong>：P2（执行时间3）→ P3（执行时间3）→P1（执行时间24）<br /></li><li><strong>各进程完成时间与等待时间</strong>：<ul><li>P2：完成时间4（1+3），等待时间0（到达时间1，开始时间1）<br /></li><li>P3：完成时间7（4+3），等待时间4-2=2<br /></li><li>P1：完成时间31（7+24），等待时间7-0=7<br /></li><li><strong>平均等待时间</strong>：(0+2+7)/3 = 3 ms（远低于FCFS的15.67ms）</li></ul></li></ul><h5 id="优缺点分析-1"><strong>3. 优缺点分析</strong></h5><table><colgroup><col style="width: 32%" /><col style="width: 67%" /></colgroup><thead><tr class="header"><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr class="odd"><td>1.<strong>理论上平均等待时间最短</strong>：优先执行短进程，减少整体等待开销。</td><td>1.<strong>可能导致饥饿</strong>：若持续有短进程到达，长进程可能长期无法被调度（如交互式进程频繁中断批处理进程）。</td></tr><tr class="even"><td>2.<strong>资源利用率高</strong>：短进程快速完成，释放CPU给其他进程，适合I/O密集型任务。</td><td>2.<strong>执行时间预估困难</strong>：实际中需通过历史数据或用户指定预估执行时间，可能不准确。</td></tr><tr class="odd"><td>3. 抢占式SJF（SRTF）对突发短进程响应更及时。</td><td>3.<strong>调度开销较高</strong>：抢占式版本需持续比较进程剩余时间，增加系统开销。</td></tr></tbody></table><h4id="三fcfs与sjf的核心对比"><strong>三、FCFS与SJF的核心对比</strong></h4><table><colgroup><col style="width: 18%" /><col style="width: 39%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th><strong>维度</strong></th><th><strong>FCFS</strong></th><th><strong>SJF（非抢占式）</strong></th></tr></thead><tbody><tr class="odd"><td><strong>调度依据</strong></td><td>进程到达顺序</td><td>进程执行时间（预估或实际）</td></tr><tr class="even"><td><strong>公平性</strong></td><td>高（严格按顺序）</td><td>低（长进程可能等待久）</td></tr><tr class="odd"><td><strong>平均等待时间</strong></td><td>高（尤其存在长进程时）</td><td>低（理论最优）</td></tr><tr class="even"><td><strong>饥饿风险</strong></td><td>无</td><td>有（长进程可能被短进程“饿死”）</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>批处理系统（如早期大型机），对公平性要求高但性能不敏感的场景。</td><td>对响应时间敏感的场景（如交互式系统），或已知任务执行时间的场景（如测试环境）。</td></tr></tbody></table><h4 id="四实际应用与改进"><strong>四、实际应用与改进</strong></h4><ol type="1"><li><strong>FCFS的应用</strong>：<ul><li>批处理系统中的作业调度（如早期UNIX系统的作业队列）。<br /></li><li>作为其他调度算法的基础组件（如多级队列调度中的某些队列）。</li></ul></li><li><strong>SJF的改进与变种</strong>：<ul><li><strong>最短剩余时间优先（SRTF）</strong>：抢占式版本，更适合实时性需求（如进程A执行时，进程B到达且剩余时间更短，则B抢占A）。<br /></li><li><strong>动态调整执行时间预估</strong>：通过指数平滑法（如<code>新预估时间 = α×实际时间 + (1-α)×旧预估时间</code>）优化SJF的准确性。</li></ul></li><li><strong>饥饿解决方案</strong>：<ul><li><strong>老化（Aging）机制</strong>：为等待时间长的进程动态提升优先级，避免长期等待。<br /></li><li><strong>多级反馈队列</strong>：将进程按执行时间分入不同优先级队列，优先级高的队列使用短时间片，低优先级队列逐步增加时间片，兼顾短进程效率和长进程公平性。</li></ul></li></ol><h4 id="五总结"><strong>五、总结</strong></h4><p>FCFS和SJF是进程调度的基础算法，前者以公平性为核心，后者以效率（最小化平均等待时间）为目标。实际操作系统中，很少直接使用纯SJF算法（因执行时间预估困难和饥饿风险），但SJF的思想（优先处理短任务）被广泛应用于各类优化调度策略（如Linux的CFS调度器对短进程的偏向）。理解这两种算法的本质，有助于深入分析更复杂的调度机制（如时间片轮转、优先级调度等）的设计trade-off。</p><h1 id="第7章-并行计算">第7章 并行计算</h1><p>本章以代码练习为主，因此仅展示一份多进程代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">task_id, sleep_time</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子进程执行的任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;进程 <span class="subst">&#123;os.getpid()&#125;</span> (父进程: <span class="subst">&#123;os.getppid()&#125;</span>) 正在执行任务 <span class="subst">&#123;task_id&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(sleep_time)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;task_id&#125;</span> 完成&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> task_id * <span class="number">10</span>  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;主进程 ID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    <span class="keyword">with</span> multiprocessing.Pool(processes=<span class="number">3</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 准备任务</span></span><br><span class="line">        tasks = [(i, i % <span class="number">3</span> + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]  <span class="comment"># 5个任务，每个任务的睡眠时间不同</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 异步执行任务</span></span><br><span class="line">        results = [pool.apply_async(worker_function, args=task) <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关闭进程池，不再接受新任务</span></span><br><span class="line">        pool.close()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        pool.join()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取并打印结果</span></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;任务结果: <span class="subst">&#123;result.get()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()    </span><br></pre></td></tr></table></figure><h1 id="第8章-计算机网络与物联网">第8章 计算机网络与物联网</h1><h2 id="物理层这部分做了解">8.1.1 物理层（这部分做了解）</h2><h3id="信道复用技术高效利用通信资源的核心技术">信道复用技术：高效利用通信资源的核心技术</h3><h4id="一信道复用技术的定义与目的"><strong>一、信道复用技术的定义与目的</strong></h4><ul><li><strong>定义</strong>：在一条物理信道上建立多个逻辑信道，使多个用户的数据能同时传输，从而提高信道资源利用率。</li><li><strong>核心目的</strong>：<br />解决物理信道数量有限与用户通信需求增长的矛盾，降低传输成本，提升系统容量。</li></ul><h4id="二主流信道复用技术分类与原理"><strong>二、主流信道复用技术分类与原理</strong></h4><h5 id="频分复用fdm-frequency-division-multiplexing"><strong>1.频分复用（FDM, Frequency Division Multiplexing）</strong></h5><ul><li><strong>原理</strong>：将物理信道的带宽划分为多个互不重叠的频率段，每个频段分配给一个用户（信道），各用户在频域上并行传输。</li><li><strong>关键特点</strong>：<ul><li>各信道频率不重叠，需用滤波器分离信号。<br /></li><li>适用于模拟信号传输，也可通过调制适配数字信号。</li></ul></li><li><strong>典型应用</strong>：<ul><li><strong>广播/电视</strong>：不同电台占用不同频率段（如FM广播76-108MHz）。<br /></li><li><strong>有线电视（CATV）</strong>：同轴电缆将带宽划分为多个电视频道（如50-1000MHz频段）。<br /></li><li><strong>早期电话网络</strong>：载波电话系统通过FDM实现多路语音传输。</li></ul></li></ul><h5 id="时分复用tdm-time-division-multiplexing"><strong>2.时分复用（TDM, Time Division Multiplexing）</strong></h5><ul><li><strong>原理</strong>：将传输时间划分为固定长度的时间片（时隙），每个用户周期性占用专属时隙传输数据。</li><li><strong>关键特点</strong>：<ul><li>时分复用分「同步TDM」和「异步TDM（统计时分复用）」：<ul><li><strong>同步TDM</strong>：时隙固定分配，无论用户是否传输数据，时隙始终保留（如E1/T1数字线路）。<br /></li><li><strong>统计TDM</strong>：动态分配时隙，仅当用户有数据时分配，利用率更高（如ATM网络）。<br /></li></ul></li><li>适用于数字信号，需严格时钟同步。</li></ul></li><li><strong>典型应用</strong>：<ul><li><strong>传统电话网（PSTN）</strong>：E1线路将32个时隙复用成2.048Mbps的数据流。<br /></li><li><strong>计算机网络</strong>：ISDN（综合业务数字网）通过TDM支持语音与数据复用。</li></ul></li></ul><h5 id="波分复用wdm-wavelength-division-multiplexing"><strong>3.波分复用（WDM, Wavelength Division Multiplexing）</strong></h5><ul><li><strong>原理</strong>：在光纤通信中，利用光的波长差异，将不同波长的光信号复用到同一根光纤传输，本质是光域的FDM。</li><li><strong>关键特点</strong>：<ul><li><strong>密集波分复用（DWDM）</strong>：在1550nm波长附近密集划分波长（如间隔0.8nm），单根光纤可承载上百路信道。<br /></li><li>传输容量极大，是光纤骨干网的核心技术。</li></ul></li><li><strong>典型应用</strong>：<ul><li><strong>长途光纤通信</strong>：如海底光缆通过DWDM实现Tbps级传输（如100Gbps×80波长=8Tbps）。<br /></li><li><strong>数据中心互联</strong>：高速率场景下复用多波长提升带宽。</li></ul></li></ul><h5 id="码分复用cdma-code-division-multiple-access"><strong>4.码分复用（CDMA, Code Division Multiple Access）</strong></h5><ul><li><strong>原理</strong>：为每个用户分配唯一的正交码序列（扩频码），不同用户的信号在时域和频域上重叠，但通过码序列区分。</li><li><strong>关键特点</strong>：<ul><li>利用「码分多址」技术，多个用户可同时使用同一信道，抗干扰能力强。<br /></li><li>需满足码序列正交性（如Walsh码），实现信号分离。</li></ul></li><li><strong>典型应用</strong>：<ul><li><strong>移动通信</strong>：3G网络（如CDMA2000）、部分4GLTE技术。<br /></li><li><strong>卫星通信</strong>：GPS信号通过CDMA实现多卫星信号区分。</li></ul></li></ul><h5 id="其他复用技术"><strong>5. 其他复用技术</strong></h5><ul><li><strong>空分复用（SDM, Space Division Multiplexing）</strong>：<ul><li>利用空间位置区分信道，如多天线技术（MIMO）在无线通信中通过不同天线传输不同数据流，提升容量（如5G中的大规模MIMO）。<br /></li></ul></li><li><strong>极化分复用（PolDM, Polarization DivisionMultiplexing）</strong>：<ul><li>利用光的偏振态差异（如水平/垂直偏振）在同一波长复用两路信号，常用于光纤通信（如100Gbps以上系统）。</li></ul></li></ul><h4id="三主要复用技术对比表"><strong>三、主要复用技术对比表</strong></h4><table><colgroup><col style="width: 11%" /><col style="width: 17%" /><col style="width: 18%" /><col style="width: 23%" /><col style="width: 29%" /></colgroup><thead><tr class="header"><th><strong>技术类型</strong></th><th><strong>核心资源划分方式</strong></th><th><strong>典型应用场景</strong></th><th><strong>优势</strong></th><th><strong>局限性</strong></th></tr></thead><tbody><tr class="odd"><td>FDM</td><td>频域划分</td><td>广播、有线电视、载波电话</td><td>技术成熟，适合模拟信号</td><td>频谱利用率低，需滤波器分隔</td></tr><tr class="even"><td>TDM</td><td>时域划分</td><td>电话网、ISDN、E1/T1</td><td>适合数字信号，同步简单</td><td>固定时隙分配可能浪费资源</td></tr><tr class="odd"><td>WDM/DWDM</td><td>光波长划分</td><td>光纤骨干网、长途通信</td><td>单光纤容量极高，易扩展</td><td>设备成本高，需精密波长控制</td></tr><tr class="even"><td>CDMA</td><td>码序列划分</td><td>3G通信、卫星定位</td><td>抗干扰性强，用户容量动态调整</td><td>码资源有限，复杂度高</td></tr><tr class="odd"><td>SDM</td><td>空间位置划分</td><td>5G MIMO、多天线系统</td><td>提升无线信道容量</td><td>依赖多天线部署，受环境影响大</td></tr></tbody></table><h4id="四信道复用技术的应用与发展趋势"><strong>四、信道复用技术的应用与发展趋势</strong></h4><ul><li><strong>在现代通信中的关键作用</strong>：<ul><li><strong>5G网络</strong>：结合TDM（时分双工TDD）、FDM（频分载波聚合）、SDM（大规模MIMO）实现高带宽与低延迟。<br /></li><li><strong>数据中心</strong>：DWDM在光纤中复用多波长，支持100G/400G高速互联。<br /></li><li><strong>卫星通信</strong>：CDMA与FDM结合，实现多用户同时接入卫星信道。</li></ul></li><li><strong>技术趋势</strong>：<ul><li><strong>高频段复用</strong>：毫米波通信（如5G毫米波）通过更窄的频段划分提升频谱效率。<br /></li><li><strong>混合复用技术</strong>：多种复用方式结合（如WDM+SDM），在光纤中实现“空分+波分”多维复用，突破单纤容量极限（如空分复用光纤可承载Tbps级流量）。<br /></li><li><strong>软件定义复用</strong>：通过SDN（软件定义网络）动态调配复用资源，提升系统灵活性。</li></ul></li></ul><h4 id="五总结-1"><strong>五、总结</strong></h4><p>信道复用技术是通信网络的核心基础，通过频域、时域、波长、码序、空间等维度的资源划分，实现“一信道多用”。从早期电话网的FDM/TDM，到光纤时代的WDM，再到5G的多维度复用，技术演进始终围绕“提升资源利用率”与“满足高速通信需求”展开，推动着通信网络向更大带宽、更低成本的方向发展。</p><h2 id="数据链路层">8.1.2 数据链路层</h2><h3id="数据链路层构建可靠数据传输的数据搬运工">数据链路层：构建可靠数据传输的“数据搬运工”</h3><h4id="一数据链路层的定位与核心使命"><strong>一、数据链路层的定位与核心使命</strong></h4><ul><li><strong>OSI模型中的位置</strong>：位于物理层之上、网络层之下，是连接“硬件”与“软件”的桥梁。<br /></li><li><strong>核心目标</strong>：在不可靠的物理信道上实现可靠的数据传输，将物理层的比特流组织成“帧”，并处理传输中的错误与冲突。</li></ul><h4id="二数据链路层的核心功能解析"><strong>二、数据链路层的核心功能解析</strong></h4><h5 id="帧的封装与拆解frame-encapsulation"><strong>1.帧的封装与拆解（Frame Encapsulation）</strong></h5><ul><li><strong>帧的结构</strong>：<br />帧由“帧头（首部）+ 数据 + 帧尾（尾部）”组成，典型字段包括：<ul><li><strong>MAC地址</strong>：源地址（SA）和目的地址（DA），标识数据的发送与接收设备。<br /></li><li><strong>类型/长度字段</strong>：指示上层协议（如IP、ARP）或帧长度。<br /></li><li><strong>数据字段</strong>：承载网络层数据包（如IP分组），长度受MTU（最大传输单元）限制（如以太网MTU为1500字节）。<br /></li><li><strong>帧校验序列（FCS）</strong>：通过CRC（循环冗余校验）实现错误检测。<br /></li></ul></li><li><strong>示例：以太网帧结构</strong><br /><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------------+</span>----------------<span class="code">+----------------+</span>----------------<span class="code">+----------------+</span></span><br><span class="line"><span class="section">|  源MAC地址(6B) |  目的MAC地址(6B) | 类型/长度(2B) |  数据(46-1500B)  |  FCS(4B)  |</span></span><br><span class="line"><span class="section">+----------------+----------------+----------------+----------------+----------------+</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="错误检测与控制error-control"><strong>2. 错误检测与控制（ErrorControl）</strong></h5><ul><li><strong>错误检测机制</strong>：<ul><li><strong>CRC校验</strong>：发送端根据数据生成校验码，接收端重新计算并比对，检测比特错误（如以太网、PPP协议）。<br /></li><li><strong>奇偶校验</strong>：简单校验比特位奇偶性，常用于低速链路（如串口通信）。<br /></li></ul></li><li><strong>错误处理策略</strong>：<ul><li><strong>自动重传请求（ARQ）</strong>：接收端发现错误时，通过反馈机制要求发送端重传（如HDLC协议的ARQ机制）。<br /></li><li><strong>前向纠错（FEC）</strong>：在数据中加入冗余信息，接收端直接纠正少量错误（如WiFi的信道编码）。</li></ul></li></ul><h5 id="流量控制flow-control"><strong>3. 流量控制（FlowControl）</strong></h5><ul><li><strong>目的</strong>：防止发送端速率超过接收端处理能力，避免数据丢失。<br /></li><li><strong>主要方法</strong>：<ul><li><strong>滑动窗口协议</strong>：发送端维护“发送窗口”，限制未确认帧的数量（如HDLC、TCP的流量控制基于此原理）。<br /></li><li><strong>停止-等待协议</strong>：发送一帧后等待确认，再发送下一帧（适用于低带宽场景）。<br /></li><li><strong>缓冲区通知</strong>：接收端通过反馈告知发送端自身缓冲区状态（如以太网的PAUSE帧）。</li></ul></li></ul><h5 id="介质访问控制mac-media-access-control"><strong>4.介质访问控制（MAC, Media Access Control）</strong></h5><ul><li><strong>解决问题</strong>：多设备共享同一物理信道时的传输冲突（如以太网、WiFi）。<br /></li><li><strong>核心协议</strong>：<ul><li><strong>CSMA/CD（载波侦听多路访问/冲突检测）</strong>：<ul><li><strong>原理</strong>：发送前监听信道，空闲则发送，发送中检测冲突，冲突时随机退避后重发（如传统以太网）。<br /></li><li><strong>适用场景</strong>：有线局域网（如10BASE-T）。<br /></li></ul></li><li><strong>CSMA/CA（载波侦听多路访问/冲突避免）</strong>：<ul><li><strong>原理</strong>：发送前先发送请求帧（RTS），接收端响应允许帧（CTS），避免隐终端冲突（如WiFi的802.11协议）。<br /></li><li><strong>适用场景</strong>：无线局域网（WiFi），因无线信道无法直接检测冲突。</li></ul></li></ul></li></ul><h4id="三数据链路层的子层划分与标准"><strong>三、数据链路层的子层划分与标准</strong></h4><ul><li><strong>逻辑链路控制子层（LLC, Logical Link Control）</strong>：<ul><li><strong>功能</strong>：向上层提供统一接口，处理帧的逻辑控制（如流量控制、差错控制）。<br /></li><li><strong>标准</strong>：IEEE 802.2，定义LLC帧格式与服务原语。<br /></li></ul></li><li><strong>介质访问控制子层（MAC, Media Access Control）</strong>：<ul><li><strong>功能</strong>：管理物理介质的访问，处理设备寻址、冲突检测/避免。<br /></li><li><strong>典型标准</strong>：<ul><li>IEEE 802.3：以太网MAC层标准（定义CSMA/CD）。<br /></li><li>IEEE 802.11：WiFi MAC层标准（定义CSMA/CA与DCF/PCF机制）。</li></ul></li></ul></li></ul><h4id="四数据链路层的关键协议与技术"><strong>四、数据链路层的关键协议与技术</strong></h4><h5 id="局域网lan协议"><strong>1. 局域网（LAN）协议</strong></h5><ul><li><strong>以太网（Ethernet）</strong>：<ul><li><strong>技术演进</strong>：从10Mbps到400Gbps，支持铜线（双绞线）与光纤传输。<br /></li><li><strong>特点</strong>：使用CSMA/CD，MAC地址全球唯一（48位，前24位为厂商OUI）。<br /></li></ul></li><li><strong>令牌环（Token Ring）</strong>：<ul><li><strong>原理</strong>：通过令牌传递控制信道访问，无冲突（如早期IBM令牌环网），已被以太网取代。</li></ul></li></ul><h5 id="广域网wan协议"><strong>2. 广域网（WAN）协议</strong></h5><ul><li><strong>点对点协议（PPP, Point-to-Point Protocol）</strong>：<ul><li><strong>应用</strong>：拨号上网、DSL、路由器间互联。<br /></li><li><strong>功能</strong>：支持认证（PAP/CHAP）、压缩、多链路捆绑（MP），帧格式含协议字段（如0x0021表示IP数据）。<br /></li></ul></li><li><strong>高级数据链路控制（HDLC, High-Level Data LinkControl）</strong>：<ul><li><strong>特点</strong>：面向比特的同步协议，用标志位（0x7E）定界帧，广泛用于电信运营商广域网（如租用线）。</li></ul></li></ul><h5 id="无线数据链路协议"><strong>3. 无线数据链路协议</strong></h5><ul><li><strong>802.11（WiFi）</strong>：<ul><li><strong>MAC层机制</strong>：CSMA/CA +RTS/CTS握手机制，支持DCF（分布式协调功能）与PCF（点协调功能）。<br /></li><li><strong>帧类型</strong>：数据帧、控制帧（如ACK）、管理帧（如关联请求）。</li></ul></li></ul><h4id="五数据链路层的关键设备"><strong>五、数据链路层的关键设备</strong></h4><ul><li><strong>交换机（Switch）</strong>：<ul><li><strong>工作原理</strong>：基于MAC地址学习，构建端口-MAC映射表，实现帧的精准转发（如将帧只发送到目标MAC对应的端口）。<br /></li><li><strong>功能</strong>：分割冲突域，提升局域网效率（每个端口为独立冲突域）。<br /></li></ul></li><li><strong>网桥（Bridge）</strong>：<ul><li><strong>早期设备</strong>：连接两个局域网，基于MAC地址转发帧，功能类似交换机但端口较少。<br /></li></ul></li><li><strong>网卡（NIC）</strong>：<ul><li><strong>硬件实现</strong>：集成MAC层与物理层功能，处理帧的发送与接收，包含唯一MAC地址。</li></ul></li></ul><h4id="六数据链路层的应用场景与技术演进"><strong>六、数据链路层的应用场景与技术演进</strong></h4><ul><li><strong>典型场景</strong>：<ul><li><strong>家庭网络</strong>：路由器的LAN口通过以太网数据链路连接电脑、手机（WiFi的802.11数据链路）。<br /></li><li><strong>企业网络</strong>：核心交换机通过高速以太网（如10G/40G）连接服务器，用VLAN（802.1Q）划分逻辑网络。<br /></li><li><strong>广域网互联</strong>：路由器通过PPP/HDLC协议连接ISP，传输IP数据包。<br /></li></ul></li><li><strong>技术趋势</strong>：<ul><li><strong>高速以太网</strong>：400G/800G以太网标准（IEEE802.3ck等），用于数据中心互联。<br /></li><li><strong>数据平面卸载（DPU）</strong>：用专用芯片卸载数据链路层处理（如CRC校验、VLAN标签处理），释放CPU资源。<br /></li><li><strong>软件定义网络（SDN）</strong>：通过OpenFlow协议控制数据链路层转发规则，实现灵活的网络流量调度。</li></ul></li></ul><h4id="七总结数据链路层的承上启下作用"><strong>七、总结：数据链路层的“承上启下”作用</strong></h4><p>数据链路层如同网络中的“数据搬运工”：向下利用物理层的比特传输能力，向上为网络层提供可靠的帧传输服务。从以太网的CSMA/CD到WiFi的CSMA/CA，从PPP的拨号连接到HDLC的广域网传输，其技术演进始终围绕“效率”与“可靠性”展开，是构建现代通信网络的关键基石。</p><h2 id="网络层">8.1.3 网络层</h2><h3id="网络层从电路连接到ip寻址的网络通信中枢">网络层：从“电路连接”到“IP寻址”的网络通信中枢</h3><h4id="一网络交换方式电路交换与包交换的核心差异"><strong>一、网络交换方式：电路交换与包交换的核心差异</strong></h4><h5 id="电路交换circuit-switching"><strong>1. 电路交换（CircuitSwitching）</strong></h5><ul><li><strong>核心原理</strong>：<br />在通信前建立一条专用物理链路（如电话线路），通信过程中链路持续占用，结束后释放。类似“打电话”时的专线连接。<br /></li><li><strong>工作流程</strong>：<ol type="1"><li><strong>建立连接</strong>：发送端向接收端申请物理通路（如电话拨号）。<br /></li><li><strong>数据传输</strong>：数据按固定路径顺序传输，无延迟波动。<br /></li><li><strong>释放连接</strong>：通信结束后断开链路。<br /></li></ol></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：延迟固定、适合实时业务（如语音通话），无数据丢失风险（链路专用）。<br /></li><li><strong>缺点</strong>：链路利用率低（即使无数据也占用），不适合突发数据传输。<br /></li></ul></li><li><strong>典型应用</strong>：传统电话网（PSTN）、早期长途通信网。</li></ul><h5 id="包交换packet-switching"><strong>2. 包交换（PacketSwitching）</strong></h5><ul><li><strong>核心原理</strong>：<br />将数据分割为独立“数据包”（Packet），每个包携带源/目的地址，通过网络节点动态路由传输。类似“寄信件”，每封信独立选择路径。<br /></li><li><strong>两种实现方式</strong>：<ul><li><strong>数据报（Datagram）</strong>：<ul><li>每个包独立路由，到达顺序可能乱序（如IP协议）。<br /></li><li>无连接建立过程，适合非实时业务（如网页浏览）。<br /></li></ul></li><li><strong>虚电路（Virtual Circuit）</strong>：<ul><li>通信前建立逻辑连接（虚拟路径），所有包沿同一路径传输（如X.25协议）。<br /></li><li>有连接建立/释放过程，类似电路交换但基于分组。<br /></li></ul></li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：链路利用率高（多用户共享），支持动态路由（抗网络故障）。<br /></li><li><strong>缺点</strong>：延迟不固定（路由选择波动），可能丢包（网络拥塞时）。<br /></li></ul></li><li><strong>典型应用</strong>：互联网（TCP/IP协议族）、路由器网络。</li></ul><h4id="二ip地址网络世界的数字门牌号"><strong>二、IP地址：网络世界的“数字门牌号”</strong></h4><h5 id="定义与核心作用"><strong>1. 定义与核心作用</strong></h5><ul><li><strong>逻辑地址标识</strong>：为网络设备分配的唯一标识符，用于跨网络的端到端通信（区别于数据链路层的MAC地址）。<br /></li><li><strong>OSI模型定位</strong>：网络层的核心协议（IP协议）负责解析和路由IP地址。</li></ul><h5 id="ipv4地址结构与表示"><strong>2.IPv4地址：结构与表示</strong></h5><ul><li><strong>32位二进制数</strong>：通常用“点分十进制”表示（如<code>192.168.1.1</code>），分为网络号和主机号两部分。<br /></li><li><strong>地址分类（Classful Networking）</strong>：<br />| 类别 | 网络号长度 | 范围（二进制前缀） | 适用场景 |<br />|------|------------|--------------------|------------------|<br />| A类 | 8位 | 0xxxxxxx | 大型网络（如跨国企业） |<br />| B类 | 16位 | 10xxxxxx | 中型网络（如企业园区） |<br />| C类 | 24位 | 110xxxxx | 小型网络（如家庭路由） |<br />| D类 | - | 1110xxxx | 组播地址（如视频会议） |<br />| E类 | - | 1111xxxx | 保留实验用 |<br /></li><li><strong>无类域间路由（CIDR）</strong>：<br />用“/网络前缀长度”表示（如<code>192.168.1.0/24</code>），打破传统分类，提高地址利用率。</li></ul><h5 id="ipv6地址解决地址枯竭的下一代方案"><strong>3.IPv6地址：解决地址枯竭的下一代方案</strong></h5><ul><li><strong>128位二进制数</strong>：用“冒号十六进制”表示（如<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>），可压缩连续零（如<code>2001:db8:85a3::8a2e:370:7334</code>）。<br /></li><li><strong>核心优势</strong>：<ul><li>地址总量：约3.4×10³⁸个，彻底解决IPv4地址不足问题。<br /></li><li>简化路由：固定长度前缀，路由表更高效。</li></ul></li></ul><h4id="三私网ip局域网内的内部门牌号"><strong>三、私网IP：局域网内的“内部门牌号”</strong></h4><h5 id="定义与用途"><strong>1. 定义与用途</strong></h5><ul><li><strong>私有地址范围</strong>：由RFC1918规定，仅在局域网内使用，无法直接在公网路由。<br /></li><li><strong>核心作用</strong>：<ul><li>节省公网IP资源（大量设备共享少量公网IP）。<br /></li><li>保护内网安全（公网无法直接访问私网IP设备）。</li></ul></li></ul><h5 id="三大私网ip段ipv4"><strong>2. 三大私网IP段（IPv4）</strong></h5><table><thead><tr class="header"><th>范围</th><th>掩码</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>10.0.0.0 ~ 10.255.255.255</td><td>255.0.0.0</td><td>大型企业内网</td></tr><tr class="even"><td>172.16.0.0 ~ 172.31.255.255</td><td>255.240.0.0</td><td>中型企业/校园网</td></tr><tr class="odd"><td>192.168.0.0 ~ 192.168.255.255</td><td>255.255.0.0</td><td>家庭/小型办公室网络</td></tr></tbody></table><h5 id="私网ip与nat网络地址转换"><strong>3.私网IP与NAT（网络地址转换）</strong></h5><ul><li><strong>NAT机制</strong>：<br />私网设备访问公网时，通过NAT路由器将私网IP转换为唯一公网IP（端口号区分不同设备）。<br /></li><li><strong>示例流程</strong>：<ol type="1"><li>家庭电脑（192.168.1.100:8080）访问百度服务器。<br /></li><li>路由器将源地址转换为公网IP（如202.102.128.68），并记录“192.168.1.100:8080→ 202.102.128.68:10001”的映射。<br /></li><li>百度服务器响应时，数据包到达路由器，通过映射还原为私网地址。</li></ol></li></ul><h5 id="私网ip的应用场景"><strong>4. 私网IP的应用场景</strong></h5><ul><li><strong>家庭网络</strong>：路由器分配192.168.1.0/24段IP，多设备共享一个公网IP上网。<br /></li><li><strong>企业内网</strong>：用10.0.0.0/8或172.16.0.0/12段构建隔离网络，通过防火墙控制对外访问。<br /></li><li><strong>云服务器内网</strong>：云计算平台（如AWS、阿里云）用私网IP构建内部通信，降低公网流量成本。</li></ul><h4id="四网络层的核心价值连接异构网络的桥梁"><strong>四、网络层的核心价值：连接异构网络的“桥梁”</strong></h4><p>网络层通过IP协议将不同类型的网络（如以太网、WiFi、广域网）互联，实现“端到端”的逻辑寻址。电路交换与包交换的选择决定了通信的效率与实时性，而IP地址与私网IP的编址体系，则为全球网络设备提供了有序的标识规则。从家庭路由器到跨国骨干网，网络层始终是支撑互联网互联互通的核心枢纽。</p><h2 id="传输层">8.1.4 传输层</h2><h3id="传输层udp与tcp数据传输的快递调度员">传输层：UDP与TCP——数据传输的“快递调度员”</h3><h4id="一传输层的核心使命端到端的数据交付"><strong>一、传输层的核心使命：端到端的数据交付</strong></h4><ul><li><strong>承上启下的定位</strong>：<br />位于网络层（IP）之上，为应用层（如HTTP、FTP）提供进程间通信服务，解决“应用到应用”的数据传输问题。<br /></li><li><strong>两大核心协议</strong>：<ul><li><strong>用户数据报协议（UDP）</strong>：无连接、轻量级传输，类似“明信片邮寄”。<br /></li><li><strong>传输控制协议（TCP）</strong>：面向连接、可靠传输，类似“快递签收服务”。</li></ul></li></ul><h4id="二udpuser-datagram-protocol简单高效的无连接传输"><strong>二、UDP（UserDatagram Protocol）：简单高效的“无连接传输”</strong></h4><h5 id="核心特性发送即忘的极简设计"><strong>1.核心特性：“发送即忘”的极简设计</strong></h5><ul><li><strong>无连接机制</strong>：<br />无需提前建立连接，直接打包数据发送（如发消息时不确认对方是否在线）。<br /></li><li><strong>非可靠交付</strong>：<ul><li>不保证数据到达、不处理丢包、不维护顺序。<br /></li><li>优点：延迟低（省去确认开销），适合实时性需求。<br /></li></ul></li><li><strong>轻量级头部</strong>：<br />仅8字节（源端口、目的端口、长度、校验和），传输效率高。</li></ul><h5 id="工作流程发了就走的无状态传输"><strong>2.工作流程：“发了就走”的无状态传输</strong></h5><ol type="1"><li>应用层数据+UDP头部→封装为UDP数据包（Datagram）。<br /></li><li>交给网络层（IP）发送，不等待响应。<br /></li><li>接收端UDP层直接将数据交给应用层，不反馈确认。</li></ol><h5 id="典型应用场景"><strong>3. 典型应用场景</strong></h5><ul><li><strong>实时通信</strong>：<ul><li>语音/视频通话（Skype、微信语音）：延迟比丢包更关键，少量丢包可通过音频补偿掩盖。<br /></li><li>在线游戏（王者荣耀）：实时操作反馈需低延迟，偶尔丢包可容忍（如角色瞬移补帧）。<br /></li></ul></li><li><strong>广播/组播</strong>：<ul><li>网络电视直播（IPTV）：同时向多用户发送数据，无需逐个确认。<br /></li></ul></li><li><strong>轻量级协议</strong>：<ul><li>DNS域名解析：查询请求短平快，响应超时可重发（由应用层处理）。</li></ul></li></ul><h4id="三tcptransmission-control-protocol可靠传输的精密控制者"><strong>三、TCP（TransmissionControl Protocol）：可靠传输的“精密控制者”</strong></h4><h5 id="核心特性全程跟踪的可靠连接"><strong>1.核心特性：“全程跟踪”的可靠连接</strong></h5><ul><li><strong>面向连接</strong>：<br />通信前必须建立连接（三次握手），结束后释放连接（四次挥手），类似“打电话前先拨号”。<br /></li><li><strong>可靠交付机制</strong>：<ul><li><strong>确认与重传</strong>：发送数据后等待ACK确认，超时未确认则重发。<br /></li><li><strong>流量控制</strong>：通过滑动窗口（WindowSize）动态调整发送速率，避免接收方缓冲区溢出。<br /></li><li><strong>拥塞控制</strong>：网络拥塞时降低发送速率（如慢启动、拥塞避免算法）。<br /></li></ul></li><li><strong>有序传输</strong>：<br />数据包编号+接收端排序，确保应用层按顺序接收数据。</li></ul><h5 id="关键机制详解"><strong>2. 关键机制详解</strong></h5><h6id="三次握手连接建立的安全认证"><strong>（1）三次握手：连接建立的“安全认证”</strong></h6><table><colgroup><col style="width: 10%" /><col style="width: 45%" /><col style="width: 44%" /></colgroup><thead><tr class="header"><th>步骤</th><th>发送方（A）→ 接收方（B）</th><th>状态变化</th></tr></thead><tbody><tr class="odd"><td>1</td><td>SYN（序列号x）</td><td>A: CLOSED → SYN_SENT</td></tr><tr class="even"><td>2</td><td>SYN+ACK（x+1，序列号y）</td><td>B: LISTEN → SYN_RCVD</td></tr><tr class="odd"><td>3</td><td>ACK（y+1）</td><td>A: SYN_SENT → ESTABLISHED<br>B: SYN_RCVD → ESTABLISHED</td></tr></tbody></table><ul><li><strong>核心目的</strong>：确认双方收发能力正常（如A发送SYN，B回复SYN+ACK表示“我收到了，我也能发”）。</li></ul><h6id="滑动窗口流量控制的调节阀"><strong>（2）滑动窗口：流量控制的“调节阀”</strong></h6><ul><li><strong>原理</strong>：接收方告知发送方“当前可接收的数据量”（窗口大小），发送方按此控制发送速率。<br /></li><li><strong>示例</strong>：<ul><li>接收方缓冲区剩余1000字节 → 告知窗口大小1000。<br /></li><li>发送方发送500字节，接收方确认后窗口缩小为500（剩余缓冲区500字节）。<br /></li><li>若发送方超过窗口大小发送，接收方会丢弃数据包并要求重传。</li></ul></li></ul><h6id="拥塞控制网络拥堵的灭火器"><strong>（3）拥塞控制：网络拥堵的“灭火器”</strong></h6><ul><li><strong>慢启动（SlowStart）</strong>：初始发送窗口小，每次收到确认后窗口指数增长（如从1→2→4→8…），避免突然大量发送导致拥塞。<br /></li><li><strong>拥塞避免</strong>：当窗口增长到“阈值”时，改为线性增长（避免超过网络承载能力）。<br /></li><li><strong>快速重传与恢复</strong>：若接收方连续三次收到重复ACK（表明丢包），立即重传丢失的数据包，无需等待超时（减少延迟）。</li></ul><h5 id="头部结构复杂但可靠的运输单据"><strong>3.头部结构：复杂但可靠的“运输单据”</strong></h5><ul><li><strong>20字节固定头部</strong>（常见字段）：<ul><li><strong>源端口/目的端口</strong>：标识应用进程（如HTTP用80端口）。<br /></li><li><strong>序列号/确认号</strong>：确保数据有序传输与确认。<br /></li><li><strong>控制位</strong>：<ul><li>SYN（连接建立）、ACK（确认）、FIN（连接释放）、RST（重置连接）等。<br /></li></ul></li><li><strong>窗口大小</strong>：告知对方当前可接收的数据量。</li></ul></li></ul><h5 id="典型应用场景-1"><strong>4. 典型应用场景</strong></h5><ul><li><strong>文件传输</strong>：<ul><li>FTP（文件传输协议）：需完整无缺传输文件，不允许丢包。<br /></li><li>邮件收发（SMTP、POP3）：邮件内容不能出错，依赖TCP可靠传输。<br /></li></ul></li><li><strong>网页浏览</strong>：<ul><li>HTTP/HTTPS：网页数据（文字、图片）需按顺序正确显示，丢包会导致页面错乱。<br /></li></ul></li><li><strong>远程登录</strong>：<ul><li>SSH/Telnet：命令行交互需确保每个字符按顺序到达，否则操作失效（如输入“cd/”变成“c /d”）。</li></ul></li></ul><h4 id="四udp-vs-tcp如何选择传输协议"><strong>四、UDP vsTCP：如何选择传输协议？</strong></h4><table><colgroup><col style="width: 18%" /><col style="width: 40%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th>维度</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr class="odd"><td><strong>连接性</strong></td><td>无连接（即发即走）</td><td>面向连接（三次握手）</td></tr><tr class="even"><td><strong>可靠性</strong></td><td>不可靠（不保证到达）</td><td>可靠（确认、重传、排序）</td></tr><tr class="odd"><td><strong>延迟</strong></td><td>低（无确认开销）</td><td>高（等待确认可能卡顿）</td></tr><tr class="even"><td><strong>头部开销</strong></td><td>8字节（轻量级）</td><td>20字节（含控制字段）</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>实时性高、少量丢包可容忍</td><td>数据完整性优先、非实时场景</td></tr><tr class="even"><td><strong>典型应用</strong></td><td>语音通话、在线游戏、DNS查询</td><td>网页浏览、文件下载、邮件传输</td></tr></tbody></table><h4id="五传输层的核心价值为应用定制传输服务"><strong>五、传输层的核心价值：为应用“定制传输服务”</strong></h4><p>UDP与TCP如同传输层的“左右臂”：前者用极简设计满足实时性需求，后者以复杂机制保障数据可靠。从刷短视频时的流畅播放（UDP）到下载系统更新时的完整无损（TCP），传输层根据应用场景动态选择协议，让不同类型的数据在网络中各得其所。理解这两大协议的差异，是掌握网络通信原理的关键一步。</p><h2 id="应用层">8.1.5 应用层</h2><h3id="应用层网络世界的用户交互大门从网页浏览到文件传输的终极实现">应用层：网络世界的“用户交互大门”——从网页浏览到文件传输的终极实现</h3><h4id="一应用层的定位连接用户与网络的最后一公里"><strong>一、应用层的定位：连接用户与网络的“最后一公里”</strong></h4><ul><li><strong>最贴近用户的一层</strong>：直接为用户应用程序（如微信、浏览器）提供服务，解决“如何通过网络完成具体业务”的问题。<br /></li><li><strong>基于下层协议（传输层UDP/TCP）</strong>：<ul><li>利用UDP的低延迟特性（如视频通话）或TCP的可靠性（如文件下载），封装成用户可感知的功能。</li></ul></li></ul><h4id="二应用层核心功能定义应用协议与数据格式"><strong>二、应用层核心功能：定义“应用协议”与数据格式</strong></h4><ol type="1"><li><strong>协议规范</strong>：规定数据传输的格式、交互流程（如HTTP请求如何构造、邮件如何发送）。<br /></li><li><strong>数据处理</strong>：将用户输入（如文字、文件）转换为网络可传输的格式（如JSON、二进制），并在接收端还原。<br /></li><li><strong>服务发现</strong>：通过域名（如www.baidu.com）或端口号（如80端口对应HTTP）定位网络服务。</li></ol><h4id="三经典应用层协议与场景解析"><strong>三、经典应用层协议与场景解析</strong></h4><h5 id="httphttps网页浏览的翻译官"><strong>1.HTTP/HTTPS：网页浏览的“翻译官”</strong></h5><ul><li><strong>超文本传输协议（HTTP）</strong><ul><li><strong>无状态交互</strong>：客户端（浏览器）发送请求→服务器响应数据，每次请求独立（如刷新网页需重新请求）。<br /></li><li><strong>请求-响应模型</strong>：<ul><li>请求方法：GET（获取资源）、POST（提交数据）、PUT（更新）等。<br /></li><li>响应状态码：200（成功）、404（资源不存在）、500（服务器错误）等。<br /></li></ul></li><li><strong>典型应用</strong>：浏览网页、API接口调用（如微信小程序获取数据）。</li></ul></li><li><strong>安全版HTTP（HTTPS）</strong><ul><li>在HTTP基础上添加TLS/SSL加密层，防止数据被窃听或篡改（如网购时的支付信息加密）。<br /></li><li><strong>差异</strong>：使用443端口（HTTP用80端口），URL以“https://”开头。</li></ul></li></ul><h5 id="ftpsftp文件传输的搬运工"><strong>2.FTP/SFTP：文件传输的“搬运工”</strong></h5><ul><li><strong>文件传输协议（FTP）</strong><ul><li><strong>双连接机制</strong>：<ul><li>控制连接：传输命令（如“下载文件”），长期保持。<br /></li><li>数据连接：传输实际文件数据，每次操作时建立。<br /></li></ul></li><li><strong>优缺点</strong>：<ul><li>优点：支持大文件分段传输、目录浏览。<br /></li><li>缺点：明文传输（账号密码易泄露），安全性低。</li></ul></li></ul></li><li><strong>安全文件传输（SFTP）</strong><ul><li>基于SSH协议加密，替代FTP成为主流（如服务器上传代码时用SFTP）。</li></ul></li></ul><h5 id="smtppop3imap邮件系统的邮递员"><strong>3.SMTP/POP3/IMAP：邮件系统的“邮递员”</strong></h5><ul><li><strong>SMTP（简单邮件传输协议）</strong>：客户端→服务器→服务器的邮件发送过程（如Outlook 发送邮件到网易服务器）。<br /></li><li><strong>POP3（邮局协议）</strong>：客户端从服务器“下载”邮件到本地，下载后服务器通常删除邮件（适合单设备使用）。<br /></li><li><strong>IMAP（互联网邮件访问协议）</strong>：客户端与服务器同步邮件，支持在线管理（如在手机和电脑上同步已读状态）。</li></ul><h5 id="dns网络世界的电话簿域名解析服务"><strong>4.DNS：网络世界的“电话簿”——域名解析服务</strong></h5><ul><li><strong>核心功能</strong>：将人类可读的域名（如www.taobao.com）转换为机器可读的IP地址（如140.207.xxx.xxx）。<br /></li><li><strong>解析流程（以访问百度为例）</strong>：<ol type="1"><li>客户端向本地DNS服务器查询“www.baidu.com”的IP。<br /></li><li>本地服务器若缓存中没有，向根域名服务器→.com顶级域名服务器→百度域名服务器递归查询。<br /></li><li>返回IP地址后，浏览器才能向该IP发送HTTP请求。</li></ol></li></ul><h5 id="dhcp自动分配ip的管理员"><strong>5.DHCP：自动分配IP的“管理员”</strong></h5><ul><li><strong>动态主机配置协议</strong>：<ul><li>当设备接入网络（如连接WiFi）时，自动获取IP地址、子网掩码、网关等网络参数，避免手动配置的繁琐。<br /></li></ul></li><li><strong>工作流程</strong>：<ol type="1"><li>设备发送DHCP Discover广播包，寻找DHCP服务器。<br /></li><li>服务器响应DHCP Offer，提供可用IP。<br /></li><li>设备确认接受（DHCPRequest），服务器分配IP并记录租期（通常24小时）。</li></ol></li></ul><h5 id="telnetssh远程控制的桥梁"><strong>6.Telnet/SSH：远程控制的“桥梁”</strong></h5><ul><li><strong>Telnet</strong>：明文传输的远程登录协议（如通过命令行控制路由器），因安全性差逐渐被淘汰。<br /></li><li><strong>SSH（安全外壳协议）</strong>：加密传输，支持远程命令执行、文件传输（SFTP基于SSH），是服务器管理的标准工具。</li></ul><h5 id="voiprtcp语音通话的实时引擎"><strong>7.VoIP/RTCP：语音通话的“实时引擎”</strong></h5><ul><li><strong>VoIP（网络语音协议）</strong>：如Skype、微信语音，将语音数据封装为UDP包传输（低延迟优先）。<br /></li><li><strong>RTCP（实时传输控制协议）</strong>：监控传输质量（丢包率、延迟），反馈给发送方调整参数（如降低音频采样率以减少带宽占用）。</li></ul><h4id="四应用层协议的分层设计哲学"><strong>四、应用层协议的“分层设计哲学”</strong></h4><p>以网页浏览为例，数据从应用层到物理层的封装过程：<br />1. <strong>应用层</strong>：HTTP请求（“获取index.html”）→封装为HTTP报文。<br />2. <strong>传输层</strong>：HTTP报文+TCP头部（目标端口80）→封装为TCP数据包。<br />3. <strong>网络层</strong>：TCP数据包+IP头部（目标IP）→封装为IP数据报。<br />4. <strong>数据链路层</strong>：IP数据报+MAC地址→ 封装为帧。<br />5.<strong>物理层</strong>：帧转换为电信号/光信号在网线/光纤中传输。<br />-<strong>优势</strong>：各层独立设计，如应用层升级HTTP/3时，无需修改下层协议。</p><h4id="五应用层的发展趋势从工具到生态"><strong>五、应用层的发展趋势：从“工具”到“生态”</strong></h4><ul><li><strong>微服务与API</strong>：应用层协议被拆解为细粒度接口（如支付宝的“支付接口”可被各APP调用）。<br /></li><li><strong>边缘计算与实时性</strong>：WebSocket协议（HTML5）支持浏览器与服务器双向实时通信（如网页聊天、股票行情推送）。<br /></li><li><strong>物联网（IoT）协议</strong>：<ul><li>MQTT：轻量级消息队列协议，适合低带宽设备（如智能灯泡、传感器）。<br /></li><li>CoAP：基于UDP的物联网应用协议，支持资源受限设备（如智能电表）。</li></ul></li></ul><h4id="六总结应用层网络价值的最终体现"><strong>六、总结：应用层——网络价值的最终体现</strong></h4><p>如果说底层协议是网络的“基础设施”，应用层则是赋予网络灵魂的“应用场景”。从办公时的邮件收发，到生活中的扫码支付，再到工业中的远程控制，应用层协议将抽象的网络通信转化为具体的用户价值。理解这些协议的工作原理，不仅能解释日常网络行为（如“为什么网页有时加载慢”），更能为开发应用程序（如设计API接口）提供底层逻辑支撑。</p><h1 id="第9章-信息安全">第9章 信息安全</h1><h2 id="密码学">9.3.1 密码学</h2><h3id="密码学基础对称加密与非对称加密">密码学基础：对称加密与非对称加密</h3><h4 id="一对称加密symmetric-encryption"><strong>一、对称加密（SymmetricEncryption）</strong></h4><h5 id="定义-3"><strong>1. 定义</strong></h5><ul><li>加密和解密使用<strong>同一把密钥</strong>，通信双方需提前共享密钥。</li><li>核心逻辑：发送方用密钥加密数据，接收方用相同密钥解密。</li></ul><h5 id="常见算法"><strong>2. 常见算法</strong></h5><table><colgroup><col style="width: 26%" /><col style="width: 26%" /><col style="width: 21%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th>算法名称</th><th>密钥长度</th><th>安全性</th><th>应用场景</th></tr></thead><tbody><tr class="odd"><td><strong>AES（高级加密标准）</strong></td><td>128/192/256位</td><td>目前主流，抗暴力破解能力强</td><td>数据传输（如SSL/TLS）、文件加密</td></tr><tr class="even"><td><strong>DES（数据加密标准）</strong></td><td>56位</td><td>已不安全（密钥过短）</td><td>旧系统兼容</td></tr><tr class="odd"><td><strong>3DES（三重DES）</strong></td><td>168位</td><td>比DES安全，但效率低</td><td>金融领域旧系统</td></tr><tr class="even"><td><strong>ChaCha20</strong></td><td>256位</td><td>高效，适合资源受限设备</td><td>移动端加密、VPN</td></tr></tbody></table><h5 id="优点"><strong>3. 优点</strong></h5><ul><li><strong>速度快</strong>：计算复杂度低，适合加密大量数据（如视频、文件）。</li><li><strong>实现简单</strong>：算法逻辑清晰，硬件加速支持广泛。</li></ul><h5 id="缺点"><strong>4. 缺点</strong></h5><ul><li><strong>密钥管理困难</strong>：通信双方需安全传递密钥，若密钥泄露则数据全失。</li><li><strong>无法验证身份</strong>：仅能加密数据，无法确认发送方身份。</li></ul><h4id="二非对称加密asymmetric-encryption"><strong>二、非对称加密（AsymmetricEncryption）</strong></h4><h5 id="定义-4"><strong>1. 定义</strong></h5><ul><li>使用<strong>密钥对（公钥+私钥）</strong>：<ul><li>公钥：公开，用于加密数据；<br /></li><li>私钥：仅持有者拥有，用于解密数据。<br /></li></ul></li><li>核心逻辑：公钥加密的内容只能用对应私钥解密，反之亦然（如私钥签名，公钥验证）。</li></ul><h5 id="常见算法-1"><strong>2. 常见算法</strong></h5><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>算法名称</th><th>安全基础</th><th>密钥长度</th><th>应用场景</th></tr></thead><tbody><tr class="odd"><td><strong>RSA</strong></td><td>大数分解难题</td><td>2048/4096位</td><td>数字签名、SSL/TLS密钥交换、证书认证</td></tr><tr class="even"><td><strong>ECC（椭圆曲线加密）</strong></td><td>椭圆曲线离散对数难题</td><td>256位（等效RSA 3072位）</td><td>移动端加密、区块链（如比特币）</td></tr><tr class="odd"><td><strong>Diffie-Hellman（DH）</strong></td><td>离散对数难题</td><td>2048位</td><td>密钥协商（不直接加密，用于生成对称密钥）</td></tr></tbody></table><h5 id="优点-1"><strong>3. 优点</strong></h5><ul><li><strong>密钥分发安全</strong>：公钥可公开传播，无需担心泄露。</li><li><strong>身份验证与签名</strong>：私钥可用于生成数字签名，确保数据完整性和发送方身份。</li></ul><h5 id="缺点-1"><strong>4. 缺点</strong></h5><ul><li><strong>速度慢</strong>：计算复杂度高，加密效率约为对称加密的1/1000。</li><li><strong>密钥长度长</strong>：如RSA 2048位密钥比AES256位长8倍，存储和传输成本高。</li></ul><h4 id="三对称加密-vs-非对称加密核心区别"><strong>三、对称加密 vs非对称加密：核心区别</strong></h4><table><colgroup><col style="width: 18%" /><col style="width: 40%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th>维度</th><th>对称加密</th><th>非对称加密</th></tr></thead><tbody><tr class="odd"><td><strong>密钥数量</strong></td><td>1个（加密解密同一密钥）</td><td>2个（公钥+私钥）</td></tr><tr class="even"><td><strong>安全性基础</strong></td><td>密钥保密性</td><td>数学难题（大数分解、离散对数）</td></tr><tr class="odd"><td><strong>速度</strong></td><td>快（适合大数据加密）</td><td>慢（适合小数据或密钥交换）</td></tr><tr class="even"><td><strong>身份验证</strong></td><td>不支持</td><td>支持（通过数字签名）</td></tr><tr class="odd"><td><strong>典型应用</strong></td><td>视频流、文件加密</td><td>数字证书、密钥协商、签名</td></tr></tbody></table><h4id="四实际应用两者的结合使用"><strong>四、实际应用：两者的结合使用</strong></h4><p>现实中常结合两者优势，例如：<br />1. <strong>TLS/SSL协议</strong>：<br />- 用非对称加密（如RSA）安全交换对称加密密钥（AES）；<br />- 后续数据传输用对称加密，兼顾安全与效率。<br />2. <strong>数字签名流程</strong>：<br />- 发送方用私钥对数据哈希值签名（非对称）；<br />- 接收方用公钥验证签名，并通过对称加密解析数据。</p><h4id="五延伸加密技术的发展趋势"><strong>五、延伸：加密技术的发展趋势</strong></h4><ul><li><strong>量子计算威胁</strong>：RSA等算法可能被量子计算机破解，ECC成为更优选择。<br /></li><li><strong>同态加密</strong>：允许在密文上直接计算，无需解密，属于非对称加密的前沿方向。</li></ul><p>通过理解对称与非对称加密的原理和应用，可更清晰地设计安全的加密方案，平衡安全性与效率需求。</p><h2 id="防火墙">9.3.2 防火墙</h2><div class="note warning flat"><p>防火墙影响网速</p></div><h3 id="防火墙网络安全的第一道屏障">防火墙：网络安全的第一道屏障</h3><h4id="一防火墙的基本概念与核心功能"><strong>一、防火墙的基本概念与核心功能</strong></h4><p><strong>定义</strong>：防火墙是位于计算机或网络之间的安全系统，通过监控、过滤进出的网络流量，阻止未经授权的访问并允许合法通信，本质是实现网络安全策略的硬件或软件组件。</p><p><strong>核心功能</strong>：<br />-<strong>访问控制</strong>：根据预设规则决定允许或拒绝流量（如禁止外部访问内部敏感端口）。<br />-<strong>边界防护</strong>：隔离可信网络（如企业内网）与不可信网络（如互联网），防止恶意入侵。<br />-<strong>流量监控与日志记录</strong>：记录网络活动，用于安全审计和异常行为分析。<br />-<strong>抗攻击能力</strong>：抵御常见攻击（如DDoS、端口扫描、IP欺骗等）。</p><h4id="二防火墙的主要类型与工作原理"><strong>二、防火墙的主要类型与工作原理</strong></h4><p>根据技术实现和工作层次，防火墙可分为以下几类：</p><h5 id="包过滤防火墙packet-filter-firewall"><strong>1.包过滤防火墙（Packet Filter Firewall）</strong></h5><ul><li><strong>工作层次</strong>：网络层（OSI第3层）和传输层（第4层）。<br /></li><li><strong>原理</strong>：基于数据包的IP地址、端口号、协议类型（如TCP/UDP）等头部信息进行过滤。<br /></li><li><strong>示例规则</strong>：允许内网IP（192.168.1.0/24）访问外网80端口（HTTP），禁止外网IP访问内网22端口（SSH）。<br /></li><li><strong>优点</strong>：处理速度快，资源消耗低。<br /></li><li><strong>缺点</strong>：无法识别数据包内容（如HTTP请求中的恶意代码），易被IP欺骗绕过。</li></ul><h5 id="状态检测防火墙stateful-inspection-firewall"><strong>2.状态检测防火墙（Stateful Inspection Firewall）</strong></h5><ul><li><strong>工作层次</strong>：网络层、传输层及会话层（第5层）。<br /></li><li><strong>原理</strong>：跟踪每个网络连接的“状态”（如连接建立、数据传输、断开），结合包过滤规则和会话状态信息进行决策。<br /></li><li><strong>核心机制</strong>：维护“状态表”记录合法连接，仅允许属于已建立连接的数据包通过。<br /></li><li><strong>示例</strong>：当用户通过浏览器访问网站时，防火墙记录该TCP连接的状态，允许返回的网页数据通过，阻止未授权的反向连接。<br /></li><li><strong>优点</strong>：比包过滤更安全，支持动态端口协议（如FTP被动模式）。<br /></li><li><strong>缺点</strong>：状态表维护需消耗内存，复杂场景下可能影响性能。</li></ul><h5 id="应用层网关防火墙application-layer-gateway-firewall"><strong>3.应用层网关防火墙（Application Layer Gateway Firewall）</strong></h5><ul><li><strong>工作层次</strong>：应用层（OSI第7层）。<br /></li><li><strong>原理</strong>：深度解析应用层协议（如HTTP、SMTP、FTP）的内容，根据内容规则过滤流量（如禁止邮件附件中的病毒文件）。<br /></li><li><strong>典型实现</strong>：<ul><li><strong>代理服务器（ProxyServer）</strong>：作为客户端和服务器的中间节点，接收客户端请求并转发给服务器，同时检查请求内容。<br /></li><li><strong>内容过滤</strong>：阻止包含恶意关键词、病毒或违规内容的流量。<br /></li></ul></li><li><strong>优点</strong>：细粒度控制应用层行为，有效防御应用层攻击（如SQL注入、跨站脚本）。<br /></li><li><strong>缺点</strong>：处理延迟高（需解析完整应用层数据），需为每种协议单独开发代理模块。</li></ul><h5 id="下一代防火墙next-generation-firewall-ngfw"><strong>4.下一代防火墙（Next-Generation Firewall, NGFW）</strong></h5><ul><li><strong>集成特性</strong>：<ul><li>融合状态检测、应用层过滤、入侵检测与防御（IDPS）、病毒防护、URL过滤等功能。<br /></li><li>支持基于用户身份、设备类型、应用场景的动态策略（如员工手机接入内网时限制P2P下载）。<br /></li></ul></li><li><strong>核心技术</strong>：<ul><li><strong>应用识别</strong>：通过深度包检测（DPI）识别加密流量中的应用（如SSL加密的恶意软件通信）。<br /></li><li><strong>威胁情报集成</strong>：对接外部威胁数据库，实时阻断已知恶意IP或域名的连接。<br /></li></ul></li><li><strong>应用场景</strong>：企业数据中心、云计算环境，需应对复杂混合威胁的场景。</li></ul><h4id="三防火墙的部署模式与典型架构"><strong>三、防火墙的部署模式与典型架构</strong></h4><h5 id="部署模式"><strong>1. 部署模式</strong></h5><ul><li><strong>网络边界部署</strong>：连接内网与外网（如企业路由器后部署防火墙），是最常见的部署方式。<br /></li><li><strong>DMZ（非军事区）部署</strong>：在防火墙后划分独立区域，放置对外服务（如Web服务器），允许外网访问DMZ但限制其访问内网。<br /></li><li><strong>内部分段部署</strong>：在企业内网中细分多个安全区域（如财务部门与研发部门），用防火墙控制区域间流量。</li></ul><h5 id="典型架构示例"><strong>2. 典型架构示例</strong></h5><pre><code>                          +----------------+                          |    互联网      |                          +----------------+                                |  ↓                +-------------+------------+                |   边界防火墙   |   入侵检测系统（IDS）|                +-------------+------------+                                |  ↓                +-----------------------------------+                |               DMZ区域               |                |  Web服务器  |  邮件服务器  |  DNS服务器 |                +-----------------------------------+                                |  ↓                +-------------+------------+                |   内部防火墙   |   流量监控设备   |                +-------------+------------+                                |  ↓                          +----------------+                          |    企业内网      |                          +----------------+</code></pre><h4id="四防火墙的策略设计与规则示例"><strong>四、防火墙的策略设计与规则示例</strong></h4><h5 id="策略设计原则"><strong>1. 策略设计原则</strong></h5><ul><li><strong>默认拒绝（DefaultDeny）</strong>：未明确允许的流量默认拒绝，避免“过度开放”风险。<br /></li><li><strong>最小权限原则</strong>：仅允许必要的服务和端口，如Web服务器仅开放80/443端口。<br /></li><li><strong>顺序优先级</strong>：规则按顺序匹配，前一条规则优先于后一条（如先禁止恶意IP，再允许正常流量）。</li></ul><h5 id="规则示例状态检测防火墙"><strong>2.规则示例（状态检测防火墙）</strong></h5><table><colgroup><col style="width: 10%" /><col style="width: 12%" /><col style="width: 15%" /><col style="width: 15%" /><col style="width: 6%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th>规则序号</th><th>方向</th><th>源IP</th><th>目标IP</th><th>协议</th><th>端口</th><th>动作</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>1</td><td>入站</td><td>任意</td><td>192.168.1.100</td><td>TCP</td><td>443</td><td>允许</td><td>允许外网访问内网HTTPS服务器</td></tr><tr class="even"><td>2</td><td>出站</td><td>192.168.1.0/24</td><td>任意</td><td>UDP</td><td>53</td><td>允许</td><td>允许内网DNS解析请求</td></tr><tr class="odd"><td>3</td><td>入站</td><td>10.0.0.1</td><td>任意</td><td>任意</td><td>任意</td><td>拒绝</td><td>阻止已知恶意IP的所有连接</td></tr><tr class="even"><td>4</td><td>默认规则</td><td>任意</td><td>任意</td><td>任意</td><td>任意</td><td>拒绝</td><td>未匹配规则的流量全部拒绝</td></tr></tbody></table><h4id="五防火墙的局限性与补充安全措施"><strong>五、防火墙的局限性与补充安全措施</strong></h4><ol type="1"><li><strong>无法防御的威胁</strong>：<ul><li><strong>内部攻击</strong>：来自内网的恶意用户或被攻陷的设备（如员工U盘植入病毒）。<br /></li><li><strong>加密流量中的恶意内容</strong>：未启用DPI的防火墙无法检测SSL加密的攻击。<br /></li><li><strong>零日漏洞（Zero-DayExploits）</strong>：利用未知漏洞的攻击，需依赖威胁情报实时更新。</li></ul></li><li><strong>补充措施</strong>：<ul><li><strong>结合IDPS（入侵检测与防御系统）</strong>：实时识别并阻断异常行为。<br /></li><li><strong>终端安全软件</strong>：防御内部攻击和零日漏洞（如端点检测与响应EDR）。<br /></li><li><strong>安全意识培训</strong>：减少人为漏洞（如钓鱼邮件诱导用户绕过防火墙）。</li></ul></li></ol><h4 id="六防火墙的发展趋势"><strong>六、防火墙的发展趋势</strong></h4><ul><li><strong>云化与SDN集成</strong>：基于软件定义网络（SDN）实现动态防火墙策略，适配云计算环境（如AWS的网络访问控制列表ACL）。<br /></li><li><strong>AI与机器学习应用</strong>：通过AI分析流量模式，自动识别新型威胁并优化规则（如减少误报率）。<br /></li><li><strong>量子计算抗性</strong>：研究抗量子密码算法，确保未来防火墙加密机制的安全性。</li></ul><p>防火墙作为网络安全的基础组件，其技术演进始终围绕“平衡安全性与性能”“适应新型网络架构”展开，需结合具体场景选择合适的类型与部署策略。</p><h2 id="入侵检测">9.3.3 入侵检测</h2><div class="note warning flat"><p>入侵检测不影响网速</p></div><h3id="入侵检测网络安全的实时监控系统">入侵检测：网络安全的“实时监控系统”</h3><h4id="一入侵检测的核心概念与定位"><strong>一、入侵检测的核心概念与定位</strong></h4><p><strong>定义</strong>：入侵检测（IntrusionDetection，ID）是通过实时监控网络或系统活动，识别违反安全策略的行为（如未授权访问、恶意代码执行、数据窃取）并发出警报的技术。其核心组件是入侵检测系统（IntrusionDetectionSystem，IDS），而具备实时阻断能力的系统称为入侵防御系统（IntrusionPrevention System，IPS）。</p><p><strong>与防火墙的区别</strong>：<br />-<strong>防火墙</strong>：基于预设规则过滤流量，是“第一道屏障”，但无法检测规则外的新型攻击。<br />-<strong>IDS/IPS</strong>：主动分析流量内容和行为模式，发现隐藏威胁，是“监控摄像头+警报器”。</p><h4id="二入侵检测系统ids的主要类型"><strong>二、入侵检测系统（IDS）的主要类型</strong></h4><h5 id="基于网络的入侵检测系统nids"><strong>1.基于网络的入侵检测系统（NIDS）</strong></h5><ul><li><strong>部署位置</strong>：串联或旁路部署在网络链路中（如交换机镜像端口）。<br /></li><li><strong>工作原理</strong>：监听网络数据包，分析流量特征（如端口扫描、DDoS攻击、恶意协议行为）。<br /></li><li><strong>典型工具</strong>：Snort（开源）、Suricata、Bro（现称Zeek）。<br /></li><li><strong>优点</strong>：不影响原有网络架构，可监控整个网段的流量。<br /></li><li><strong>缺点</strong>：无法检测加密流量（如SSL）中的恶意内容，对高速网络（如10Gbps）可能产生丢包。</li></ul><h5 id="基于主机的入侵检测系统hids"><strong>2.基于主机的入侵检测系统（HIDS）</strong></h5><ul><li><strong>部署位置</strong>：安装在目标主机（如服务器、终端）上。<br /></li><li><strong>工作原理</strong>：监控主机日志、进程活动、文件系统变化（如异常进程启动、敏感文件修改）。<br /></li><li><strong>典型工具</strong>：OSSEC、AIDE（文件完整性检查）、Windows事件日志分析工具。<br /></li><li><strong>优点</strong>：可检测针对主机的深层攻击（如内核级rootkit），不受网络加密影响。<br /></li><li><strong>缺点</strong>：需在每台主机部署，资源消耗高，对主机性能有一定影响。</li></ul><h5 id="混合型入侵检测系统hybrid-ids"><strong>3.混合型入侵检测系统（Hybrid IDS）</strong></h5><ul><li><strong>融合特点</strong>：结合NIDS的网络流量分析和HIDS的主机行为监控，形成立体防御。<br /></li><li><strong>应用场景</strong>：企业核心服务器集群，同时监控网络攻击和主机异常。</li></ul><h4id="三入侵检测的核心技术与工作流程"><strong>三、入侵检测的核心技术与工作流程</strong></h4><h5 id="检测技术分类"><strong>1. 检测技术分类</strong></h5><table><colgroup><col style="width: 9%" /><col style="width: 42%" /><col style="width: 19%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>技术类型</th><th>核心原理</th><th>典型应用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td><strong>异常检测（Anomaly Detection）</strong></td><td>建立正常行为基线，将偏离基线的活动视为可疑（如突然激增的流量、异常登录时间）</td><td>发现未知攻击（零日漏洞）</td><td>无需已知攻击特征库</td><td>误报率高（如业务高峰导致的流量异常）</td></tr><tr class="even"><td><strong>误用检测（Misuse Detection）</strong></td><td>匹配已知攻击特征（如恶意代码签名、漏洞利用模式），又称“特征检测”</td><td>防御已知漏洞和恶意软件</td><td>准确率高，误报率低</td><td>无法检测新型未收录的攻击</td></tr><tr class="odd"><td><strong>协议分析（Protocol Analysis）</strong></td><td>解析应用层协议（如HTTP、FTP）的格式，检测违反协议规范的攻击（如畸形数据包）</td><td>防御缓冲区溢出、SQL注入等协议层攻击</td><td>针对性强，可定位攻击点</td><td>需为每种协议定制检测规则</td></tr><tr class="even"><td><strong>流量异常检测（Traffic Anomaly Detection）</strong></td><td>分析流量统计特征（如源IP分布、端口访问模式），识别DDoS、端口扫描等行为</td><td>网络层大规模攻击防御</td><td>实时性高，适合流量清洗</td><td>难以定位具体攻击源</td></tr></tbody></table><h5 id="工作流程以nids为例"><strong>2.工作流程（以NIDS为例）</strong></h5><ol type="1"><li><strong>数据采集</strong>：捕获网络数据包，提取头部信息（IP、端口）和payload 内容。<br /></li><li><strong>预处理</strong>：过滤无关流量（如广播包），重组碎片化数据包（防分片攻击）。<br /></li><li><strong>检测分析</strong>：<ul><li>异常检测：对比当前流量与历史基线（如CPU使用率、连接数）。<br /></li><li>误用检测：匹配特征库（如Snort规则：<code>alert tcp any any -&gt; any 80 (content:"eval("; msg:"PHP Code Injection");</code>）。<br /></li></ul></li><li><strong>响应处理</strong>：生成警报（如发送邮件、写入日志），或联动IPS阻断连接。</li></ol><h4id="四入侵防御系统ips从检测到阻断"><strong>四、入侵防御系统（IPS）：从“检测”到“阻断”</strong></h4><ul><li><strong>核心差异</strong>：<ul><li>IDS仅报警，IPS可实时拦截攻击（如丢弃恶意数据包、重置TCP连接）。<br /></li></ul></li><li><strong>部署方式</strong>：串联在网络链路中（如防火墙与服务器之间），成为流量必经之路。<br /></li><li><strong>典型场景</strong>：<ul><li>阻止勒索软件的C2通信（通过特征匹配域名或IP）。<br /></li><li>拦截SQL注入攻击（检测HTTP请求中的恶意字符串<code>' OR 1=1--</code>）。</li></ul></li></ul><h4id="五入侵检测的应用场景与典型案例"><strong>五、入侵检测的应用场景与典型案例</strong></h4><h5 id="企业网络安全"><strong>1. 企业网络安全</strong></h5><ul><li><strong>场景</strong>：监控企业内网与外网边界，检测外部渗透攻击（如钓鱼邮件携带的恶意附件）。<br /></li><li><strong>案例</strong>：某公司NIDS发现大量来自海外IP的445端口（SMB）扫描，预警可能的勒索软件攻击。</li></ul><h5 id="云计算与云安全"><strong>2. 云计算与云安全</strong></h5><ul><li><strong>场景</strong>：云服务提供商（如AWS）通过分布式NIDS监控租户流量，防止跨租户攻击。<br /></li><li><strong>技术</strong>：容器安全中使用HIDS监控容器内进程异常（如加密货币挖矿程序）。</li></ul><h5 id="工业控制系统ics"><strong>3. 工业控制系统（ICS）</strong></h5><ul><li><strong>场景</strong>：电力、能源行业的ICS网络中，检测针对SCADA系统的协议攻击（如Modbus协议篡改）。<br /></li><li><strong>特殊需求</strong>：低延迟（攻击响应需在毫秒级），避免误阻断影响生产。</li></ul><h4id="六入侵检测的局限性与优化措施"><strong>六、入侵检测的局限性与优化措施</strong></h4><ol type="1"><li><strong>主要挑战</strong>：<ul><li><strong>误报与漏报</strong>：异常检测易将正常业务波动误判为攻击（如电商大促时的流量激增）；误用检测依赖特征库更新，可能漏检新型攻击。<br /></li><li><strong>加密流量检测</strong>：HTTPS流量占比超80%，传统IDS无法解析SSL内容（需部署SSL卸载设备或支持DPI的IPS）。<br /></li><li><strong>海量警报处理</strong>：大型企业IDS每日可能产生数万条警报，需人工筛选有效信息。</li></ul></li><li><strong>优化方案</strong>：<ul><li><strong>联动SIEM（安全信息和事件管理）</strong>：集中管理多源警报，通过关联分析减少噪音（如同一IP的端口扫描+漏洞利用尝试视为高风险）。<br /></li><li><strong>AI与机器学习</strong>：<ul><li>异常检测：用神经网络学习用户行为模式（如员工办公时段的访问习惯）。<br /></li><li>特征提取：用深度学习自动识别恶意流量的隐藏特征（如加密流量中的流量模式异常）。<br /></li></ul></li><li><strong>威胁情报集成</strong>：对接外部情报源（如VirusTotal、AlienVault），实时阻断已知恶意IP或域名。</li></ul></li></ol><h4id="七入侵检测技术的发展趋势"><strong>七、入侵检测技术的发展趋势</strong></h4><ol type="1"><li><strong>云原生与分布式检测</strong>：<ul><li>基于Kubernetes部署分布式IDS，适应容器化、微服务架构（如SysdigSecure）。<br /></li></ul></li><li><strong>物联网（IoT）安全</strong>：<ul><li>针对IoT设备资源有限的特点，开发轻量级HIDS（如监控智能家居设备的异常网络请求）。<br /></li></ul></li><li><strong>量子计算与AI融合</strong>：<ul><li>研究量子机器学习算法，提升对加密流量中量子级攻击的检测能力。<br /></li></ul></li><li><strong>行为分析与用户实体行为分析（UEBA）</strong>：<ul><li>从“检测攻击”转向“分析用户行为”，识别内部威胁（如员工账号被盗用后的异常数据下载）。</li></ul></li></ol><h4id="八开源入侵检测工具推荐"><strong>八、开源入侵检测工具推荐</strong></h4><ul><li><strong>Snort</strong>：最经典的开源NIDS，支持自定义规则，适合学习和中小企业场景。<br /></li><li><strong>Suricata</strong>：性能优于Snort，支持多核处理和SSL流量检测。<br /></li><li><strong>OSSEC</strong>：开源HIDS，支持日志分析、文件完整性检查，跨平台兼容（Windows/Linux）。</li></ul><p>入侵检测作为网络安全的“免疫系统”，其价值不仅在于发现攻击，更在于通过持续监控构建动态防御体系。在实际部署中，需结合业务场景选择合适的IDS类型，并与防火墙、IPS、SIEM等组件联动，形成立体防护网络。</p><h2 id="笔者补充rsa算法">笔者补充：RSA算法</h2><h3id="rsa算法详解从数学原理到实际应用">RSA算法详解：从数学原理到实际应用</h3><h4 id="一rsa的基本概念"><strong>一、RSA的基本概念</strong></h4><ul><li><strong>提出时间</strong>：1977年由Ron Rivest、Adi Shamir和LeonardAdleman提出，是首个成熟的非对称加密算法。</li><li><strong>安全基础</strong>：基于<strong>大数分解难题</strong>——将两个大质数的乘积分解为原质数在计算上不可行。</li><li><strong>核心特点</strong>：使用公钥（Public Key）加密，私钥（PrivateKey）解密，两者成对出现且无法互相推导。</li></ul><h4 id="二rsa算法的数学基础"><strong>二、RSA算法的数学基础</strong></h4><ol type="1"><li><strong>质数与互质</strong><ul><li>质数：只能被1和自身整除的数（如2, 3, 5, 7...）。<br /></li><li>互质：两数的最大公约数（gcd）为1（如3和8，gcd(3,8)=1）。</li></ul></li><li><strong>欧拉函数φ(n)</strong><ul><li>定义：对于正整数n，φ(n)表示小于n且与n互质的数的个数。<br /></li><li>性质：若n=p×q（p、q为质数），则φ(n)=(p-1)(q-1)。<br />例：n=15=3×5，则φ(15)=(3-1)(5-1)=8（与15互质的数：1,2,4,7,8,11,13,14）。</li></ul></li><li><strong>模运算与欧拉定理</strong><ul><li>欧拉定理：若a与n互质，则a^φ(n) ≡ 1 mod n。<br /></li><li>推论：a^(kφ(n)+1) ≡ a modn（k为任意整数），这是RSA解密的核心公式。</li></ul></li></ol><h4 id="三rsa算法的完整流程"><strong>三、RSA算法的完整流程</strong></h4><h5 id="密钥生成步骤"><strong>1. 密钥生成步骤</strong></h5><ol type="1"><li><strong>选两个大质数p和q</strong><ul><li>例：取p=3，q=7（实际应用中p和q通常为1024位或2048位质数）。</li></ul></li><li><strong>计算n=p×q，作为密钥的模数</strong><ul><li>例：n=3×7=21，n的长度决定了RSA的安全强度（如n=2048位时，分解难度极高）。</li></ul></li><li><strong>计算欧拉函数φ(n)=(p-1)(q-1)</strong><ul><li>例：φ(21)=(3-1)(7-1)=12。</li></ul></li><li><strong>选公钥e：满足1&lt;e&lt;φ(n)且gcd(e,φ(n))=1</strong><ul><li>例：选e=5（gcd(5,12)=1），e通常取小质数（如65537）以提高计算效率。</li></ul></li><li><strong>计算私钥d：满足e×d ≡ 1 mod φ(n)</strong><ul><li>即d是e在模φ(n)下的乘法逆元，可通过扩展欧几里得算法求解。<br /></li><li>例：5×d ≡1 mod12 → d=5（5×5=25≡1 mod12）。</li></ul></li><li><strong>生成密钥对</strong><ul><li>公钥：(e, n) = (5, 21)，可公开；<br /></li><li>私钥：(d, n) = (5, 21)，需严格保密。</li></ul></li></ol><h5 id="加密过程"><strong>2. 加密过程</strong></h5><ul><li>明文m需满足1≤m&lt;n，加密公式：<br /><strong>密文c = m^e mod n</strong><br /></li><li>例：加密m=2（假设m=2&lt;21）：<br />c=2^5 mod21=32 mod21=11。</li></ul><h5 id="解密过程"><strong>3. 解密过程</strong></h5><ul><li>解密公式：<br /><strong>明文m = c^d mod n</strong><br /></li><li>例：解密c=11：<br />m=11^5 mod21。计算过程：<br />11^2=121 mod21=16，11<sup>4=(16)</sup>2=256 mod21=4，11^5=4×11=44mod21=2，成功还原m=2。</li></ul><h4 id="四rsa的安全性分析"><strong>四、RSA的安全性分析</strong></h4><ol type="1"><li><p><strong>安全核心</strong>：若n=p×q，攻击者需通过n分解出p和q才能计算φ(n)，进而推导d。</p><ul><li>当n=2048位时，目前最快的超级计算机也需数万亿年才能分解（基于传统算法）。</li></ul></li><li><p><strong>密钥长度建议</strong><br />| 年份 | 推荐密钥长度 | 抗暴力破解能力 ||------------|--------------|------------------------------| | 2020-2030| 2048位 | 抵御传统计算机攻击 | | 2030年后 | 4096位 |防范量子计算初步威胁（预计） |</p></li><li><p><strong>潜在威胁</strong></p><ul><li><strong>量子计算</strong>：Shor算法可在多项式时间内分解大数，可能破解RSA（需数千量子比特的量子计算机）。<br /></li><li><strong>实现漏洞</strong>：如私钥泄露、弱质数选择（如p-1或q-1含小因子）、加密消息过小等。</li></ul></li></ol><h4 id="五rsa的典型应用场景"><strong>五、RSA的典型应用场景</strong></h4><ol type="1"><li><strong>SSL/TLS协议</strong><ul><li>用于客户端与服务器的密钥协商：服务器用公钥加密对称加密密钥（如AES），客户端用私钥解密，后续通信使用对称加密提升效率。</li></ul></li><li><strong>数字签名</strong><ul><li>发送方用私钥对消息哈希值签名（即m=哈希值，加密得到签名），接收方用公钥验证，确保消息未被篡改且来源可信。</li></ul></li><li><strong>加密邮件（如PGP）</strong><ul><li>用收件人公钥加密邮件内容，仅收件人私钥可解密，保证邮件隐私。</li></ul></li><li><strong>区块链与数字货币</strong><ul><li>用于钱包地址生成和交易签名（如以太坊账户基于RSA变种ECDSA，但核心逻辑类似）。</li></ul></li></ol><h4 id="六rsa的优缺点对比"><strong>六、RSA的优缺点对比</strong></h4><table><thead><tr class="header"><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>1. 非对称设计，密钥分发安全</td><td>1. 加密速度慢（比AES慢1000+倍）</td></tr><tr class="even"><td>2. 支持数字签名和身份验证</td><td>2. 明文长度受限（需小于n）</td></tr><tr class="odd"><td>3. 数学原理成熟，标准化程度高</td><td>3. 密钥长度长（2048位密钥约256字节）</td></tr></tbody></table><h4id="七rsa与其他算法的结合使用"><strong>七、RSA与其他算法的结合使用</strong></h4><ul><li><strong>与对称加密结合</strong>（如TLS流程）：<ol type="1"><li>客户端生成对称密钥k；<br /></li><li>用服务器公钥加密k，发送给服务器；<br /></li><li>服务器用私钥解密得到k，后续通信使用k进行对称加密。<br />（兼顾RSA的安全性和对称加密的效率）</li></ol></li><li><strong>与哈希函数结合</strong>（数字签名流程）：<ol type="1"><li>对消息m计算哈希值H(m)；<br /></li><li>用私钥加密H(m)得到签名s；<br /></li><li>接收方用公钥解密s得到H'(m)，对比H'(m)与H(m)是否一致。</li></ol></li></ul><h4 id="八rsa的发展与挑战"><strong>八、RSA的发展与挑战</strong></h4><ul><li><strong>后量子密码学</strong>：因量子计算威胁，学界正研究抗量子算法（如基于格理论、编码理论的算法），但RSA仍为当前主流。<br /></li><li><strong>效率优化</strong>：通过硬件加速（如Intel的AES-NI指令集）和算法优化（如中国剩余定理加速解密）提升性能。</li></ul><p>理解RSA的数学原理和应用场景，有助于在实际开发中正确使用加密技术，平衡安全性与工程实现的需求。</p><h1 id="第10章-机器学习概论">第10章 机器学习概论</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 计算机科学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 操作 SQLite3 核心功能</title>
      <link href="/2025/05/21/Python%20%E6%93%8D%E4%BD%9C%20SQLite3%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"/>
      <url>/2025/05/21/Python%20%E6%93%8D%E4%BD%9C%20SQLite3%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>Python 操作 SQLite3核心功能的表格化整理</strong>，涵盖连接、建表、CRUD等核心操作，代码可直接复制使用： ### <strong>Python SQLite3操作指令速查表</strong></p><table><colgroup><col style="width: 12%" /><col style="width: 54%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th><strong>操作场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>说明/注意事项</strong></th></tr></thead><tbody><tr class="odd"><td><strong>连接数据库（文件）</strong></td><td><code>import sqlite3&lt;br&gt;conn = sqlite3.connect('mydb.db')</code></td><td>文件不存在时自动创建<br>支持绝对路径（如<code>'/data/mydb.db'</code>）</td></tr><tr class="even"><td><strong>连接内存数据库（临时）</strong></td><td><code>conn = sqlite3.connect(':memory:')</code></td><td>程序关闭后数据丢失，适合临时测试场景</td></tr><tr class="odd"><td><strong>创建游标</strong></td><td><code>cursor = conn.cursor()</code></td><td>所有 SQL 操作需通过游标执行</td></tr><tr class="even"><td><strong>关闭连接</strong></td><td><code>conn.close()</code><br>（推荐）<code>with sqlite3.connect('mydb.db') as conn: ...</code></td><td><code>with</code> 块自动提交事务并关闭连接，避免资源泄漏</td></tr></tbody></table><h3 id="表结构操作ddl"><strong>表结构操作（DDL）</strong></h3><table><colgroup><col style="width: 3%" /><col style="width: 76%" /><col style="width: 19%" /></colgroup><thead><tr class="header"><th><strong>操作场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr class="odd"><td><strong>创建表（含约束）</strong></td><td><code>python&lt;br&gt;with conn:)&lt;br&gt;    cursor.execute('''&lt;br&gt;        CREATE TABLE IF NOT EXISTS users (&lt;br&gt;            id INTEGER PRIMARY KEY AUTOINCREMENT,&lt;br&gt;            name TEXT NOT NULL,&lt;br&gt;            email TEXT UNIQUE&lt;br&gt;        )&lt;br&gt;    ''')&lt;br&gt;</code></td><td><code>IF NOT EXISTS</code>避免重复创建<br><code>AUTOINCREMENT</code>自增主键<br><code>UNIQUE</code> 唯一约束</td></tr><tr class="even"><td><strong>查询所有表名</strong></td><td><code>python&lt;br&gt;cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")&lt;br&gt;print(cursor.fetchall())&lt;br&gt;</code></td><td>通过系统表 <code>sqlite_master</code> 获取元数据</td></tr><tr class="odd"><td><strong>删除表</strong></td><td><code>python&lt;br&gt;with conn:)&lt;br&gt;    cursor.execute("DROP TABLE IF EXISTS users")&lt;br&gt;</code></td><td>谨慎操作！数据无法恢复</td></tr><tr class="even"><td><strong>添加列</strong></td><td><code>python&lt;br&gt;with conn:)&lt;br&gt;    cursor.execute("ALTER TABLE users ADD COLUMN age INTEGER")&lt;br&gt;</code></td><td>SQLite 仅支持有限修改（如添加列），不支持删除/重命名列</td></tr></tbody></table><h3 id="数据操作crud"><strong>数据操作（CRUD）</strong></h3><h4 id="插入数据create"><strong>插入数据（Create）</strong></h4><table><colgroup><col style="width: 10%" /><col style="width: 46%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th><strong>场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>安全实践</strong></th></tr></thead><tbody><tr class="odd"><td><strong>单条插入</strong></td><td><code>python&lt;br&gt;with conn:)&lt;br&gt;    cursor.execute('''&lt;br&gt;        INSERT INTO users (name, email) VALUES (?, ?)&lt;br&gt;    ''', ('Alice', 'a@example.com'))&lt;br&gt;</code></td><td>用 <code>?</code> 占位符防 SQL注入，参数以元组传递（即使单个参数也需加逗号）</td></tr><tr class="even"><td><strong>批量插入</strong></td><td><code>python&lt;br&gt;users = [('Bob', 'b@example.com'), ('Charlie', 'c@example.com')]&lt;br&gt;with conn:)&lt;br&gt;    cursor.executemany('''&lt;br&gt;        INSERT INTO users (name, email) VALUES (?, ?)&lt;br&gt;    ''', users)&lt;br&gt;</code></td><td><code>executemany()</code> 比循环单条插入效率更高</td></tr></tbody></table><h4 id="查询数据read"><strong>查询数据（Read）</strong></h4><table><colgroup><col style="width: 10%" /><col style="width: 46%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th><strong>场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>结果处理</strong></th></tr></thead><tbody><tr class="odd"><td><strong>查询所有记录</strong></td><td><code>python&lt;br&gt;cursor.execute("SELECT * FROM users")&lt;br&gt;rows = cursor.fetchall()&lt;br&gt;for row in rows: print(row)  # 元组形式：(1, 'Alice', 'a@example.com')&lt;br&gt;</code></td><td><code>fetchall()</code> 返回元组列表，按列顺序取值</td></tr><tr class="even"><td><strong>条件查询</strong></td><td><code>python&lt;br&gt;cursor.execute("SELECT * FROM users WHERE age &gt; ?", (28,))&lt;br&gt;results = cursor.fetchall()&lt;br&gt;</code></td><td>条件参数用元组传递，避免直接拼接字符串</td></tr><tr class="odd"><td><strong>查询单条记录</strong></td><td><code>python&lt;br&gt;cursor.execute("SELECT * FROM users WHERE id = ?", (1,))&lt;br&gt;user = cursor.fetchone()  # 取第一条记录&lt;br&gt;</code></td><td><code>fetchone()</code> 返回单个元组，无结果时返回<code>None</code></td></tr></tbody></table><h4 id="更新数据update"><strong>更新数据（Update）</strong></h4><table><colgroup><col style="width: 10%" /><col style="width: 46%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th><strong>场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr class="odd"><td><strong>按条件更新</strong></td><td><code>python&lt;br&gt;with conn:)&lt;br&gt;    cursor.execute('''&lt;br&gt;        UPDATE users SET email = ? WHERE name = ?&lt;br&gt;    ''', ('new@example.com', 'Alice'))&lt;br&gt;</code></td><td>必须包含 <code>WHERE</code> 条件，避免全表更新</td></tr></tbody></table><h4 id="删除数据delete"><strong>删除数据（Delete）</strong></h4><table style="width:100%;"><colgroup><col style="width: 7%" /><col style="width: 76%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th><strong>场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr class="odd"><td><strong>按条件删除</strong></td><td><code>python&lt;br&gt;with conn:)&lt;br&gt;    cursor.execute("DELETE FROM users WHERE id = ?", (1,))&lt;br&gt;</code></td><td>无 <code>WHERE</code> 条件会删除全表数据！</td></tr></tbody></table><h3 id="事务与错误处理"><strong>事务与错误处理</strong></h3><table><colgroup><col style="width: 4%" /><col style="width: 85%" /><col style="width: 10%" /></colgroup><thead><tr class="header"><th><strong>场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>核心逻辑</strong></th></tr></thead><tbody><tr class="odd"><td><strong>手动事务控制</strong></td><td><code>python&lt;br&gt;try:&lt;br&gt;    cursor.execute("操作1")&lt;br&gt;    cursor.execute("操作2")&lt;br&gt;    conn.commit()  # 成功则提交&lt;br&gt;except sqlite3.Error as e:&lt;br&gt;    conn.rollback()  # 失败则回滚&lt;br&gt;    print("错误:", e)&lt;br&gt;</code></td><td>确保一组操作要么全部成功，要么全部回滚</td></tr><tr class="even"><td><strong>自动提交事务</strong></td><td><code>python&lt;br&gt;with sqlite3.connect('mydb.db') as conn:)&lt;br&gt;    cursor.execute("INSERT INTO users VALUES (..., ...)")&lt;br&gt;    # 退出 with 块时自动提交&lt;br&gt;</code></td><td>推荐写法！简化代码并避免忘记 <code>commit</code></td></tr></tbody></table><h3 id="高级技巧"><strong>高级技巧</strong></h3><table><colgroup><col style="width: 6%" /><col style="width: 85%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th><strong>场景</strong></th><th><strong>Python 代码示例</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr class="odd"><td><strong>以字典形式返回结果</strong></td><td><code>python&lt;br&gt;conn.row_factory = sqlite3.Row&lt;br&gt;cursor.execute("SELECT * FROM users")&lt;br&gt;row = cursor.fetchone()&lt;br&gt;print(dict(row))  # 输出: &#123;'id': 1, 'name': 'Alice', ...&#125;&lt;br&gt;</code></td><td>方便通过字段名访问数据，提升可读性</td></tr><tr class="even"><td><strong>使用可视化工具调试</strong></td><td>安装 <a href="https://sqlitebrowser.org/">DB Browser forSQLite</a><br>直接打开 <code>.db</code> 文件执行 SQL</td><td>图形化查看表结构和数据，替代代码调试</td></tr></tbody></table><h3 id="最佳实践速记进阶"><strong>最佳实践速记(进阶)</strong></h3><ol type="1"><li><strong>永远用 <code>?</code> 占位符</strong>：防止 SQL 注入，如<code>cursor.execute("SELECT * FROM users WHERE name = ?", (user_name,))</code>。<br /></li><li><strong>用 <code>with</code>管理连接</strong>：自动处理事务提交和资源释放，避免代码遗漏。<br /></li><li><strong>批量操作首选<code>executemany</code></strong>：比循环单条插入效率高 10倍以上。<br /></li><li><strong>调试用可视化工具</strong>：遇到数据问题时，用 DB Browser直接查看文件内容。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理B1-期中复习</title>
      <link href="/2025/04/28/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86B1-%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/04/28/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86B1-%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="转动惯量">转动惯量</h2><h3 id="常见物体转动惯量">常见物体转动惯量</h3><p><imgsrc="https://pic1.imgdb.cn/item/680f835958cb8da5c8d264ac.png" /></p><p>考虑径向厚度的圆环（空心圆柱）的转动惯量为： <spanclass="math display">\[​I=\frac{1}{2}M\left(R_{1}^{2}+R_{2}^{2}\right)\]</span>其中 𝑅1R1​ 为内半径，𝑅2R2​ 为外半径。这一公式统一了薄圆环和实心圆柱的特例，表明转动惯量随质量分布的半径平方线性叠加。</p><h3 id="平行轴定理">平行轴定理</h3><p>刚体对任意轴的转动惯量＝对质心的转动惯量 + 质量乘以两个轴距离的平方<span class="math display">\[J=J_{c}+m d^{2}\]</span></p><h3 id="转动定律">转动定律</h3><ul><li>力矩：对于定轴转动，力矩等于力垂直于轴的分量，乘以它到轴的距离，<span class="math inline">\(M=Fd\)</span></li><li>转动定律：角加速度与合外力矩成正比，与转动惯量成反比，<spanclass="math inline">\(M=J \alpha\)</span></li></ul><h1 id="静电场">静电场</h1><h2 id="高斯定理">高斯定理</h2><p><imgsrc="https://pic1.imgdb.cn/item/681db34258cb8da5c8e8e0ba.png" /></p><p><imgsrc="https://pic1.imgdb.cn/item/681db31a58cb8da5c8e8e0ae.png" /></p><p><imgsrc="https://pic1.imgdb.cn/item/681db2d758cb8da5c8e8e08a.png" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学物理 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学A2-期中复习</title>
      <link href="/2025/04/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6A2-%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/04/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6A2-%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数极限">函数极限</h1><h2 id="证明极限不存在">证明极限不存在</h2><h3 id="通用思路">通用思路</h3><p><imgsrc="https://pic1.imgdb.cn/item/6803018f88c538a9b5dcbf95.png" /></p><h3 id="小公式">小公式</h3><p><img src="https://pic1.imgdb.cn/item/6803050a88c538a9b5dcd274.png" />### 核心例题</p><p><imgsrc="https://pic1.imgdb.cn/item/6803079d88c538a9b5dce0c8.png" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 期中复习 </tag>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解锁 MCP 协议：开启 AI 新世界大门</title>
      <link href="/2025/04/13/%E8%A7%A3%E9%94%81%20MCP%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%BC%80%E5%90%AF%20AI%20%E6%96%B0%E4%B8%96%E7%95%8C%E5%A4%A7%E9%97%A8/"/>
      <url>/2025/04/13/%E8%A7%A3%E9%94%81%20MCP%20%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%BC%80%E5%90%AF%20AI%20%E6%96%B0%E4%B8%96%E7%95%8C%E5%A4%A7%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>在人工智能蓬勃发展的当下，我们常常探寻如何让这个神奇的技术更完美地融入生活、赋能百业。接下来，咱们换个新奇又易懂的视角，把AI 和 MCP 想象成人体的大脑与手，以此深入剖析它们的奇妙关联，看看 MCP协议究竟是如何为 AI 注入强大动力的。</p><h2 id="一ai-与-mcp大脑与手的奇幻联动">一、AI 与MCP：大脑与手的奇幻联动</h2><p>在这个独特视角下，AI宛如人体的大脑，是智慧的核心中枢。它拥有令人惊叹的思考、学习以及决策天赋。就像大脑持续接收外界纷杂的信息，AI也能海量吸纳各种数据，凭借复杂精妙的算法，将数据转化为知识与模型，进而理解任务的复杂性，做出精准判断。无论是预测市场趋势、诊断疾病，还是解析自然语言，AI都能应对自如，恰似大脑指挥身体应对生活的种种挑战。</p><p>而此时，MCP协议闪亮登场，它担当的角色恰似灵活的双手。双手是大脑实现意图、与外界互动的得力助手，MCP协议对 AI 而言亦是如此。它精心构建起标准化的沟通桥梁，让 AI这颗“大脑”能与外部世界无缝对接。无论是本地存储的海量信息宝库，还是远程专业的API 资源，又或是形形色色功能各异的软件工具，MCP协议都能像手抓取物品、操控器具一样，助力 AI精准连接、随心调用。打个比方，当 AI想要深入研究某个课题，需要从数据库调取大量资料时，MCP协议就迅速行动，熟练地“抓取”所需数据，稳稳递到 AI “手中”；若 AI试图优化一份文案，MCP 协议便能灵巧调用文本编辑工具，帮 AI 实现想法。</p><h2 id="二ai-领域的两大门派与-mcp-的交融">二、AI 领域的两大“门派”与 MCP的交融</h2><p>不过，在进一步探究 MCP 协议的精妙之处前，得先了解 AI领域的两大重要流派——计算机视觉派和软件调用派，看看它们与 MCP是如何相互交织、各显神通的。</p><h3 id="计算机视觉派">计算机视觉派</h3><p>这一派系宛如大脑的“视觉皮层”，专注赋予计算机“火眼金睛”，使其能看懂图像与视频内容，模拟人类视觉系统行事。核心“秘籍”是深度学习算法，像卷积神经网络（CNN）这类高深功夫，用海量图像数据“喂养”模型，让它自动抓取图像特征，进而达成图像识别、目标检测、图像分割、视频理解等绝技。在安防监控领域，计算机视觉技术实时紧盯视频画面，异常行为、目标踪迹都逃不过它的法眼；于自动驾驶赛道，车辆靠摄像头采集道路图像，经计算机视觉算法识别交通标志、车道线、行人与其他车辆，为驾驶决策提供关键指引。</p><p>而 MCP 协议为计算机视觉派的 AI应用拓展了边界。当计算机视觉模型识别出图像中的特定物体，需要调用外部数据库查询该物体的详细信息，或者联动专业分析软件对图像数据进行深度剖析时，MCP协议就能发挥作用，打通内外资源，让视觉 AI 的功能得以升华。</p><h3 id="软件调用派">软件调用派</h3><p>软件调用派好似大脑的“运动协调中枢”，走的是一条与外部协同作战的“蹊径”，专注于AI 系统与外部软件工具、服务的协同。靠特定协议或接口，尤其是 MCP 协议，AI得以调动各类现成软件资源，像数据库管理系统、文件处理工具、数据分析软件、云计算服务等，来搞定特定任务。在智能办公场景里，AI调用办公软件自动生成文档、报表；智能客服场景下，AI联合知识库系统、业务处理软件，给用户答疑解惑。</p><p>MCP协议让软件调用派如虎添翼，它解决了不同软件间的兼容性、接口适配等难题，使得AI 调用软件资源更加流畅高效。原本可能因软件对接不畅而受阻的复杂任务，在MCP 协议的协调下，都能顺利推进，让 AI 的能力得以充分释放。</p><h2 id="三剖析-mcp-架构协同作战的精密体系">三、剖析 MCP架构：协同作战的精密体系</h2><p>深入探究，MCP协议拥有一套严谨高效的架构，如同人体精密协调的神经系统。</p><p>MCP 主机，作为指令的发起者，通常是我们熟悉的智能写作助手、智能客服等AI 应用，它明确目标，向 MCP 客户端下达任务，就如同大脑发出行动指令。MCP客户端则像敏捷的神经纤维，在主机与 MCP服务器之间高效穿梭，确保信息传递无误，维持二者紧密的一对一连接。</p><p>而 MCP 服务器堪称资源宝库，既储备丰富的上下文信息，让 AI随时调取过往交互记忆，又持有各类实用工具，涵盖文件读取、数据分析等，仿若手部肌肉存储着执行各种动作的能量与技巧。当客户端携需求而至，服务器迅速响应，提供有力支持。三者协同发力，保障AI 系统流畅运行，精准执行各项任务。</p><h2 id="四探寻-mcp-特性点亮-ai-前行灯塔">四、探寻 MCP 特性，点亮 AI前行灯塔</h2><ol type="1"><li><p><strong>开放性：激活 AI 生态潜能</strong> MCP协议的开放性，犹如为 AI 生态注入一股蓬勃动力。它允许服务商便捷开发API，促使不同 AI工具打破藩篱，共享连接模式。这意味着更多创意应用将如雨后春笋般涌现，激发无限可能，推动AI迈向更广阔天地。想象大脑与外界的交流不再受限，创意想法能够借助多样的工具快速实现，AI的未来充满希望。</p></li><li><p><strong>安全护航：筑牢数据交互防线</strong>在数据安全至关重要的今天，MCP 协议精心构建了安全双向连接机制。API密钥、用户隐私数据等敏感信息，在传输与存储过程中，均受到严密保护。如同给珍贵文物套上层层防护，每一次数据交互都历经多重加密与验证，确保万无一失，让AI 放心探索知识海洋。就像双手在抓取物品时，会小心翼翼保护易碎品，MCP协议保障数据安全也是这般谨慎。</p></li><li><p><strong>灵活拓展：适配 AI 生态需求</strong> AI的发展瞬息万变，需求层出不穷。MCP协议凭借出色的扩展性与模块化设计从容应对。基于经典客户端 -服务器架构，它能按需灵活嵌入新模块。开发者只需轻松添加 MCP服务器，即可拓展系统边界，满足复杂多变的 AI应用需求，宛如为成长中的建筑不断添砖加瓦，让 AI的“身体”能够与时俱进。</p></li></ol><h2 id="五对比-function-callingmcp-协议的独特优势">五、对比 FunctionCalling：MCP 协议的独特优势</h2><p>在 AI 工具集成领域，Function Calling 曾备受关注，它专注于助力 AI结构化调用外部功能，类似为 AI 配备精准操作指南。</p><p>然而，MCP 协议视野更为宽广。Function Calling 侧重于工具的简单调用，而MCP 协议志在打破数据孤岛，深度赋能 AI实现复杂的数据访问、精细的文件操作乃至 Web自动化。二者协同互补，方能全方位提升 AI综合实力，使其在智能化浪潮中破浪前行。就好比单纯的手部精细动作训练与学会综合运用双手去完成复杂任务的区别，MCP协议让 AI 具备更强的实操能力。</p><h2 id="六总结">六、总结</h2><p>MCP 协议为 AI 发展开辟了全新路径，它打破数据禁锢，强化 AI能力，让我们距离智能生活更近一步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> MCP协议 </tag>
            
            <tag> 热点解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用笔记</title>
      <link href="/2025/04/09/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/04/09/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="linux系统基础操作">Linux系统基础操作</h1><p>pwd——查看当前目录 cd 目录名——进入目录 mkdir 文件夹名——新建文件夹ls——查看当前路径下的文件 touch 文件名——当前目录下新建文件 mv 文件名目标地址——剪切文件 cp 文件名 目标地址 重命名——复制文件 rm文件名——删除文件 rm-r 文件夹名——删除文件夹 sudo ——提权指令</p><h1 id="cpython极简基础">C++&amp;Python极简基础</h1><h1 id="安装ros系统">安装ROS系统</h1><p><ahref="https://blog.csdn.net/PlutooRx/article/details/127558240">【ROS】在Ubuntu 20.04 安装 ROS 的详细教程_ubuntu20.04安装ros-CSDN博客</a></p><p>20.04找不到命令先输入：sudo apt install python3-rosdep</p><p>初始化 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdepc init</span><br></pre></td></tr></table></figure></p><p>第一个终端 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure></p><p>第二个终端，出现小海龟 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>第三个终端，控制移动 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim  turtle_teleop_key</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机科学导论》算法练习</title>
      <link href="/2025/04/09/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
      <url>/2025/04/09/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="求平方根的三种方法">求平方根的三种方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close_method</span>(<span class="params">num, precision=<span class="number">1e-4</span></span>):<span class="comment">#这里的精确度太高会导致程序死循环#趋近法</span></span><br><span class="line">    result = <span class="number">0.0</span></span><br><span class="line">    i = <span class="number">0.00001</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(result ** <span class="number">2</span> - num) &gt; precision:</span><br><span class="line">        result += i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> result ** <span class="number">2</span> &gt; num:<span class="comment">#超过目标值就缩小增量（课本上没有这步）</span></span><br><span class="line">            i = -i / <span class="number">10</span></span><br><span class="line">            result += i</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_method</span>(<span class="params">num, precision=<span class="number">1e-6</span></span>):<span class="comment">#二分法</span></span><br><span class="line">    low, high = <span class="number">0</span>, num</span><br><span class="line">    <span class="keyword">while</span> high - low &gt; precision:</span><br><span class="line">        mid = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid ** <span class="number">2</span> &gt; num:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newton_iteration_method</span>(<span class="params">num, precision=<span class="number">1e-6</span></span>):<span class="comment">#牛顿法</span></span><br><span class="line">    x = num</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(x * x - num) &gt; precision:</span><br><span class="line">        x = <span class="number">0.5</span> * (x + num / x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input_num = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个正整数（输入小于等于0的数退出程序）: &quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> input_num &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;程序退出&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        close_result = close_method(input_num)</span><br><span class="line">        binary_result = binary_search_method(input_num)</span><br><span class="line">        newton_result = newton_iteration_method(input_num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;趋近法计算的平方根: <span class="subst">&#123;close_result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;二分查找法计算的平方根: <span class="subst">&#123;binary_result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;牛顿迭代法计算的平方根: <span class="subst">&#123;newton_result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入无效，请输入一个数字。&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="分解质因数">分解质因数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prime_factorize</span>(<span class="params">n, factor=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> n % factor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [factor] + prime_factorize(n // factor, factor)</span><br><span class="line">    <span class="keyword">return</span> prime_factorize(n, factor + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个正整数: &quot;</span>))</span><br><span class="line">factors = prime_factorize(num)</span><br><span class="line">result = <span class="string">&#x27;*&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, factors))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span>=<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="分治法找最大最小数">分治法找最大最小数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_max_min</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    <span class="keyword">if</span> low == high:</span><br><span class="line">        <span class="keyword">return</span> arr[low], arr[low]</span><br><span class="line">    <span class="keyword">elif</span> high - low == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> arr[low] &lt; arr[high]:</span><br><span class="line">            <span class="keyword">return</span> arr[high], arr[low]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arr[low], arr[high]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;分治法的递归过程&#x27;&#x27;&#x27;</span></span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        max1, min1 = find_max_min(arr, low, mid)</span><br><span class="line">        max2, min2 = find_max_min(arr, mid + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max1, max2), <span class="built_in">min</span>(min1, min2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要生成的随机数的数量: &quot;</span>))</span><br><span class="line">arr = [random.randint(<span class="number">1</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]<span class="comment">#生成的随机数列表</span></span><br><span class="line">max_num, min_num = find_max_min(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;生成的随机数列表: <span class="subst">&#123;arr&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最大数: <span class="subst">&#123;max_num&#125;</span>, 最小数: <span class="subst">&#123;min_num&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 杭电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M0603C电机使用</title>
      <link href="/2025/03/04/M0603C%E7%94%B5%E6%9C%BA%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/03/04/M0603C%E7%94%B5%E6%9C%BA%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="电机使用文档">电机使用文档</h1><h1 id="历代代码">历代代码</h1><h2 id="阶段一">阶段一</h2><h3 id="crc-8maxim校验码计算算法">CRC-8/MAXIM校验码计算算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CRC-8/MAXIM 计算函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>; <span class="comment">// 初始值</span></span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++; <span class="comment">// 逐字节异或</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123; <span class="comment">// LSB-first 处理</span></span><br><span class="line">      <span class="keyword">if</span> (crc &amp; <span class="number">0x01</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span>; <span class="comment">// 反转多项式 0x8C</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc; <span class="comment">// 无最终异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送动态速度">发送动态速度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="number">9</span>]; <span class="comment">// 接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个变量，用于替换原数据帧中的 0x01 0x2C</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dynamic_byte1 = <span class="number">0x01</span>; <span class="comment">// 默认值 0x01（可修改）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dynamic_byte2 = <span class="number">0x2C</span>; <span class="comment">// 默认值 0x2C（可修改）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CRC-8/MAXIM 计算函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial2.begin(<span class="number">115200</span>); <span class="comment">// 初始化串口（根据实际使用的串口调整）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 原始数据帧（9字节）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> data_frame[] = &#123;</span><br><span class="line">      <span class="number">0x01</span>, <span class="number">0x64</span>,</span><br><span class="line">      dynamic_byte1, <span class="comment">// 动态字节1</span></span><br><span class="line">      dynamic_byte2, <span class="comment">// 动态字节2</span></span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">  <span class="comment">// 计算 CRC-8/MAXIM</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">  <span class="comment">// 发送完整帧（9数据 + 1CRC）</span></span><br><span class="line">  Serial2.write(data_frame, <span class="keyword">sizeof</span>(data_frame)); <span class="comment">// 发送前9字节</span></span><br><span class="line">  Serial2.write(crc);                            <span class="comment">// 发送CRC字节</span></span><br><span class="line">  delay(<span class="number">1000</span>); <span class="comment">// 每秒发送一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>; <span class="comment">// 初始值</span></span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++; <span class="comment">// 逐字节异或</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123; <span class="comment">// LSB-first 处理</span></span><br><span class="line">      <span class="keyword">if</span> (crc &amp; <span class="number">0x01</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span>; <span class="comment">// 反转多项式 0x8C</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc; <span class="comment">// 无最终异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="速度限幅">速度限幅</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">200</span>; <span class="comment">// 示例：目标转速（超限值将被约束）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;            <span class="comment">// 存储解析后的实际转速</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>]; <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;       <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= CRC函数 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);  <span class="comment">// 调试输出</span></span><br><span class="line">  Serial2.begin(<span class="number">115200</span>); <span class="comment">// 主串口（全双工）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">1000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;<span class="comment">// 每秒发送</span></span><br><span class="line">    <span class="comment">// 速度限幅：约束在 [-150, 150] RPM 之间</span></span><br><span class="line">    <span class="type">int</span> clamped_rpm = target_rpm;</span><br><span class="line">    <span class="keyword">if</span> (clamped_rpm &gt; <span class="number">150</span>)</span><br><span class="line">      clamped_rpm = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (clamped_rpm &lt; <span class="number">-150</span>)</span><br><span class="line">      clamped_rpm = <span class="number">-150</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为带符号的 16 位整数（10倍值）</span></span><br><span class="line">    <span class="type">int16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分解为两个字节（大端序）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte1 = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>; <span class="comment">// 高位字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte2 = speed_value &amp; <span class="number">0xFF</span>;        <span class="comment">// 低位字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造数据帧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[] = &#123;</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x64</span>,</span><br><span class="line">        byte1, byte2, <span class="comment">// 动态字节</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并发送</span></span><br><span class="line">    Serial2.write(data_frame, <span class="number">9</span>);             <span class="comment">// 发送数据</span></span><br><span class="line">    Serial2.write(crc8_maxim(data_frame, <span class="number">9</span>)); <span class="comment">// 发送CRC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试输出（实际应用可删除）</span></span><br><span class="line">    Serial.print(<span class="string">&quot;[SEND] Target RPM: &quot;</span>);</span><br><span class="line">    Serial.print(target_rpm);</span><br><span class="line">    Serial.print(<span class="string">&quot; -&gt; Clamped RPM: &quot;</span>);</span><br><span class="line">    Serial.print(clamped_rpm);</span><br><span class="line">    Serial.print(<span class="string">&quot; -&gt; HEX: 0x&quot;</span>);</span><br><span class="line">    Serial.print(byte1, HEX);</span><br><span class="line">    Serial.print(byte2, HEX);</span><br><span class="line">    Serial.println();</span><br><span class="line">    </span><br><span class="line">    last_send = millis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> recv_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    recv_buffer[recv_index++] = Serial2.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收满10字节后处理</span></span><br><span class="line">    <span class="keyword">if</span> (recv_index == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 验证帧头 + CRC</span></span><br><span class="line">      <span class="keyword">if</span> (recv_buffer[<span class="number">0</span>] == <span class="number">0x01</span> &amp;&amp;</span><br><span class="line">          recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span> &amp;&amp;</span><br><span class="line">          crc8_maxim(recv_buffer, <span class="number">9</span>) == recv_buffer[<span class="number">9</span>])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 合并两字节（注意符号扩展）</span></span><br><span class="line">        <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为实际 RPM（考虑符号）</span></span><br><span class="line">        actual_rpm = raw_value / <span class="number">10</span>; <span class="comment">// 还原10倍关系</span></span><br><span class="line">        data_valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调试输出</span></span><br><span class="line">        Serial.print(<span class="string">&quot;[RECV] Actual RPM: &quot;</span>);</span><br><span class="line">        Serial.print(actual_rpm);</span><br><span class="line">        Serial.print(<span class="string">&quot; (HEX: 0x&quot;</span>);</span><br><span class="line">        Serial.print(recv_buffer[<span class="number">2</span>], HEX);</span><br><span class="line">        Serial.print(recv_buffer[<span class="number">3</span>], HEX);</span><br><span class="line">        Serial.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        data_valid = <span class="literal">false</span>;</span><br><span class="line">        Serial.println(<span class="string">&quot;[ERROR] Invalid Data!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      recv_index = <span class="number">0</span>; <span class="comment">// 重置接收索引</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; <span class="number">0x01</span>) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝牙反馈数据">蓝牙反馈数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">200</span>; <span class="comment">// 示例：目标转速（超限值将被约束）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;            <span class="comment">// 存储解析后的实际转速</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>]; <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;       <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= CRC函数 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);      <span class="comment">// 调试输出</span></span><br><span class="line">  Serial2.begin(<span class="number">115200</span>);     <span class="comment">// 主串口（全双工）</span></span><br><span class="line">  SerialBT.begin(<span class="string">&quot;BAKUMAN&quot;</span>); <span class="comment">// 如果没有参数传入则默认是蓝牙名称是: &quot;ESP32&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">1000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;<span class="comment">// 每秒发送</span></span><br><span class="line"><span class="comment">// 速度限幅：约束在 [-150, 150] RPM 之间</span></span><br><span class="line">    <span class="type">int</span> clamped_rpm = target_rpm;</span><br><span class="line">    <span class="keyword">if</span> (clamped_rpm &gt; <span class="number">150</span>)</span><br><span class="line">      clamped_rpm = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (clamped_rpm &lt; <span class="number">-150</span>)</span><br><span class="line">      clamped_rpm = <span class="number">-150</span>;</span><br><span class="line"><span class="comment">// 转换为带符号的 16 位整数（10倍值）</span></span><br><span class="line">    <span class="type">int16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 分解为两个字节（大端序）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte1 = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>; <span class="comment">// 高位字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte2 = speed_value &amp; <span class="number">0xFF</span>;        <span class="comment">// 低位字节</span></span><br><span class="line"><span class="comment">// 构造数据帧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[] = &#123;</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x64</span>,</span><br><span class="line">        byte1, byte2, <span class="comment">// 动态字节</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">// 计算并发送</span></span><br><span class="line">    Serial2.write(data_frame, <span class="number">9</span>);             <span class="comment">// 发送数据</span></span><br><span class="line">    Serial2.write(crc8_maxim(data_frame, <span class="number">9</span>)); <span class="comment">// 发送CRC</span></span><br><span class="line">    last_send = millis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> recv_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    recv_buffer[recv_index++] = Serial2.read();</span><br><span class="line"><span class="comment">// 收满10字节后处理</span></span><br><span class="line">    <span class="keyword">if</span> (recv_index == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 验证帧头 + CRC</span></span><br><span class="line">      <span class="keyword">if</span> (recv_buffer[<span class="number">0</span>] == <span class="number">0x01</span> &amp;&amp;</span><br><span class="line">          recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span> &amp;&amp;</span><br><span class="line">          crc8_maxim(recv_buffer, <span class="number">9</span>) == recv_buffer[<span class="number">9</span>])</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">// 合并两字节（注意符号扩展）</span></span><br><span class="line">        <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 转换为实际 RPM（考虑符号）</span></span><br><span class="line">        actual_rpm = raw_value / <span class="number">10</span>; <span class="comment">// 还原10倍关系</span></span><br><span class="line">        data_valid = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 调试输出</span></span><br><span class="line">        SerialBT.print(<span class="string">&quot;[RECV] Actual RPM: &quot;</span>);</span><br><span class="line">        SerialBT.print(actual_rpm);</span><br><span class="line">        SerialBT.print(<span class="string">&quot; (HEX: 0x&quot;</span>);</span><br><span class="line">        SerialBT.print(recv_buffer[<span class="number">2</span>], HEX);</span><br><span class="line">        SerialBT.print(recv_buffer[<span class="number">3</span>], HEX);</span><br><span class="line">        SerialBT.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        data_valid = <span class="literal">false</span>;</span><br><span class="line">        SerialBT.println(<span class="string">&quot;[ERROR] Invalid Data!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      recv_index = <span class="number">0</span>; <span class="comment">// 重置接收索引</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; <span class="number">0x01</span>) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加入模式切换">加入模式切换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 预定义协议帧 =================</span></span><br><span class="line"><span class="comment">// 开环指令帧：01 A0 00 00 00 00 00 00 00 9E</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> open_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9E</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 速度环指令帧：01 A0 02 00 00 00 00 00 00 E4</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> speed_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 控制模式定义 =================</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ControlMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SPEED_LOOP, <span class="comment">// 速度环模式</span></span><br><span class="line">  OPEN_LOOP   <span class="comment">// 开环模式</span></span><br><span class="line">&#125;;</span><br><span class="line">ControlMode current_mode = SPEED_LOOP; <span class="comment">// 初始模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">30</span>; <span class="comment">// 目标转速（速度环模式有效）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;               <span class="comment">// 实际转速</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>];    <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bt_recv_buffer[<span class="number">10</span>]; <span class="comment">// 蓝牙接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;          <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= CRC函数 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; <span class="number">0x01</span>) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);      <span class="comment">// USB调试</span></span><br><span class="line">  Serial2.begin(<span class="number">115200</span>);     <span class="comment">// 主串口（全双工）</span></span><br><span class="line">  SerialBT.begin(<span class="string">&quot;BAKUMAN&quot;</span>); <span class="comment">// 蓝牙名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">1000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;<span class="comment">// 每秒发送一次</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[<span class="number">9</span>];</span><br><span class="line"><span class="comment">// 根据模式构造数据帧</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123;<span class="comment">// 速度环模式：发送转速指令</span></span><br><span class="line">      <span class="type">int</span> clamped_rpm = constrain(target_rpm, <span class="number">-150</span>, <span class="number">150</span>); <span class="comment">// 进行速度限幅</span></span><br><span class="line">      <span class="type">int16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line">      data_frame[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line">      data_frame[<span class="number">2</span>] = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">      data_frame[<span class="number">3</span>] = speed_value &amp; <span class="number">0xFF</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>); <span class="comment">// 填充后续字节</span></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[SpeedLoop] Sent RPM: &quot;</span>);</span><br><span class="line">      SerialBT.println(clamped_rpm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 开环模式：不主动发送数据（或发送特定指令）</span></span><br><span class="line"><span class="comment">// 此处根据需求可填充开环控制参数</span></span><br><span class="line">      <span class="built_in">memset</span>(data_frame, <span class="number">0x00</span>, <span class="number">9</span>);</span><br><span class="line">      SerialBT.println(<span class="string">&quot;[OpenLoop] No Data Sent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123; <span class="comment">// 速度环模式发送</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(crc);</span><br><span class="line">    &#125;</span><br><span class="line">    last_send = millis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> recv_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    recv_buffer[recv_index++] = Serial2.read();</span><br><span class="line"><span class="comment">// 完整帧处理</span></span><br><span class="line">    <span class="keyword">if</span> (recv_index == <span class="number">10</span>)</span><br><span class="line">    &#123;<span class="comment">// CRC校验</span></span><br><span class="line">      <span class="type">bool</span> crc_ok = (crc8_maxim(recv_buffer, <span class="number">9</span>) == recv_buffer[<span class="number">9</span>]);</span><br><span class="line"><span class="comment">// 速度数据解析（仅在速度环模式处理）</span></span><br><span class="line">      <span class="keyword">if</span> (crc_ok &amp;&amp; current_mode == SPEED_LOOP &amp;&amp;</span><br><span class="line">          recv_buffer[<span class="number">0</span>] == <span class="number">0x01</span> &amp;&amp; recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">        actual_rpm = raw_value / <span class="number">10</span>;</span><br><span class="line">        data_valid = <span class="literal">true</span>;</span><br><span class="line">        SerialBT.print(<span class="string">&quot;[RECV] Actual RPM: &quot;</span>);</span><br><span class="line">        SerialBT.println(actual_rpm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!crc_ok)</span><br><span class="line">      &#123;</span><br><span class="line">        data_valid = <span class="literal">false</span>;</span><br><span class="line">        SerialBT.println(<span class="string">&quot;[ERROR] CRC Check Failed!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      recv_index = <span class="number">0</span>; <span class="comment">// 重置接收</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 蓝牙指令处理 -----------------</span></span><br><span class="line">  <span class="keyword">while</span> (SerialBT.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> cmd = SerialBT.read();</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">toupper</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">// 切换速度环模式</span></span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      Serial2.write(speed_loop_frame, <span class="keyword">sizeof</span>(speed_loop_frame));</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode switched to SpeedLoop&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 切换开环模式</span></span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial2.write(open_loop_frame, <span class="keyword">sizeof</span>(open_loop_frame));</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode switched to OpenLoop&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      SerialBT.print(<span class="string">&quot;Unknown command: &quot;</span>);</span><br><span class="line">      SerialBT.println(cmd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="上电默认开环">上电默认开环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 预定义协议帧 =================</span></span><br><span class="line"><span class="comment">// 上电反馈数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> POWER_ON_ACK[<span class="number">3</span>] = &#123;<span class="number">0xAA</span>, <span class="number">0x55</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开环指令帧：01 A0 00 00 00 00 00 00 00 9E</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> open_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 速度环指令帧：01 A0 02 00 00 00 00 00 00 E4</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> speed_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 控制模式定义 =================</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ControlMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SPEED_LOOP, <span class="comment">// 速度环模式</span></span><br><span class="line">  OPEN_LOOP   <span class="comment">// 开环模式</span></span><br><span class="line">&#125;;</span><br><span class="line">ControlMode current_mode = OPEN_LOOP; <span class="comment">// 初始模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">30</span>; <span class="comment">// 目标转速（速度环模式有效）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;               <span class="comment">// 实际转速</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>];    <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bt_recv_buffer[<span class="number">10</span>]; <span class="comment">// 蓝牙接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;          <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= CRC函数 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; <span class="number">0x01</span>) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);      <span class="comment">// USB调试</span></span><br><span class="line">  Serial2.begin(<span class="number">115200</span>);     <span class="comment">// 主串口（全双工）</span></span><br><span class="line">  SerialBT.begin(<span class="string">&quot;BAKUMAN&quot;</span>); <span class="comment">// 蓝牙名称</span></span><br><span class="line">  delay(<span class="number">5000</span>);               <span class="comment">// 因为我人手不能同时给电机和单片机上电以及连接蓝牙，所以此处有一个延时</span></span><br><span class="line">  <span class="comment">// 等待电机上电反馈</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start = millis();</span><br><span class="line">  <span class="type">bool</span> ack_received = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  SerialBT.println(<span class="string">&quot;Waiting for motor initialization...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// while (!ack_received &amp;&amp; (millis() - start &lt; 5000))</span></span><br><span class="line">  <span class="comment">// &#123; // 5秒超时</span></span><br><span class="line">  <span class="comment">//   if (Serial2.available() &gt;= sizeof(POWER_ON_ACK))</span></span><br><span class="line">  <span class="comment">//   &#123;</span></span><br><span class="line">  <span class="comment">//     uint8_t tmp[3];</span></span><br><span class="line">  <span class="comment">//     Serial2.readBytes(tmp, 3);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//     if (memcmp(tmp, POWER_ON_ACK, 3) == 0)</span></span><br><span class="line">  <span class="comment">//     &#123;</span></span><br><span class="line">  <span class="comment">//       ack_received = true;</span></span><br><span class="line">  <span class="comment">//       SerialBT.println(&quot;Motor Ready!&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//       // 发送电流环指令</span></span><br><span class="line">  <span class="comment">//       Serial2.write(open_loop_frame, 10);</span></span><br><span class="line">  <span class="comment">//       delay(50);</span></span><br><span class="line">  <span class="comment">//       Serial2.flush(); // 清空缓冲区</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  Serial2.write(open_loop_frame, <span class="number">10</span>);</span><br><span class="line">  delay(<span class="number">50</span>);</span><br><span class="line">  Serial2.flush(); <span class="comment">// 清空缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">1000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;                                 <span class="comment">// 每秒发送一次</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据模式构造数据帧</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 速度环模式：发送转速指令</span></span><br><span class="line">      <span class="type">int</span> clamped_rpm = constrain(target_rpm, <span class="number">-150</span>, <span class="number">150</span>); <span class="comment">// 进行速度限幅</span></span><br><span class="line">      <span class="type">int16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line">      data_frame[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line">      data_frame[<span class="number">2</span>] = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">      data_frame[<span class="number">3</span>] = speed_value &amp; <span class="number">0xFF</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>); <span class="comment">// 填充后续字节</span></span><br><span class="line"></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[SpeedLoop] Sent RPM: &quot;</span>);</span><br><span class="line">      SerialBT.println(clamped_rpm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 开环模式：不主动发送数据（或发送特定指令）</span></span><br><span class="line">      <span class="comment">// 此处根据需求可填充开环控制参数</span></span><br><span class="line">      <span class="built_in">memset</span>(data_frame, <span class="number">0x00</span>, <span class="number">9</span>);</span><br><span class="line">      SerialBT.println(<span class="string">&quot;[OpenLoop] No Data Sent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123; <span class="comment">// 速度环模式发送</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(crc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_send = millis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> recv_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    recv_buffer[recv_index++] = Serial2.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完整帧处理</span></span><br><span class="line">    <span class="keyword">if</span> (recv_index == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// CRC校验</span></span><br><span class="line">      <span class="type">bool</span> crc_ok = (crc8_maxim(recv_buffer, <span class="number">9</span>) == recv_buffer[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 速度数据解析（仅在速度环模式处理）</span></span><br><span class="line">      <span class="keyword">if</span> (crc_ok &amp;&amp; current_mode == SPEED_LOOP &amp;&amp;</span><br><span class="line">          recv_buffer[<span class="number">0</span>] == <span class="number">0x01</span> &amp;&amp; recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">        actual_rpm = raw_value / <span class="number">10</span>;</span><br><span class="line">        data_valid = <span class="literal">true</span>;</span><br><span class="line">        SerialBT.print(<span class="string">&quot;[RECV] Actual RPM: &quot;</span>);</span><br><span class="line">        SerialBT.println(actual_rpm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!crc_ok)</span><br><span class="line">      &#123;</span><br><span class="line">        data_valid = <span class="literal">false</span>;</span><br><span class="line">        SerialBT.println(<span class="string">&quot;[ERROR] CRC Check Failed!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      recv_index = <span class="number">0</span>; <span class="comment">// 重置接收</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 蓝牙指令处理 -----------------</span></span><br><span class="line">  <span class="keyword">while</span> (SerialBT.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> cmd = SerialBT.read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">toupper</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">// 切换速度环模式</span></span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      Serial2.write(speed_loop_frame, <span class="keyword">sizeof</span>(speed_loop_frame));</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode switched to SpeedLoop&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 切换开环模式</span></span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial2.write(open_loop_frame, <span class="keyword">sizeof</span>(open_loop_frame));</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode switched to OpenLoop&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      SerialBT.print(<span class="string">&quot;Unknown command: &quot;</span>);</span><br><span class="line">      SerialBT.println(cmd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阶段完成">250307阶段完成</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 预定义协议帧 =================</span></span><br><span class="line"><span class="comment">// 电机ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上电反馈数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> POWER_ON_ACK[<span class="number">3</span>] = &#123;<span class="number">0xAA</span>, <span class="number">0x55</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开环指令帧：ID A0 00 00 00 00 00 00 00 9E</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> open_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 速度环指令帧：ID A0 02 00 00 00 00 00 00 E4</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> speed_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减速指令帧：01 64 00 00 00 00 00 00 00 50</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> stop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 控制模式定义 =================</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ControlMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SPEED_LOOP, <span class="comment">// 速度环模式</span></span><br><span class="line">  OPEN_LOOP   <span class="comment">// 开环模式</span></span><br><span class="line">&#125;;</span><br><span class="line">ControlMode current_mode = OPEN_LOOP; <span class="comment">// 初始模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">-100</span>;         <span class="comment">// 目标转速（速度环模式有效）</span></span><br><span class="line"><span class="type">int</span> open_loop_current = <span class="number">10000</span>; <span class="comment">// 开环电流值（范围：-32767 ~ 32767）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;               <span class="comment">// 实际转速</span></span><br><span class="line"><span class="type">int</span> actual_current = <span class="number">0</span>;           <span class="comment">// 实际电流</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>];    <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bt_recv_buffer[<span class="number">10</span>]; <span class="comment">// 蓝牙接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;          <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= CRC函数 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; ID) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);  <span class="comment">// USB调试</span></span><br><span class="line">  Serial2.begin(<span class="number">115200</span>); <span class="comment">// 主串口（全双工）</span></span><br><span class="line">  SerialBT.begin();      <span class="comment">// 蓝牙名称</span></span><br><span class="line">  delay(<span class="number">1000</span>);           <span class="comment">// 因为我人手不能同时给电机和单片机上电以及连接蓝牙，所以此处有一个延时</span></span><br><span class="line">  <span class="comment">//   等待电机上电反馈</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start = millis();</span><br><span class="line">  <span class="type">bool</span> ack_received = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SerialBT.println(&quot;Waiting for motor initialization...&quot;);</span></span><br><span class="line">  <span class="comment">//  清空接收缓冲区</span></span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 读取并丢弃缓冲区中的字符</span></span><br><span class="line">    Serial2.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// while (!ack_received &amp;&amp; (millis() - start &lt; 5000))</span></span><br><span class="line">  <span class="comment">// &#123; // 5秒超时</span></span><br><span class="line">  <span class="comment">//   if (Serial2.available() &gt;= sizeof(POWER_ON_ACK))</span></span><br><span class="line">  <span class="comment">//   &#123;</span></span><br><span class="line">  <span class="comment">//     uint8_t tmp[3];</span></span><br><span class="line">  <span class="comment">//     Serial2.readBytes(tmp, 3);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//     if (memcmp(tmp, POWER_ON_ACK, 3) == 0)</span></span><br><span class="line">  <span class="comment">//     &#123;</span></span><br><span class="line">  <span class="comment">//       ack_received = true;</span></span><br><span class="line">  <span class="comment">//       SerialBT.println(&quot;Motor Ready!&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//       // 发送电流环指令</span></span><br><span class="line">  <span class="comment">//       Serial2.write(open_loop_frame, 10);</span></span><br><span class="line">  <span class="comment">//       delay(50);</span></span><br><span class="line">  <span class="comment">//       Serial2.flush(); // 清空缓冲区</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  Serial2.write(open_loop_frame, <span class="number">10</span>);</span><br><span class="line">  delay(<span class="number">50</span>);</span><br><span class="line">  Serial2.flush(); <span class="comment">// 清空缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">2000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;                                 <span class="comment">// 每秒发送一次</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据模式构造数据帧</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 速度环模式：发送转速指令</span></span><br><span class="line">      <span class="type">int</span> clamped_rpm = constrain(target_rpm, <span class="number">-150</span>, <span class="number">150</span>); <span class="comment">// 进行速度限幅</span></span><br><span class="line">      <span class="type">uint16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line">      data_frame[<span class="number">0</span>] = ID;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line">      data_frame[<span class="number">2</span>] = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">      data_frame[<span class="number">3</span>] = speed_value &amp; <span class="number">0xFF</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>); <span class="comment">// 填充后续字节</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 速度环模式发送</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(crc);</span><br><span class="line"></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[SpeedLoop] Sent RPM: &quot;</span>);</span><br><span class="line">      SerialBT.println(clamped_rpm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current_mode == OPEN_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 构造开环指令帧：ID 64 [电流值高8位] [电流值低8位] 00 00 00 00 00 [CRC]</span></span><br><span class="line">      data_frame[<span class="number">0</span>] = ID;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将电流值转为大端字节序</span></span><br><span class="line">      <span class="type">int16_t</span> current_raw = constrain(open_loop_current, <span class="number">-32767</span>, <span class="number">32767</span>); <span class="comment">// 进行限幅</span></span><br><span class="line">      <span class="type">uint16_t</span> unsigned_current = (<span class="type">uint16_t</span>)current_raw;                 <span class="comment">// 转为无符号类型</span></span><br><span class="line">      data_frame[<span class="number">2</span>] = (unsigned_current &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;                    <span class="comment">// 高字节</span></span><br><span class="line">      data_frame[<span class="number">3</span>] = unsigned_current &amp; <span class="number">0xFF</span>;                           <span class="comment">// 低字节</span></span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>);                                   <span class="comment">// 后续5字节填充0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算CRC（前9字节）</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(crc);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[OpenLoop] Current: &quot;</span>);</span><br><span class="line">      SerialBT.print(current_raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> recv_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      recv_buffer[recv_index++] = Serial2.read();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完整帧处理</span></span><br><span class="line">      <span class="keyword">if</span> (recv_index == <span class="number">10</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// CRC校验</span></span><br><span class="line">        <span class="type">bool</span> crc_ok = (crc8_maxim(recv_buffer, <span class="number">9</span>) == recv_buffer[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 速度数据解析（仅在速度环模式处理）</span></span><br><span class="line">        <span class="keyword">if</span> (crc_ok &amp;&amp; current_mode == SPEED_LOOP &amp;&amp;</span><br><span class="line">            recv_buffer[<span class="number">0</span>] == ID &amp;&amp; recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">          actual_rpm = raw_value / <span class="number">10</span>;</span><br><span class="line">          data_valid = <span class="literal">true</span>;</span><br><span class="line">          SerialBT.print(<span class="string">&quot;[RECV] Actual RPM: &quot;</span>);</span><br><span class="line">          SerialBT.println(actual_rpm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开环速度接收</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (crc_ok &amp;&amp; current_mode == OPEN_LOOP &amp;&amp; recv_buffer[<span class="number">0</span>] == ID &amp;&amp; recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">          actual_rpm = raw_value / <span class="number">10</span>;</span><br><span class="line">          data_valid = <span class="literal">true</span>;</span><br><span class="line">          SerialBT.print(<span class="string">&quot;[RECV] Actual RPM: &quot;</span>);</span><br><span class="line">          SerialBT.println(actual_rpm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!crc_ok)</span><br><span class="line">        &#123;</span><br><span class="line">          data_valid = <span class="literal">false</span>;</span><br><span class="line">          SerialBT.println(<span class="string">&quot;[ERROR] CRC Check Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recv_index = <span class="number">0</span>; <span class="comment">// 重置接收</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1</span>);</span><br><span class="line">    last_send = millis();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ----------------- 蓝牙指令处理 -----------------</span></span><br><span class="line">  <span class="keyword">while</span> (SerialBT.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> cmd = SerialBT.read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">toupper</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">// 切换速度环模式</span></span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      Serial2.write(stop_frame, <span class="keyword">sizeof</span>(stop_frame));</span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      Serial2.write(speed_loop_frame, <span class="keyword">sizeof</span>(speed_loop_frame));</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode switched to SpeedLoop&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 切换开环模式</span></span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial2.write(stop_frame, <span class="keyword">sizeof</span>(stop_frame)); <span class="comment">// 减速保护电机</span></span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      Serial2.write(open_loop_frame, <span class="keyword">sizeof</span>(open_loop_frame));</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode switched to OpenLoop&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      SerialBT.print(<span class="string">&quot;Unknown command: &quot;</span>);</span><br><span class="line">      SerialBT.println(cmd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶段二">阶段二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 UART1 的自定义引脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART1_TX_PIN 25 <span class="comment">// 自定义 TX 引脚（GPIO25）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART1_RX_PIN 26 <span class="comment">// 自定义 RX 引脚（GPIO26）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 预定义协议帧 =================</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> // 定义一个结构体接收反馈数据</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> id;          <span class="comment">// 设备ID (0x01)</span></span><br><span class="line">  <span class="type">uint8_t</span> cmd;         <span class="comment">// 指令类型 (0x64)</span></span><br><span class="line">  <span class="type">int16_t</span> param;       <span class="comment">// 参数（速度或电流）</span></span><br><span class="line">  <span class="type">uint8_t</span> reserved[<span class="number">5</span>]; <span class="comment">// 保留字节</span></span><br><span class="line">  <span class="type">uint8_t</span> crc;         <span class="comment">// CRC校验码</span></span><br><span class="line">&#125; MotorFrame;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电机ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上电反馈数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> POWER_ON_ACK[<span class="number">3</span>] = &#123;<span class="number">0xAA</span>, <span class="number">0x55</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开环指令帧：ID A0 00 00 00 00 00 00 00 9E</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> open_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 速度环指令帧：ID A0 02 00 00 00 00 00 00 E4</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> speed_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减速指令帧：01 64 00 00 00 00 00 00 00 50</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> stop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 控制模式定义 =================</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ControlMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SPEED_LOOP, <span class="comment">// 速度环模式</span></span><br><span class="line">  OPEN_LOOP   <span class="comment">// 开环模式</span></span><br><span class="line">&#125;;</span><br><span class="line">ControlMode current_mode = OPEN_LOOP; <span class="comment">// 初始模式</span></span><br><span class="line"></span><br><span class="line">MotorFrame tx_frame = &#123;</span><br><span class="line">    .id = <span class="number">0x01</span>,</span><br><span class="line">    .cmd = <span class="number">0x64</span>,</span><br><span class="line">    .param = <span class="number">0</span>,</span><br><span class="line">    .reserved = &#123;<span class="number">0</span>&#125;,</span><br><span class="line">    .crc = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">-100</span>;         <span class="comment">// 目标转速（速度环模式有效）</span></span><br><span class="line"><span class="type">int</span> open_loop_current = <span class="number">10000</span>; <span class="comment">// 开环电流值（范围：-32767 ~ 32767）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;               <span class="comment">// 实际转速</span></span><br><span class="line"><span class="type">int</span> actual_current = <span class="number">0</span>;           <span class="comment">// 实际电流</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>];    <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bt_recv_buffer[<span class="number">10</span>]; <span class="comment">// 蓝牙接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;          <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> sync_state = <span class="number">0</span>;           <span class="comment">// 同步状态机</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> last_rx = <span class="number">0</span>;        <span class="comment">// 最后接收时间戳</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> RX_TIMEOUT = <span class="number">2000</span>; <span class="comment">// 接收超时(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 函数声明 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_Serial1_data</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">verify_frame</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_bluetooth</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendModeQuery</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 直接使用预定义的 Serial1，无需重新声明</span></span><br><span class="line">  Serial1.begin(<span class="number">115200</span>, SERIAL_8N1, UART1_RX_PIN, UART1_TX_PIN);</span><br><span class="line">  SerialBT.begin(); <span class="comment">// 蓝牙名称</span></span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空软件串口接收缓冲区</span></span><br><span class="line">  <span class="keyword">while</span> (Serial1.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Serial1.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial1.write(open_loop_frame, <span class="number">10</span>); <span class="comment">// 发送开环指令</span></span><br><span class="line">  delay(<span class="number">50</span>);</span><br><span class="line">  Serial1.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_query = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> query_interval = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">1000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;                                 <span class="comment">// 每秒发送一次</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据模式构造数据帧</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 速度环模式：发送转速指令</span></span><br><span class="line">      <span class="type">int</span> clamped_rpm = constrain(target_rpm, <span class="number">-150</span>, <span class="number">150</span>); <span class="comment">// 进行速度限幅</span></span><br><span class="line">      <span class="type">uint16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line">      data_frame[<span class="number">0</span>] = ID;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line">      data_frame[<span class="number">2</span>] = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">      data_frame[<span class="number">3</span>] = speed_value &amp; <span class="number">0xFF</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>); <span class="comment">// 填充后续字节</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 速度环模式发送</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial1.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial1.write(crc);</span><br><span class="line"></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[SpeedLoop] Sent RPM: &quot;</span>);</span><br><span class="line">      SerialBT.println(clamped_rpm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current_mode == OPEN_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 构造开环指令帧：ID 64 [电流值高8位] [电流值低8位] 00 00 00 00 00 [CRC]</span></span><br><span class="line">      data_frame[<span class="number">0</span>] = ID;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将电流值转为大端字节序</span></span><br><span class="line">      <span class="type">int16_t</span> current_raw = constrain(open_loop_current, <span class="number">-32767</span>, <span class="number">32767</span>); <span class="comment">// 进行限幅</span></span><br><span class="line">      <span class="type">uint16_t</span> unsigned_current = (<span class="type">uint16_t</span>)current_raw;                 <span class="comment">// 转为无符号类型</span></span><br><span class="line">      data_frame[<span class="number">2</span>] = (unsigned_current &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;                    <span class="comment">// 高字节</span></span><br><span class="line">      data_frame[<span class="number">3</span>] = unsigned_current &amp; <span class="number">0xFF</span>;                           <span class="comment">// 低字节</span></span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>);                                   <span class="comment">// 后续5字节填充0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算CRC（前9字节）</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial1.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial1.write(crc);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[OpenLoop] Current: &quot;</span>);</span><br><span class="line">      SerialBT.print(current_raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1</span>);</span><br><span class="line">    sendModeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line">    <span class="keyword">if</span> (Serial1.available())</span><br><span class="line">    &#123;</span><br><span class="line">      process_Serial1_data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_send = millis();</span><br><span class="line"></span><br><span class="line">    process_bluetooth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; ID) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // ================= 数据接收状态机 =================</span></span><br><span class="line"><span class="comment">// void process_Serial1_data()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   while (Serial1.available())</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     uint8_t c = Serial1.read();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 状态机处理</span></span><br><span class="line"><span class="comment">//     switch (sync_state)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//     case 0: // 寻找0x01</span></span><br><span class="line"><span class="comment">//       if (c == 0x01)</span></span><br><span class="line"><span class="comment">//         sync_state = 1;</span></span><br><span class="line"><span class="comment">//       break;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     case 1: // 检查后续是否为0x64</span></span><br><span class="line"><span class="comment">//       if (c == 0x64)</span></span><br><span class="line"><span class="comment">//       &#123;</span></span><br><span class="line"><span class="comment">//         recv_buffer[0] = 0x01;</span></span><br><span class="line"><span class="comment">//         recv_buffer[1] = 0x64;</span></span><br><span class="line"><span class="comment">//         sync_state = 2;</span></span><br><span class="line"><span class="comment">//         last_rx = millis();</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       else</span></span><br><span class="line"><span class="comment">//       &#123;</span></span><br><span class="line"><span class="comment">//         sync_state = 0; // 同步失败,重新开始</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       break;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     case 2: // 接收剩余数据</span></span><br><span class="line"><span class="comment">//       static uint8_t idx = 2;</span></span><br><span class="line"><span class="comment">//       recv_buffer[idx++] = c;</span></span><br><span class="line"><span class="comment">//       last_rx = millis();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       // 检查是否收满</span></span><br><span class="line"><span class="comment">//       if (idx &gt;= 9)</span></span><br><span class="line"><span class="comment">//       &#123;</span></span><br><span class="line"><span class="comment">//         verify_frame();</span></span><br><span class="line"><span class="comment">//         idx = 0;</span></span><br><span class="line"><span class="comment">//         sync_state = 0;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       break;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 超时重置</span></span><br><span class="line"><span class="comment">//     if ((sync_state == 2) &amp;&amp; (millis() - last_rx &gt; RX_TIMEOUT))</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       sync_state = 0;</span></span><br><span class="line"><span class="comment">//       memset(recv_buffer, 0, sizeof(recv_buffer));</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // ================= 帧验证 =================</span></span><br><span class="line"><span class="comment">// void verify_frame()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   MotorFrame *frame = (MotorFrame *)recv_buffer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   // CRC校验</span></span><br><span class="line"><span class="comment">//   if (crc8_maxim(recv_buffer, 9) != frame-&gt;crc)</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     SerialBT.println(&quot;[ERROR] CRC mismatch&quot;);</span></span><br><span class="line"><span class="comment">//     return;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   // 数据解析</span></span><br><span class="line"><span class="comment">//   if (frame-&gt;cmd == 0x64)</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     int16_t raw_value = frame-&gt;param;</span></span><br><span class="line"><span class="comment">//     actual_rpm = raw_value / 10;</span></span><br><span class="line"><span class="comment">//     SerialBT.print(&quot;RPM: &quot;);</span></span><br><span class="line"><span class="comment">//     SerialBT.println(actual_rpm);</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendModeQuery</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> query_frame[<span class="number">10</span>] = &#123;ID, <span class="number">0x75</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">  query_frame[<span class="number">9</span>] = crc8_maxim(query_frame, <span class="number">9</span>);</span><br><span class="line">  Serial1.write(query_frame, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 改进的状态机接收 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_Serial1_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> idx = <span class="number">0</span>;      <span class="comment">// 统一索引管理</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> last_rx = <span class="number">0</span>; <span class="comment">// 最后接收时间戳</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Serial1.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span> c = Serial1.read(); <span class="comment">// 串口1的接收数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sync_state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 同步头第一阶段</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0x01</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        recv_buffer[<span class="number">0</span>] = c;</span><br><span class="line">        sync_state = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 同步头第二阶段</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0x64</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        recv_buffer[<span class="number">1</span>] = c;</span><br><span class="line">        idx = <span class="number">2</span>; <span class="comment">// 重置索引</span></span><br><span class="line">        sync_state = <span class="number">2</span>;</span><br><span class="line">        last_rx = millis();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        sync_state = <span class="number">0</span>; <span class="comment">// 同步失败</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 数据接收阶段</span></span><br><span class="line">      <span class="keyword">if</span> (idx &lt; <span class="keyword">sizeof</span>(recv_buffer))</span><br><span class="line">      &#123;</span><br><span class="line">        recv_buffer[idx++] = c;</span><br><span class="line">        last_rx = millis();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完整帧接收完成</span></span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="keyword">sizeof</span>(recv_buffer))</span><br><span class="line">      &#123;</span><br><span class="line">        verify_frame();</span><br><span class="line">        sync_state = <span class="number">0</span>; <span class="comment">// 重置状态机</span></span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时处理（2秒无数据）</span></span><br><span class="line">    <span class="keyword">if</span> (sync_state == <span class="number">2</span> &amp;&amp; (millis() - last_rx) &gt; RX_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">      SerialBT.println(<span class="string">&quot;[ERROR] Reception timeout&quot;</span>);</span><br><span class="line">      sync_state = <span class="number">0</span>;</span><br><span class="line">      idx = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(recv_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 增强的帧验证 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">verify_frame</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">// 做开环检测</span></span><br><span class="line">  <span class="comment">// CRC校验（前9字节）</span></span><br><span class="line">  <span class="type">uint8_t</span> calculated_crc = crc8_maxim(recv_buffer, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">if</span> (calculated_crc != recv_buffer[<span class="number">9</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;[ERROR] CRC Mismatch: 0x%02X vs 0x%02X\n&quot;</span>, calculated_crc, recv_buffer[<span class="number">9</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (recv_buffer[<span class="number">1</span>] == <span class="number">0x75</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span> mode = recv_buffer[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode: Open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">0x02</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode: Speed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 速度值解析</span></span><br><span class="line">    <span class="comment">//  协议解析（大端字节序处理）</span></span><br><span class="line">    <span class="keyword">if</span> (recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">    &#123; <span class="comment">// 速度环反馈</span></span><br><span class="line">      <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">      actual_rpm = raw_value / <span class="number">10</span>; <span class="comment">// 实际转速</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 电流值解析</span></span><br><span class="line">      <span class="type">int16_t</span> current = (recv_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">      SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;RPM: %d\tCurrent: %dmA\n&quot;</span>, actual_rpm, current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;[WARN] Unsupported command: 0x%02X\n&quot;</span>, recv_buffer[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_bluetooth</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ----------------- 蓝牙指令处理 -----------------</span></span><br><span class="line">  <span class="comment">// ...（原有蓝牙逻辑保持不变，但需修改模式切换时的串口操作）...</span></span><br><span class="line">  <span class="keyword">while</span> (SerialBT.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> cmd = SerialBT.read();</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">toupper</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      Serial1.write(stop_frame, <span class="keyword">sizeof</span>(stop_frame)); <span class="comment">// 替换为 Serial1</span></span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      Serial1.write(speed_loop_frame, <span class="keyword">sizeof</span>(speed_loop_frame)); <span class="comment">// 替换</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial1.write(stop_frame, <span class="keyword">sizeof</span>(stop_frame)); <span class="comment">// 替换</span></span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      Serial1.write(open_loop_frame, <span class="keyword">sizeof</span>(open_loop_frame)); <span class="comment">// 替换</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单电机的最后一版">单电机的最后一版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 预定义协议帧 =================</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> // 定义一个结构体接收反馈数据</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> id;          <span class="comment">// 设备ID (0x01)</span></span><br><span class="line">  <span class="type">uint8_t</span> cmd;         <span class="comment">// 指令类型 (0x64)</span></span><br><span class="line">  <span class="type">int16_t</span> param;       <span class="comment">// 参数（速度或电流）</span></span><br><span class="line">  <span class="type">uint8_t</span> reserved[<span class="number">5</span>]; <span class="comment">// 保留字节</span></span><br><span class="line">  <span class="type">uint8_t</span> crc;         <span class="comment">// CRC校验码</span></span><br><span class="line">&#125; MotorFrame;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电机ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上电反馈数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> POWER_ON_ACK[<span class="number">3</span>] = &#123;<span class="number">0xAA</span>, <span class="number">0x55</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开环指令帧：ID A0 00 00 00 00 00 00 00 9E</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> open_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9E</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 速度环指令帧：ID A0 02 00 00 00 00 00 00 E4</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> speed_loop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减速指令帧：01 64 00 00 00 00 00 00 00 50</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> stop_frame[<span class="number">10</span>] = &#123;</span><br><span class="line">    ID, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 控制模式定义 =================</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ControlMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SPEED_LOOP, <span class="comment">// 速度环模式</span></span><br><span class="line">  OPEN_LOOP   <span class="comment">// 开环模式</span></span><br><span class="line">&#125;;</span><br><span class="line">ControlMode current_mode = OPEN_LOOP; <span class="comment">// 初始模式</span></span><br><span class="line"></span><br><span class="line">MotorFrame tx_frame = &#123;</span><br><span class="line">    .id = <span class="number">0x01</span>,</span><br><span class="line">    .cmd = <span class="number">0x64</span>,</span><br><span class="line">    .param = <span class="number">0</span>,</span><br><span class="line">    .reserved = &#123;<span class="number">0</span>&#125;,</span><br><span class="line">    .crc = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 发送端配置 =================</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">-100</span>;         <span class="comment">// 目标转速（速度环模式有效）</span></span><br><span class="line"><span class="type">int</span> open_loop_current = <span class="number">10000</span>; <span class="comment">// 开环电流值（范围：-32767 ~ 32767）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 接收端配置 =================</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;               <span class="comment">// 实际转速</span></span><br><span class="line"><span class="type">int</span> actual_current = <span class="number">0</span>;           <span class="comment">// 实际电流</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">10</span>];    <span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bt_recv_buffer[<span class="number">10</span>]; <span class="comment">// 蓝牙接收缓冲区</span></span><br><span class="line"><span class="type">bool</span> data_valid = <span class="literal">false</span>;          <span class="comment">// 数据有效性标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> sync_state = <span class="number">0</span>;           <span class="comment">// 同步状态机</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> last_rx = <span class="number">0</span>;        <span class="comment">// 最后接收时间戳</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> RX_TIMEOUT = <span class="number">2000</span>; <span class="comment">// 接收超时(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 函数声明 =================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_Serial2_data</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">verify_frame</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_bluetooth</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sendModeQuery</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// ================= 初始化 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 直接使用预定义的 Serial2，无需重新声明</span></span><br><span class="line">  Serial2.begin(<span class="number">115200</span>);</span><br><span class="line">  SerialBT.begin(); <span class="comment">// 蓝牙名称</span></span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空软件串口接收缓冲区</span></span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Serial2.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial2.write(open_loop_frame, <span class="number">10</span>); <span class="comment">// 发送开环指令</span></span><br><span class="line">  delay(<span class="number">50</span>);</span><br><span class="line">  Serial2.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 主循环 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------- 发送逻辑 -----------------</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_send = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> last_query = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> query_interval = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis() - last_send &gt;= <span class="number">1000</span>) <span class="comment">// millis()返回的是从 Arduino 开发板开始运行当前程序起，经过的毫秒数。</span></span><br><span class="line">  &#123;                                 <span class="comment">// 每秒发送一次</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data_frame[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据模式构造数据帧</span></span><br><span class="line">    <span class="keyword">if</span> (current_mode == SPEED_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 速度环模式：发送转速指令</span></span><br><span class="line">      <span class="type">int</span> clamped_rpm = constrain(target_rpm, <span class="number">-150</span>, <span class="number">150</span>); <span class="comment">// 进行速度限幅</span></span><br><span class="line">      <span class="type">uint16_t</span> speed_value = clamped_rpm * <span class="number">10</span>;</span><br><span class="line">      data_frame[<span class="number">0</span>] = ID;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line">      data_frame[<span class="number">2</span>] = (speed_value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">      data_frame[<span class="number">3</span>] = speed_value &amp; <span class="number">0xFF</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>); <span class="comment">// 填充后续字节</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 速度环模式发送</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(crc);</span><br><span class="line"></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[SpeedLoop] Sent RPM: &quot;</span>);</span><br><span class="line">      SerialBT.println(clamped_rpm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current_mode == OPEN_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 构造开环指令帧：ID 64 [电流值高8位] [电流值低8位] 00 00 00 00 00 [CRC]</span></span><br><span class="line">      data_frame[<span class="number">0</span>] = ID;</span><br><span class="line">      data_frame[<span class="number">1</span>] = <span class="number">0x64</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将电流值转为大端字节序</span></span><br><span class="line">      <span class="type">int16_t</span> current_raw = constrain(open_loop_current, <span class="number">-32767</span>, <span class="number">32767</span>); <span class="comment">// 进行限幅</span></span><br><span class="line">      <span class="type">uint16_t</span> unsigned_current = (<span class="type">uint16_t</span>)current_raw;                 <span class="comment">// 转为无符号类型</span></span><br><span class="line">      data_frame[<span class="number">2</span>] = (unsigned_current &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;                    <span class="comment">// 高字节</span></span><br><span class="line">      data_frame[<span class="number">3</span>] = unsigned_current &amp; <span class="number">0xFF</span>;                           <span class="comment">// 低字节</span></span><br><span class="line">      <span class="built_in">memset</span>(&amp;data_frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>);                                   <span class="comment">// 后续5字节填充0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算CRC（前9字节）</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> crc = crc8_maxim(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(data_frame, <span class="number">9</span>);</span><br><span class="line">      Serial2.write(crc);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">      SerialBT.print(<span class="string">&quot;[OpenLoop] Current: &quot;</span>);</span><br><span class="line">      SerialBT.print(current_raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1</span>);</span><br><span class="line">    sendModeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------- 接收逻辑 -----------------</span></span><br><span class="line">    <span class="keyword">if</span> (Serial2.available())</span><br><span class="line">    &#123;</span><br><span class="line">      process_Serial2_data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_send = millis();</span><br><span class="line"></span><br><span class="line">    process_bluetooth();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *ptr++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; ID) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // ================= 数据接收状态机 =================</span></span><br><span class="line"><span class="comment">// void process_Serial2_data()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   while (Serial2.available())</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     uint8_t c = Serial2.read();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 状态机处理</span></span><br><span class="line"><span class="comment">//     switch (sync_state)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//     case 0: // 寻找0x01</span></span><br><span class="line"><span class="comment">//       if (c == 0x01)</span></span><br><span class="line"><span class="comment">//         sync_state = 1;</span></span><br><span class="line"><span class="comment">//       break;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     case 1: // 检查后续是否为0x64</span></span><br><span class="line"><span class="comment">//       if (c == 0x64)</span></span><br><span class="line"><span class="comment">//       &#123;</span></span><br><span class="line"><span class="comment">//         recv_buffer[0] = 0x01;</span></span><br><span class="line"><span class="comment">//         recv_buffer[1] = 0x64;</span></span><br><span class="line"><span class="comment">//         sync_state = 2;</span></span><br><span class="line"><span class="comment">//         last_rx = millis();</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       else</span></span><br><span class="line"><span class="comment">//       &#123;</span></span><br><span class="line"><span class="comment">//         sync_state = 0; // 同步失败,重新开始</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       break;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     case 2: // 接收剩余数据</span></span><br><span class="line"><span class="comment">//       static uint8_t idx = 2;</span></span><br><span class="line"><span class="comment">//       recv_buffer[idx++] = c;</span></span><br><span class="line"><span class="comment">//       last_rx = millis();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       // 检查是否收满</span></span><br><span class="line"><span class="comment">//       if (idx &gt;= 9)</span></span><br><span class="line"><span class="comment">//       &#123;</span></span><br><span class="line"><span class="comment">//         verify_frame();</span></span><br><span class="line"><span class="comment">//         idx = 0;</span></span><br><span class="line"><span class="comment">//         sync_state = 0;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       break;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 超时重置</span></span><br><span class="line"><span class="comment">//     if ((sync_state == 2) &amp;&amp; (millis() - last_rx &gt; RX_TIMEOUT))</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       sync_state = 0;</span></span><br><span class="line"><span class="comment">//       memset(recv_buffer, 0, sizeof(recv_buffer));</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // ================= 帧验证 =================</span></span><br><span class="line"><span class="comment">// void verify_frame()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   MotorFrame *frame = (MotorFrame *)recv_buffer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   // CRC校验</span></span><br><span class="line"><span class="comment">//   if (crc8_maxim(recv_buffer, 9) != frame-&gt;crc)</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     SerialBT.println(&quot;[ERROR] CRC mismatch&quot;);</span></span><br><span class="line"><span class="comment">//     return;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   // 数据解析</span></span><br><span class="line"><span class="comment">//   if (frame-&gt;cmd == 0x64)</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     int16_t raw_value = frame-&gt;param;</span></span><br><span class="line"><span class="comment">//     actual_rpm = raw_value / 10;</span></span><br><span class="line"><span class="comment">//     SerialBT.print(&quot;RPM: &quot;);</span></span><br><span class="line"><span class="comment">//     SerialBT.println(actual_rpm);</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendModeQuery</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> query_frame[<span class="number">10</span>] = &#123;ID, <span class="number">0x75</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">  query_frame[<span class="number">9</span>] = crc8_maxim(query_frame, <span class="number">9</span>);</span><br><span class="line">  Serial2.write(query_frame, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 改进的状态机接收 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_Serial2_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> idx = <span class="number">0</span>;      <span class="comment">// 统一索引管理</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> last_rx = <span class="number">0</span>; <span class="comment">// 最后接收时间戳</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Serial2.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span> c = Serial2.read(); <span class="comment">// 串口1的接收数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sync_state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 同步头第一阶段</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0x01</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        recv_buffer[<span class="number">0</span>] = c;</span><br><span class="line">        sync_state = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 同步头第二阶段</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0x64</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        recv_buffer[<span class="number">1</span>] = c;</span><br><span class="line">        idx = <span class="number">2</span>; <span class="comment">// 重置索引</span></span><br><span class="line">        sync_state = <span class="number">2</span>;</span><br><span class="line">        last_rx = millis();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        sync_state = <span class="number">0</span>; <span class="comment">// 同步失败</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 数据接收阶段</span></span><br><span class="line">      <span class="keyword">if</span> (idx &lt; <span class="keyword">sizeof</span>(recv_buffer))</span><br><span class="line">      &#123;</span><br><span class="line">        recv_buffer[idx++] = c;</span><br><span class="line">        last_rx = millis();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完整帧接收完成</span></span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="keyword">sizeof</span>(recv_buffer))</span><br><span class="line">      &#123;</span><br><span class="line">        verify_frame();</span><br><span class="line">        sync_state = <span class="number">0</span>; <span class="comment">// 重置状态机</span></span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时处理（2秒无数据）</span></span><br><span class="line">    <span class="keyword">if</span> (sync_state == <span class="number">2</span> &amp;&amp; (millis() - last_rx) &gt; RX_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">      SerialBT.println(<span class="string">&quot;[ERROR] Reception timeout&quot;</span>);</span><br><span class="line">      sync_state = <span class="number">0</span>;</span><br><span class="line">      idx = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(recv_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 增强的帧验证 =================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">verify_frame</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">// 做开环检测</span></span><br><span class="line">  <span class="comment">// CRC校验（前9字节）</span></span><br><span class="line">  <span class="type">uint8_t</span> calculated_crc = crc8_maxim(recv_buffer, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">if</span> (calculated_crc != recv_buffer[<span class="number">9</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;[ERROR] CRC Mismatch: 0x%02X vs 0x%02X\n&quot;</span>, calculated_crc, recv_buffer[<span class="number">9</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (recv_buffer[<span class="number">1</span>] == <span class="number">0x75</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span> mode = recv_buffer[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode: Open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">0x02</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      SerialBT.println(<span class="string">&quot;Mode: Speed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 速度值解析</span></span><br><span class="line">    <span class="comment">//  协议解析（大端字节序处理）</span></span><br><span class="line">    <span class="keyword">if</span> (recv_buffer[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">    &#123; <span class="comment">// 速度环反馈</span></span><br><span class="line">      <span class="type">int16_t</span> raw_value = (recv_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">3</span>];</span><br><span class="line">      actual_rpm = raw_value / <span class="number">10</span>; <span class="comment">// 实际转速</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 电流值解析</span></span><br><span class="line">      <span class="type">int16_t</span> current = (recv_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | recv_buffer[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">      SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;RPM: %d\tCurrent: %dmA\n&quot;</span>, actual_rpm, current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;[WARN] Unsupported command: 0x%02X\n&quot;</span>, recv_buffer[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_bluetooth</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ----------------- 蓝牙指令处理 -----------------</span></span><br><span class="line">  <span class="comment">// ...（原有蓝牙逻辑保持不变，但需修改模式切换时的串口操作）...</span></span><br><span class="line">  <span class="keyword">while</span> (SerialBT.available() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> cmd = SerialBT.read();</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">toupper</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      Serial2.write(stop_frame, <span class="keyword">sizeof</span>(stop_frame)); <span class="comment">// 替换为 Serial2</span></span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      Serial2.write(speed_loop_frame, <span class="keyword">sizeof</span>(speed_loop_frame)); <span class="comment">// 替换</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial2.write(stop_frame, <span class="keyword">sizeof</span>(stop_frame)); <span class="comment">// 替换</span></span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      Serial2.write(open_loop_frame, <span class="keyword">sizeof</span>(open_loop_frame)); <span class="comment">// 替换</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整理完代码">整理完代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BluetoothSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BluetoothSerial SerialBT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               数据结构定义</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 电机反馈数据结构体</span></span><br><span class="line"><span class="comment"> * @note 使用紧凑内存布局，总长度10字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> id;          <span class="comment">// 设备ID (0x01)</span></span><br><span class="line">  <span class="type">uint8_t</span> cmd;         <span class="comment">// 指令类型 (0x64=速度环，0xA0=模式设置)</span></span><br><span class="line">  <span class="type">int16_t</span> param;       <span class="comment">// 参数（速度或电流）</span></span><br><span class="line">  <span class="type">uint8_t</span> reserved[<span class="number">5</span>]; <span class="comment">// 保留字节</span></span><br><span class="line">  <span class="type">uint8_t</span> crc;         <span class="comment">// CRC校验码</span></span><br><span class="line">&#125; MotorFrame;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               宏定义与常量</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ID 0x01           <span class="comment">// 本设备ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_TIMEOUT_MS 2000       <span class="comment">// 串口接收超时</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTROL_INTERVAL_MS 1000 <span class="comment">// 主控制周期</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义指令帧（完整帧含CRC）</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> FRAME_OPEN_LOOP[<span class="number">10</span>] = &#123;DEVICE_ID, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9E</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> FRAME_SPEED_LOOP[<span class="number">10</span>] = &#123;DEVICE_ID, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE4</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> FRAME_STOP[<span class="number">10</span>] = &#123;DEVICE_ID, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               全局变量声明</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ControlMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SPEED_LOOP,</span><br><span class="line">  OPEN_LOOP</span><br><span class="line">&#125;;</span><br><span class="line">ControlMode current_mode = OPEN_LOOP; <span class="comment">// 当前控制模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制参数</span></span><br><span class="line"><span class="type">int</span> target_rpm = <span class="number">-100</span>;         <span class="comment">// 速度环目标转速（-150~150）</span></span><br><span class="line"><span class="type">int</span> open_loop_current = <span class="number">10000</span>; <span class="comment">// 开环电流值（-32767~32767）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态参数</span></span><br><span class="line"><span class="type">int</span> actual_rpm = <span class="number">0</span>;     <span class="comment">// 实际转速（通过反馈更新）</span></span><br><span class="line"><span class="type">int</span> actual_current = <span class="number">0</span>; <span class="comment">// 实际电流（通过反馈更新）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               函数声明</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint8_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_control_frame</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_serial_data</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_bluetooth</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_frame</span><span class="params">(<span class="type">uint8_t</span> *frame)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update_system_status</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_mode_query</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               初始化配置</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial2.begin(<span class="number">115200</span>);       <span class="comment">// 电机通信串口</span></span><br><span class="line">  SerialBT.begin(<span class="string">&quot;MotorCtrl&quot;</span>); <span class="comment">// 蓝牙设备名称</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送初始模式设置</span></span><br><span class="line">  Serial2.write(FRAME_OPEN_LOOP, <span class="keyword">sizeof</span>(FRAME_OPEN_LOOP));</span><br><span class="line">  delay(<span class="number">50</span>);</span><br><span class="line">  Serial2.flush(); <span class="comment">// 等待发送完成</span></span><br><span class="line"></span><br><span class="line">  SerialBT.println(<span class="string">&quot;System Initialized&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               主循环程序</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> last_control = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时发送控制指令</span></span><br><span class="line">  <span class="keyword">if</span> (millis() - last_control &gt;= CONTROL_INTERVAL_MS)</span><br><span class="line">  &#123;</span><br><span class="line">    send_control_frame();</span><br><span class="line">    send_mode_query();</span><br><span class="line">    last_control = millis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理串口数据</span></span><br><span class="line">  <span class="keyword">if</span> (Serial2.available())</span><br><span class="line">  &#123;</span><br><span class="line">    process_serial_data();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理蓝牙指令</span></span><br><span class="line">  process_bluetooth();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* =============================================</span></span><br><span class="line"><span class="comment">               功能函数实现</span></span><br><span class="line"><span class="comment">============================================= */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算CRC8校验值（Maxim/Dallas算法）</span></span><br><span class="line"><span class="comment"> * @param data 数据指针</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> * @return 计算得到的CRC值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">crc8_maxim</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint8_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> crc = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">while</span> (len--)</span><br><span class="line">  &#123;</span><br><span class="line">    crc ^= *data++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      crc = (crc &amp; <span class="number">0x01</span>) ? (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span> : crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送控制帧（根据当前模式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_control_frame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> frame[<span class="number">10</span>] = &#123;DEVICE_ID, <span class="number">0x64</span>&#125;;</span><br><span class="line">  <span class="type">uint16_t</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (current_mode)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> SPEED_LOOP:</span><br><span class="line">    <span class="comment">// 构造速度环指令（大端序）</span></span><br><span class="line">    value = constrain(target_rpm, <span class="number">-150</span>, <span class="number">150</span>) * <span class="number">10</span>;</span><br><span class="line">    frame[<span class="number">2</span>] = (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    frame[<span class="number">3</span>] = value &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> OPEN_LOOP:</span><br><span class="line">    <span class="comment">// 构造开环指令（有符号转无符号）</span></span><br><span class="line">    value = (<span class="type">uint16_t</span>)constrain(open_loop_current, <span class="number">-32767</span>, <span class="number">32767</span>);</span><br><span class="line">    frame[<span class="number">2</span>] = (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    frame[<span class="number">3</span>] = value &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填充保留字节并计算CRC</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;frame[<span class="number">4</span>], <span class="number">0x00</span>, <span class="number">5</span>);</span><br><span class="line">  frame[<span class="number">9</span>] = crc8_maxim(frame, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  Serial2.write(frame, <span class="keyword">sizeof</span>(frame));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理串口接收数据（状态机实现）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_serial_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> sync_state = <span class="number">0</span>;    <span class="comment">// 同步状态机</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> buffer_index = <span class="number">0</span>;  <span class="comment">// 缓冲区索引</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint8_t</span> rx_buffer[<span class="number">10</span>];     <span class="comment">// 接收缓冲区</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> last_rx_time = <span class="number">0</span>; <span class="comment">// 最后接收时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Serial2.available())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span> c = Serial2.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态机处理</span></span><br><span class="line">    <span class="keyword">switch</span> (sync_state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 等待帧头1</span></span><br><span class="line">      <span class="keyword">if</span> (c == DEVICE_ID)</span><br><span class="line">      &#123;</span><br><span class="line">        rx_buffer[<span class="number">0</span>] = c;</span><br><span class="line">        sync_state = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 等待帧头2</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0x64</span> || c == <span class="number">0x75</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        rx_buffer[<span class="number">1</span>] = c;</span><br><span class="line">        buffer_index = <span class="number">2</span>;</span><br><span class="line">        sync_state = <span class="number">2</span>;</span><br><span class="line">        last_rx_time = millis();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        sync_state = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 接收数据体</span></span><br><span class="line">      rx_buffer[buffer_index++] = c;</span><br><span class="line">      last_rx_time = millis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完成帧接收</span></span><br><span class="line">      <span class="keyword">if</span> (buffer_index &gt;= <span class="keyword">sizeof</span>(rx_buffer))</span><br><span class="line">      &#123;</span><br><span class="line">        validate_frame(rx_buffer);</span><br><span class="line">        sync_state = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="keyword">if</span> (sync_state == <span class="number">2</span> &amp;&amp; (millis() - last_rx_time) &gt; RX_TIMEOUT_MS)</span><br><span class="line">    &#123;</span><br><span class="line">      sync_state = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(rx_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(rx_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 验证并处理接收到的数据帧</span></span><br><span class="line"><span class="comment"> * @param frame 接收到的完整数据帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_frame</span><span class="params">(<span class="type">uint8_t</span> *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// CRC校验</span></span><br><span class="line">  <span class="keyword">if</span> (crc8_maxim(frame, <span class="number">9</span>) != frame[<span class="number">9</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    SerialBT.println(<span class="string">&quot;CRC Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模式查询响应处理</span></span><br><span class="line">  <span class="keyword">if</span> (frame[<span class="number">1</span>] == <span class="number">0x75</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame[<span class="number">2</span>] == <span class="number">0x02</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Serial2.write(FRAME_STOP, <span class="keyword">sizeof</span>(FRAME_STOP));</span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial2.write(FRAME_OPEN_LOOP, <span class="keyword">sizeof</span>(FRAME_OPEN_LOOP));</span><br><span class="line">    &#125;</span><br><span class="line">    SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;Mode Updated: %s\n&quot;</span>, current_mode);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据帧解析</span></span><br><span class="line">  <span class="keyword">if</span> (frame[<span class="number">1</span>] == <span class="number">0x64</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    actual_rpm = ((<span class="type">int16_t</span>)(frame[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | frame[<span class="number">3</span>]) / <span class="number">10</span>;</span><br><span class="line">    actual_current = (<span class="type">int16_t</span>)(frame[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | frame[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    SerialBT.<span class="built_in">printf</span>(<span class="string">&quot;RPM: %d\tCurrent: %dmA\n&quot;</span>, actual_rpm, actual_current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理蓝牙输入指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_bluetooth</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (SerialBT.available())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> cmd = <span class="built_in">toupper</span>(SerialBT.read());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: <span class="comment">// 速度环模式</span></span><br><span class="line">      Serial2.write(FRAME_STOP, <span class="keyword">sizeof</span>(FRAME_STOP));</span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      current_mode = SPEED_LOOP;</span><br><span class="line">      Serial2.write(FRAME_SPEED_LOOP, <span class="keyword">sizeof</span>(FRAME_SPEED_LOOP));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 开环模式</span></span><br><span class="line">      Serial2.write(FRAME_STOP, <span class="keyword">sizeof</span>(FRAME_STOP));</span><br><span class="line">      delay(<span class="number">500</span>);</span><br><span class="line">      current_mode = OPEN_LOOP;</span><br><span class="line">      Serial2.write(FRAME_OPEN_LOOP, <span class="keyword">sizeof</span>(FRAME_OPEN_LOOP));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送模式查询指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_mode_query</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> query_frame[<span class="number">10</span>] = &#123;DEVICE_ID, <span class="number">0x75</span>&#125;;</span><br><span class="line">  query_frame[<span class="number">9</span>] = crc8_maxim(query_frame, <span class="number">9</span>);</span><br><span class="line">  Serial2.write(query_frame, <span class="keyword">sizeof</span>(query_frame));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学期末复习</title>
      <link href="/2025/01/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/01/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://pan.baidu.com/s/119l3iqQP_2wVGh9vs2dCmA?pwd=f3qh">往年期末真题</a>提取码: f3qh</p><h1 id="极限">极限</h1><h2 id="函数极限">函数极限</h2><h3 id="无穷小">无穷小</h3><h3 id="极限的计算">极限的计算</h3><p><imgsrc="https://pic1.imgdb.cn/item/678319e4d0e0a243d4f38482.png" /></p><h4 id="重要极限">重要极限</h4><h4 id="等价无穷小">等价无穷小</h4><p><imgsrc="https://pic1.imgdb.cn/item/67831a05d0e0a243d4f38492.png" /></p><h4 id="洛必达">洛必达</h4><h4 id="泰勒公式">泰勒公式</h4><p><imgsrc="https://pic1.imgdb.cn/item/67831e77d0e0a243d4f3857e.png" /></p><h2 id="数列极限">数列极限</h2><h3 id="夹逼准则">夹逼准则</h3><p><imgsrc="https://pic1.imgdb.cn/item/67831a21d0e0a243d4f384a5.png" /></p><h2 id="连续点与间断点">连续点与间断点</h2><p><imgsrc="https://pic1.imgdb.cn/item/67831a56d0e0a243d4f384ba.png" /></p><h2 id="零点定理与介值定理">零点定理与介值定理</h2><h3 id="零点定理">零点定理</h3><h3 id="介值定理">介值定理</h3><h1 id="导数与微分">导数与微分</h1><h2 id="导数概念">导数概念</h2><p><imgsrc="https://pic1.imgdb.cn/item/67831a8ad0e0a243d4f384d5.png" /></p><h2 id="求导">求导</h2><h3 id="反函数求导">反函数求导</h3><h3 id="复合函数求导">复合函数求导</h3><p><strong>链式法则</strong></p><h3 id="隐函数求导">隐函数求导</h3><h3 id="参数方程求导">参数方程求导</h3><p><strong>注意高阶导数求法</strong></p><h3 id="高阶导数">高阶导数</h3><p><imgsrc="https://pic1.imgdb.cn/item/67831a9bd0e0a243d4f384db.png" /></p><h4 id="莱布尼茨公式">莱布尼茨公式</h4><h1 id="微分中值定理与导数的应用">微分中值定理与导数的应用</h1><h2 id="微分中值定理">微分中值定理</h2><h2 id="泰勒公式-1">泰勒公式</h2><p>泰勒多项式+余项=泰勒公式</p><p>麦克劳林公式：</p><p><span class="math display">\[  f(x)=\sum_{k = 0}^{n}\frac{f^{(k)}(0)}{k!}x^k + R_n(x),其中f^{(k)}(0)是f(x)在x = 0处的k阶导数，k!是k的阶乘，R_n(x)是余项。\]</span></p><p>展开式：</p><p><span class="math display">\[\begin{aligned}    e^{x}&amp;=\sum_{n=0}^{\infty} \frac{1}{n !} x^{n}=1+x+\frac{1}{2 !}x^{2}+\cdots \in(-\infty,+\infty) \\    \sin x&amp;=\sum_{n=0}^{\infty} \frac{(-1)^{n}}{(2 n+1) !} x^{2n+1}=x-\frac{1}{3 !} x^{3}+\frac{1}{5 !} x^{5}+\cdots, x\in(-\infty,+\infty) \\    \cos x&amp;=\sum_{n=0}^{\infty} \frac{(-1)^{n}}{(2 n) !} x^{2n}=1-\frac{1}{2 !} x^{2}+\frac{1}{4 !} x^{4}+\cdots, x\in(-\infty,+\infty) \\    \ln (1+x)&amp;=\sum_{n=0}^{\infty} \frac{(-1)^{n}}{n+1}x^{n+1}=x-\frac{1}{2} x^{2}+\frac{1}{3} x^{3}+\cdots, x \in(-1,1] \\    \frac{1}{1-x}&amp;=\sum_{n=0}^{\infty} x^{n}=1+x+x^{2}+x^{3}+\cdots,x \in(-1,1) \\    \frac{1}{1+x}&amp;=\sum_{n=0}^{\infty}(-1)^{n}x^{n}=1-x+x^{2}-x^{3}+\cdots, x \in(-1,1)\\        (1+x)^{\alpha}&amp;=1+\sum_{n=1}^{\infty} \frac{\alpha(\alpha-1)\cdots(\alpha-n+1)}{n !} x^{n}=1+\alpha x+\frac{\alpha(\alpha-1)}{2 !}x^{2}+\cdots, x \in(-1,1) \\        \arctan x&amp;=\sum_{n=0}^{\infty} \frac{(-1)^{n}}{2 n+1} x^{2n+1}=x-\frac{1}{3} x^{3}+\frac{1}{5} x^{5}+\cdots+ x \in[-1,1] \\        \arcsin x&amp;=\sum_{n=0}^{\infty} \frac{(2 n) !}{4^{n}(n!)^{2}(2 n+1)} x^{2n+1}=x+\frac{1}{6} x^{3}+\frac{3}{40}x^{5}+\frac{5}{112} x^{7}+\frac{35}{1152} x^{9}+\cdots+, x \in(-1,1)\\        \tan x&amp;=\sum_{n=1}^{\infty} \frac{B_{2n}(-4)^{n}\left(1-4^{n}\right)}{(2 n) !} x^{2 n-1}=x+\frac{1}{3}x^{3}+\frac{2}{15} x^{5}+\frac{17}{315} x^{7}+\frac{62}{2835}x^{9}+\frac{1382}{155925} x^{11}+\frac{21844}{6081075}x^{13}+\frac{929569}{638512875} x^{15}+\cdots,x\in(-\frac{\pi}{2},\frac{\pi}{2})    \end{aligned}\]</span></p><h2 id="单调性与凹凸性">单调性与凹凸性</h2><h2 id="极值与最值">极值与最值</h2><h2 id="曲率">曲率</h2><p><imgsrc="https://pic1.imgdb.cn/item/678321a9d0e0a243d4f385d0.png" /></p><h1 id="不定积分与定积分">不定积分与定积分</h1><h2 id="不定积分">不定积分</h2><h3 id="部分积分不能用初等函数表示">部分积分不能用初等函数表示</h3><p><imgsrc="https://pic1.imgdb.cn/item/6783228cd0e0a243d4f38605.png" /></p><h3 id="积分公式">积分公式</h3><h3 id="积分方法">积分方法</h3><h4 id="分项积分">分项积分</h4><p>1.用分子凑分母拆成多项式的和的积分</p><p>2.三件函数变换：平方和（<spanclass="math inline">\(sin和cos、tan和sec\)</span>），二倍角，积化和差</p><h4 id="第一类换元">第一类换元</h4><p>常用凑微分公式（举例）：</p><p><span class="math display">\[1）  \int f(a x+b) d x=\frac{1}{a} \int f(a x+b) d(a x+b)(a \neq0)  ；\]</span> <span class="math display">\[2）  \int f(\sin x) \cos x d x=\int f(\sin x) d \sin x  ；\]</span><span class="math display">\[3）  \int f(\ln x) \frac{1}{x} d x=\int f(\ln x) d \ln x  ；\]</span><span class="math display">\[4）  \int f(\sqrt{x}) \frac{d x}{\sqrt{x}}=2 \int f(\sqrt{x})d(\sqrt{x})  ；\]</span> <span class="math display">\[5）  \int f(\arctan x) \frac{d x}{1+x^{2}}=\int f(\arctan x) d \arctanx  ．\]</span></p><h4 id="第二类换元">第二类换元</h4><p>定义：令 <span class="math inline">\(x=\psi(t)\)</span> ，使 <spanclass="math inline">\(\int f(x) d x=\int f[\psi(t)] \psi^{\prime}(t) dt\)</span> ，其中 <span class="math inline">\(x=\psi(t)\)</span>单调可导且 <span class="math inline">\(\psi^{\prime}(t) \neq 0\)</span>．</p><h5 id="三角代换-a0">三角代换 (a&gt;0)</h5><p>被积函数含 <span class="math inline">\(\sqrt{a^{2}-x^{2}}\)</span>，令 <span class="math inline">\(x=a \sin t, t \in\left[-\frac{\pi}{2},\frac{\pi}{2}\right]\)</span> ，则 <spanclass="math inline">\(\sqrt{a^{2}-x^{2}}=a \cos t\)</span> ；</p><p>被积函数含 <span class="math inline">\(\sqrt{x^{2}+a^{2}}\)</span>，令 <span class="math inline">\(x=a \tan t, t \in\left(-\frac{\pi}{2},\frac{\pi}{2}\right) ，则 \sqrt{x^{2}+a^{2}}=a \sec t\)</span> ；</p><p>被积函数含 <span class="math inline">\(\sqrt{x^{2}-a^{2}}\)</span>，令 <span class="math inline">\(x=a \sec t, t \in\left[0,\frac{\pi}{2}\right) \cup\left(\frac{\pi}{2}, \pi\right] ，则\sqrt{x^{2}-a^{2}}=a|\tan t|\)</span> ；</p><h5 id="根式代换">根式代换</h5><p>被积函数含 <span class="math inline">\(\sqrt[n]{a x+b}\)</span> ，令<span class="math inline">\(t=\sqrt[n]{a x+b}\)</span> ，有 <spanclass="math inline">\(x=\frac{1}{a}\left(t^{n}-b\right)\)</span> ．</p><h5 id="倒代换">倒代换</h5><p>当被积函数分母的最高次数高于分子的最高次数时，可试用倒代换令 x=．</p><h4 id="分部积分">分部积分</h4><h5 id="表格法">表格法</h5><p>口诀：反对幂指三（靠后面的放到d后面）</p><p>适用范围：幂函数与指数函数/三角函数与指数函数</p><h4 id="有理函数积分">有理函数积分</h4><p>1.分母因式分解</p><p>2.分子待定系数法</p><p>eg.</p><p><span class="math display">\[①\frac{2x + 1}{(2x + 3)^2(2x^2 + 3x + 4)} = \frac{A_1}{2x + 3} +\frac{A_2}{(2x + 3)^2} + \frac{Bx + D}{2x^2 + 3x + 4}\]</span> <spanclass="math display">\[②\frac{2x + 6x^2}{(x - 5)(3x^2 + x + 1)^2} =\frac{A}{x - 5} + \frac{B_1x + D_1}{3x^2 + x + 1} + \frac{B_2x +D_2}{(3x^2 + x + 1)^2}\]</span></p><h4 id="三角函数有理式的积分">三角函数有理式的积分</h4><p>万能代换</p><p><ahref="https://blog.csdn.net/m0_56494923/article/details/129014727">三角有理式积分——万能代换公式详细推导_三角有理式积分万能代换推导-CSDN博客</a></p><p><imgsrc="https://pic1.imgdb.cn/item/6783399bd0e0a243d4f38b04.png" /></p><h4 id="分段函数的积分">分段函数的积分</h4><p>1.各段分别求原函数</p><p>2.注意分段点一定要连续</p><h2 id="定积分">定积分</h2><h3 id="几何物理意义">几何物理意义</h3><h3 id="求数列极限">求数列极限</h3><p><imgsrc="https://pic1.imgdb.cn/item/67834cc8d0e0a243d4f38ff6.png" /></p><h3 id="变限积分">变限积分</h3><p>性质： <span class="math display">\[\begin{align*}&amp;1)\quad\text{若 }f(x)\text{ 在 }[a,b]\text{ 上可积，则函数}F(x)=\int_{a}^{x} f(t)dt\text{ 在 }[a,b]\text{ 上连续；}\\&amp;2)\quad\text{若 }f(x)\text{ 在 }[a,b]\text{ 上连续，则函数}F(x)=\int_{a}^{x} f(t)dt\text{ 在 }[a,b]\text{ 上可导，且}F^{\prime}(x)=f(x). \end{align*}\]</span></p><p>对于可积：有积分值就可积（1.连续；或者2.有界且有有限个间断点）</p><p>求导：</p><p><imgsrc="https://pic1.imgdb.cn/item/678358bad0e0a243d4f392db.png" /></p><h3 id="积分方法-1">积分方法</h3><p>计算用 <imgsrc="https://pic1.imgdb.cn/item/67834d0ad0e0a243d4f3900c.png" /></p><p>证明用 <imgsrc="https://pic1.imgdb.cn/item/67834d79d0e0a243d4f3903b.png" /></p><h3 id="对称区间积分">对称区间积分</h3><p>1.<strong>偶倍奇邻</strong></p><p>2.<span class="math inline">\(\quad \int_{-a}^{a} f(x)dx =\int_{0}^{a} [f(x) + f(-x)]dx.\)</span></p><p>可能遇到的公式： <span class="math display">\[\arctan x + \arctan\frac{1}{x} =\begin{cases}\frac{\pi}{2}, &amp; x &gt; 0 \\-\frac{\pi}{2}, &amp; x &lt; 0\end{cases}\]</span></p><h3 id="换元法">换元法</h3><p><strong>积分换元必换限</strong></p><h3 id="华理士公式点火公式">华理士公式（点火公式）</h3><p><span class="math display">\[\text{华理士公式：}\int_{0}^{\frac{\pi}{2}}\sin^{n}xdx=\int_{0}^{\frac{\pi}{2}}\cos^{n}xdx=\begin{cases}\frac{(n - 1)!!}{n!!}\cdot\frac{\pi}{2}, &amp; n\geq 2\text{为正偶数},\\\frac{(n - 1)!!}{n!!}, &amp; n\geq 3 \text{为正奇数}.\end{cases}\]</span></p><p>可能的前置转换： <span class="math display">\[\begin{align*}&amp;\text{设 }f(x)\text{ 在区间 }[0,1]\text{ 上连续，则}\\&amp;1)\quad\int_{0}^{\frac{\pi}{2}} f(\sinx)dx=\int_{0}^{\frac{\pi}{2}} f(\cos x)dx;\\ &amp;2)\quad\int_{0}^{\pi}f(\sin x)dx = 2\int_{0}^{\frac{\pi}{2}} f(\sin x)dx,\quad\int_{0}^{\pi}f(|\cos x|)dx = 2\int_{0}^{\frac{\pi}{2}} f(\cos x)dx;\\&amp;\text{注：在 }[0,\pi]\text{ 上 }f(\cos^{2} x), f(|\cos x|)\text{可以看作 }f(\sin x)\text{ ，}f(\cos x)\text{ 不可看作 }f(\sin x).\\&amp;3)\quad\int_{0}^{\pi} xf(\sin x)dx=\frac{\pi}{2}\int_{0}^{\pi}f(\sin x)dx;\\&amp;4)\quad\text{华理士公式：}\int_{0}^{\frac{\pi}{2}}\sin^{n}xdx=\int_{0}^{\frac{\pi}{2}}\cos^{n} xdx=\begin{cases} \frac{(n -1)!!}{n!!}\cdot\frac{\pi}{2}, &amp; n\geq 2\text{ 为正偶数},\\ \frac{(n- 1)!!}{n!!}, &amp; n\geq 3\text{ 为正奇数}. \end{cases}\\&amp;5)\quad\int_{0}^{2\pi}\sin^{n} xdx=\int_{0}^{2\pi}\cos^{n}xdx=\begin{cases} 4\int_{0}^{\frac{\pi}{2}}\sin^{n} xdx, &amp; n\text{为正偶数},\\ 0, &amp; n\text{ 为正奇数}. \end{cases} \end{align*}\]</span></p><h3 id="区间再现公式">区间再现公式</h3><h2 id="反常积分广义积分">反常积分（广义积分）</h2><h3 id="无穷限的反常积分">无穷限的反常积分</h3><h3 id="无界函数的反常积分">无界函数的反常积分</h3><h2 id="几何学的应用">几何学的应用</h2><p>直角坐标：</p><p><imgsrc="https://pic1.imgdb.cn/item/67835d4cd0e0a243d4f39437.png" /></p><p>极坐标：</p><p><imgsrc="https://pic1.imgdb.cn/item/67835d94d0e0a243d4f3944c.png" /></p><p>立体：</p><p><imgsrc="https://pic1.imgdb.cn/item/67835fbed0e0a243d4f3953d.png" /></p><p>曲线弧长和旋转面面积：</p><p><imgsrc="https://pic1.imgdb.cn/item/67836130d0e0a243d4f39613.png" /></p><p>柱壳法：<ahref="https://www.bilibili.com/video/BV14p4y1k7XM?vd_source=379d5cda68ca666fa7175545a5db3f8a">用最硬核的方法讲解大学数学柱壳法，不信你还看不懂</a></p><p>旋转面面积可以理解为周长*弧微分的积分</p><h2 id="物理学的应用">物理学的应用</h2><h1 id="微分方程">微分方程</h1><h2 id="可分离变量的微分方程">可分离变量的微分方程</h2><p>自变量因变量分开在等式两侧同时积分</p><h2 id="齐次方程">齐次方程</h2><h3 id="定义">定义</h3><p><span class="math display">\[形如 \frac{dy}{dx} = f(\frac{y}{x})\的一阶微分方程称为齐次微分方程，简称微分方程。\]</span></p><h3 id="特点">特点</h3><p><spanclass="math display">\[齐次微分方程的特点是其右端项是以\frac{y}{x}为变元的连续函数。\]</span><spanclass="math display">\[ 例如，(x^{2}+y^{2})dx - xydy =0是齐次微分方程，它可以转化为：\frac{dy}{dx}=\frac{x^{2}+y^{2}}{xy}，即\frac{dy}{dx}=\frac{x}{y}+\frac{y}{x}。\]</span></p><h3 id="方程的解">方程的解</h3><p><spanclass="math display">\[齐次微分方程通过\textbf{变量代换}，可化为\textbf{可分离变量微分方程}来求解。\]</span><span class="math display">\[ 令u = \frac{y}{x}或y = ux， \]</span><span class="math display">\[其中u = u(x)是新的未知函数，对y =ux两边\textbf{求导}，则有：\frac{dy}{dx} = u + x\frac{du}{dx}，\]</span><span class="math display">\[ 将其代入\frac{dy}{dx} =f(\frac{y}{x})，得：u + x\frac{du}{dx} = f(u)，\]</span> <spanclass="math display">\[ 分离变量，得：\frac{du}{f(u) - u} = \frac{dx}{x}\]</span> <span class="math display">\[两边\textbf{积分}，得：\int\frac{du}{f(u) - u} = \int \frac{dx}{x}，\]</span> <spanclass="math display">\[ 求出积分后，再将u =\frac{y}{x}回代，便得到方程\frac{dy}{dx} =f(\frac{y}{x})的通解。\]</span></p><h2 id="一阶线性微分方程">一阶线性微分方程</h2><p><ahref="https://blog.csdn.net/weixin_42941859/article/details/121274613">6.1.3一阶线性方程的线性、齐次与通解公式-CSDN博客</a></p><p>公式：<span class="math inline">\(y = e^{-\int g(x)dx}[C + \inth(x)e^{\int g(x)dx}dx]\)</span></p><div class="note warning flat"><p>这里会有更换主元的考法</p></div><h3 id="伯努利方程">伯努利方程</h3><p>这篇文章比较完全：<ahref="https://blog.csdn.net/weixin_45827703/article/details/104851743">【高等数学】伯努利方程及其求解方法_伯努利方程高数-CSDN博客</a></p><p><imgsrc="https://pic1.imgdb.cn/item/6783b490d0e0a243d4f3aad6.png" /></p><h2 id="可降阶的高阶微分方程">可降阶的高阶微分方程</h2><h3 id="可以连续积分型">可以连续积分型</h3><p>一直积分就行了</p><h3 id="不显含y型">不显含y型</h3><h3 id="不限含x型">不限含x型</h3><h2 id="高阶线性微分方程">高阶线性微分方程</h2><p>利用解的结构（和线性代数的思路相似）</p><div class="note warning flat"><p>这里会有解的叠加原理的考法</p></div><h2 id="常系数齐次线性微分方程">常系数齐次线性微分方程</h2><p><imgsrc="https://pic1.imgdb.cn/item/6783b5afd0e0a243d4f3ab01.png" /></p><p>高阶的例题：</p><p><span class="math inline">\(例6 求方程y^{(4)} - 2y&#39;&#39;&#39; +5y&#39;&#39; = 0的通解.\)</span> 解 这里的特征方程为</p><p><span class="math display">\[r^{4} - 2r^{3} + 5r^{2} =0,\]</span></p><p>即</p><p><span class="math display">\[r^{2}(r^{2} - 2r + 5) = 0.\]</span></p><p>它的根是<span class="math inline">\(r_{1} = r_{2} = 0\)</span>和<spanclass="math inline">\(r_{3,4} = 1 \pm2\text{i}\)</span>.因此所给微分方程的通解为 <spanclass="math display">\[y = C_{1} + C_{2}x + \text{e}^{x}(C_{3}\cos 2x +C_{4}\sin 2x).\]</span></p><h2 id="常系数非齐次线性微分方程">常系数非齐次线性微分方程</h2><p><a href="https://zhuanlan.zhihu.com/p/349527153">微分方程第七节常系数齐次线性微分方程 - 知乎 (zhihu.com)</a></p><p><imgsrc="https://pic1.imgdb.cn/item/6783baf8d0e0a243d4f3ac6a.jpg" /></p><h1 id="附录">附录</h1><h2 id="积分表">积分表</h2><p><imgsrc="https://pic3.zhimg.com/v2-0855b8f2b620f94422d4e0c419cb0e58_r.jpg" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言期末复习</title>
      <link href="/2025/01/10/C%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/01/10/C%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据基本类型和输入输出">数据基本类型和输入输出</h1><h2id="c语言将数字和数字字符输入给char型变量会如何">C语言——将数字和数字字符输入给char型变量会如何？</h2><p><ahref="https://blog.csdn.net/weixin_52005740/article/details/117432826">C语言——将数字和数字字符输入给char型变量会如何？-CSDN博客</a></p><h1 id="字符串">字符串</h1><h2 id="输入输出函数">输入输出函数</h2><h3 id="sscanf">sscanf</h3><ol type="1"><li><p><strong>函数定义与功能</strong></p><ul><li><strong>sscanf</strong>是 C语言中的函数，函数原型为<code>int sscanf(const char *str, const char *format,...)</code>。它的主要作用是从字符串<code>str</code>中按照<code>format</code>指定的格式读取数据，并将读取的数据存储到可变参数列表所指定的变量中。</li><li>简单来说，它是<code>sprintf</code>的逆操作。<code>sprintf</code>是将数据格式化后写入字符串，而<code>sscanf</code>是从字符串中解析出数据并存储到变量中。</li></ul></li><li><p><strong>使用示例</strong></p><ul><li><p><strong>基本数据类型的读取</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;10 3.14 A&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> f_num;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%d %f %c&quot;</span>, &amp;num, &amp;f_num, &amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的整数：%d，浮点数：%f，字符：%c\n&quot;</span>, num, f_num, ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>sscanf</code>从字符串<code>str</code>（"10 3.14A"）中按照<code>%d %f %c</code>的格式读取数据。它将字符串中的第一个数字<code>10</code>读取并存储到<code>num</code>变量中，第二个数字<code>3.14</code>存储到<code>f_num</code>变量中，最后一个字符<code>A</code>存储到<code>ch</code>变量中。最后输出<code>读取的整数：10，浮点数：3.140000，字符：A</code>。</p></li><li><p><strong>字符串部分读取与格式匹配</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="type">char</span> part1[<span class="number">4</span>];</span><br><span class="line">    <span class="type">char</span> part2[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%3s%3s&quot;</span>, part1, part2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的第一部分：%s，第二部分：%s\n&quot;</span>, part1, part2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>sscanf</code>按照<code>%3s%3s</code>的格式从<code>str</code>中读取数据。<code>%3s</code>表示读取最多3个字符作为一个字符串。所以<code>part1</code>读取了<code>abc</code>，<code>part2</code>读取了<code>def</code>，输出为<code>读取的第一部分：abc，第二部分：def</code>。</p></li></ul></li><li><p><strong>注意事项</strong></p><ul><li><strong>格式匹配与数据类型</strong>：格式控制字符串<code>format</code>的格式必须与要读取的数据类型和格式相匹配。如果不匹配，可能会导致读取的数据错误或者程序异常。例如，如果格式控制字符串中要求读取一个整数，但字符串中对应的部分不是合法的整数格式，就会出现问题。</li><li><strong>缓冲区大小</strong>：在读取字符串数据到字符数组变量时，要确保字符数组有足够的大小来容纳读取的数据。如果字符数组过小，可能会导致缓冲区溢出，覆盖其他内存区域的数据。</li><li><strong>可变参数列表的正确使用</strong>：传递给<code>sscanf</code>的可变参数必须是正确的变量地址，这样才能将读取的数据正确存储。例如，对于整数变量，要传递其地址<code>&amp;num</code>，而不是变量本身<code>num</code>。</li></ul></li><li><p><strong>应用场景</strong></p><ul><li><strong>数据解析与提取</strong>：在处理用户输入、配置文件或者网络数据包等数据时，<code>sscanf</code>可以用于从字符串格式的数据中提取出需要的信息。例如，从用户输入的日期字符串（如<code>"2025-01-10"</code>）中提取出年、月、日等信息。</li><li><strong>数据转换与验证</strong>：可以用于验证和转换数据格式。比如，检查一个字符串是否符合某种数字格式，如果符合则将其转换为相应的数字类型存储到变量中，方便后续的计算和处理。</li></ul></li></ol><h3 id="sprintf">sprintf</h3><ol type="1"><li><p><strong>函数定义与功能</strong></p><ul><li><strong>sprintf</strong>是 C语言中的一个函数，函数原型为<code>int sprintf(char *str, const char *format,...)</code>。它的主要功能是将格式化的数据写入到字符串<code>str</code>中。</li><li>其中，<code>format</code>是格式化字符串，类似于<code>printf</code>函数中的格式控制字符串，它规定了要写入的数据的格式，包括数据类型（如整数、浮点数、字符等）、宽度、精度等信息。后面的省略号<code>...</code>表示可变参数列表，用于传递要格式化的数据。</li></ul></li><li><p><strong>使用示例</strong></p><ul><li><p><strong>基本数据类型的格式化输出</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> f_num = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;整数：%d，浮点数：%f，字符：%c&quot;</span>, num, f_num, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>sprintf</code>函数将整数<code>num</code>、浮点数<code>f_num</code>和字符<code>ch</code>按照指定的格式（<code>%d</code>、<code>%f</code>、<code>%c</code>）进行格式化，并写入到<code>buffer</code>字符串中。最后通过<code>printf</code>输出<code>buffer</code>的内容，结果为<code>整数：10，浮点数：3.140000，字符：A</code>。</p></li><li><p><strong>格式化字符串拼接</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%s %s&quot;</span>, str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>sprintf</code>将<code>str1</code>和<code>str2</code>两个字符串拼接起来写入到<code>buffer</code>中，输出结果为<code>Hello World</code>。</p></li></ul></li><li><p><strong>注意事项</strong></p><ul><li><strong>缓冲区大小</strong>：使用<code>sprintf</code>时，必须确保目标字符串<code>str</code>有足够的空间来容纳格式化后的数据。如果空间不足，会导致缓冲区溢出，可能会引起程序崩溃或产生不可预测的行为。</li><li><strong>格式化字符串的正确性</strong>：格式控制字符串<code>format</code>的格式必须与后面传递的参数类型和数量相匹配。否则，可能会得到错误的结果或者程序出现异常。例如，如果格式控制字符串中要求一个整数参数，但实际传递的是一个字符，就会出现问题。</li></ul></li><li><p><strong>应用场景</strong></p><ul><li><strong>数据记录与日志记录</strong>：在程序中记录数据或生成日志时，可以使用<code>sprintf</code>将各种数据（如时间、状态信息、数据值等）按照一定的格式组合成一个字符串，方便存储或输出。</li><li><strong>数据转换与显示</strong>：可以将不同类型的数据（如二进制数据转换为十六进制字符串显示，整数转换为特定格式的字符串等）进行格式化，用于在用户界面或者数据传输过程中进行合适的展示。</li></ul></li></ol><h2 id="字符串处理函数">字符串处理函数</h2><h3 id="strlen-与sizeof">strlen 与sizeof</h3><ol type="1"><li><strong>含义</strong><ul><li><strong>strlen</strong>：是一个函数，用于计算字符串的长度。它从给定字符串的起始位置开始，一直计数到遇到字符串结束标志'\0' 为止，并且不包括 '\0' 本身。这个函数定义在 &lt;string.h&gt;头文件中（在 C 语言中）。</li><li><strong>sizeof</strong>：是一个操作符，不是函数。它用于计算变量或数据类型所占用的字节数。在计算数组时，它返回整个数组所占用的字节数；在计算指针时，它返回指针本身所占用的字节数（通常在32 位系统中是 4 字节，在 64 位系统中是 8 字节）。</li></ul></li><li><strong>使用示例</strong><ul><li><p><strong>strlen 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The length of the string is %d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个示例中，<code>strlen(str)</code>会计算字符串<code>str</code>中字符的个数，不包括'\0'。所以输出结果是<code>5</code>。</p></li><li><p><strong>sizeof 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size_of_arr = <span class="keyword">sizeof</span>(arr);</span><br><span class="line">    <span class="type">int</span> size_of_int = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> num_elements = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The size of the array is %d bytes\n&quot;</span>, size_of_arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The size of an int is %d bytes\n&quot;</span>, size_of_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of elements in the array is %d\n&quot;</span>, num_elements);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>sizeof(arr)</code>返回整个数组<code>arr</code>所占用的字节数。假设<code>int</code>类型占4 字节，那么<code>size_of_arr</code>的值为<code>20</code>（因为数组中有5 个<code>int</code>元素，每个<code>int</code>占 4字节）。<code>sizeof(int)</code>返回<code>int</code>类型所占用的字节数，这里假设是4。<code>num_elements</code>通过<code>sizeof(arr)/sizeof(int)</code>计算出数组中元素的个数，结果为<code>5</code>。</p></li></ul></li><li><strong>对于不同数据类型的应用区别</strong><ul><li><strong>对于字符数组（字符串）</strong><ul><li><strong>strlen</strong>：重点关注字符串内容的长度，即字符的个数。例如，对于字符数组<code>char str[] = "abcde"</code>，<code>strlen(str)</code>返回<code>5</code>。</li><li><strong>sizeof</strong>：如果是字符数组，它返回数组占用的总字节数。对于<code>char str[] = "abcde"</code>，<code>sizeof(str)</code>返回包括'\0' 在内的字符数组的大小，通常是 6（假设<code>char</code>占 1字节）。</li></ul></li><li><strong>对于普通变量和数据类型</strong><ul><li><strong>strlen</strong>：不能用于非字符数组类型来获取其长度相关信息。例如，对于<code>int num = 10;</code>，不能使用<code>strlen</code>来计算它的任何长度相关内容。</li><li><strong>sizeof</strong>：可以用于任何变量或数据类型。对于<code>int num = 10;</code>，<code>sizeof(num)</code>返回<code>int</code>类型所占用的字节数，通常在32 位系统中是 4 字节，在 64 位系统中也是 4字节（<code>int</code>类型大小一般是固定的，但也有一些特殊情况）。对于自定义的结构体等复杂数据类型，<code>sizeof</code>也可以计算其占用的字节数。</li></ul></li></ul></li><li><strong>在指针方面的区别</strong><ul><li><p><strong>strlen</strong>：当应用于字符指针时，它会从指针所指向的字符开始，一直计数到遇到'\0' 字符为止。例如：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(ptr);</span><br></pre></td></tr></table></figure></p><p>这里<code>len</code>的值为<code>5</code>，因为<code>strlen</code>会沿着指针<code>ptr</code>所指向的字符串计算长度，直到'\0'。</p></li><li><p><strong>sizeof</strong>：当应用于指针时，不管指针指向什么类型的数据，它只返回指针本身所占用的字节数。例如：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line"><span class="type">int</span> size = <span class="keyword">sizeof</span>(ptr);</span><br></pre></td></tr></table></figure></p><p>在 32 位系统中<code>size</code>为 4 字节，在 64位系统中<code>size</code>为 8字节，因为它计算的是指针变量本身的大小，而不是指针所指向的数据的大小。</p></li></ul></li></ol><p>在使用strlen和sizeof时，有哪些需要注意的地方？</p><p>除了C语言，其他编程语言中是否有类似strlen和sizeof的函数或操作符？</p><p>在计算结构体大小时，sizeof和strlen有什么区别？</p><h3 id="strcpy-与strncpy">strcpy 与strncpy</h3><ol type="1"><li><strong>含义</strong><ul><li><strong>strcpy</strong>：是一个 C语言中的字符串操作函数，用于将一个字符串（包括结束符'\0'）复制到另一个字符串中。它的函数原型是<code>char* strcpy(char* destination, const char* source)</code>。它会从<code>source</code>字符串的起始位置开始，逐个字符地将内容复制到<code>destination</code>字符串中，直到遇到<code>source</code>中的'\0' 字符，然后也会把 '\0'复制过去，这样<code>destination</code>就成为了<code>source</code>的一个副本。</li><li><strong>strncpy</strong>：也是一个用于字符串复制的函数，它的函数原型是<code>char* strncpy(char* destination, const char* source, size_t n)</code>。它会从<code>source</code>字符串中复制最多<code>n</code>个字符到<code>destination</code>字符串中。如果<code>source</code>的长度小于<code>n</code>，则会在<code>destination</code>中剩余的位置填充'\0'；如果<code>source</code>的长度大于等于<code>n</code>，则不会自动在<code>destination</code>的末尾添加'\0'。</li></ul></li><li><strong>使用示例</strong><ul><li><p><strong>strcpy 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(destination, source);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, destination);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>strcpy</code>函数将<code>source</code>字符串（"Hello"）复制到<code>destination</code>字符串中。最后输出<code>Copied string: Hello</code>。</p></li><li><p><strong>strncpy 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> destination2[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 使用strncpy复制部分字符</span></span><br><span class="line">    <span class="built_in">strncpy</span>(destination1, source, <span class="number">5</span>);</span><br><span class="line">    destination1[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">// 如果source长度大于等于n，需要手动添加&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">strncpy</span>(destination2, source, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string 1: %s\n&quot;</span>, destination1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string 2: %s\n&quot;</span>, destination2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，<code>strncpy(destination1, source, 5)</code>会将<code>source</code>中的前5个字符（"Hello"）复制到<code>destination1</code>中。由于<code>source</code>的长度大于5，所以需要手动添加 '\0'来正确结束字符串。而<code>strncpy(destination2, source, 15)</code>会将<code>source</code>中的前15个字符复制到<code>destination2</code>中，因为<code>source</code>的长度小于15，所以<code>strncpy</code>会自动在剩余位置填充'\0'，最后输出<code>Copied string 1: Hello</code>和<code>Copied string 2: Hello, world!</code>。</p></li></ul></li><li><strong>安全风险和注意事项</strong><ul><li><strong>strcpy</strong>：存在缓冲区溢出的安全风险。如果<code>destination</code>字符串的长度小于<code>source</code>字符串的长度，就会导致缓冲区溢出，可能会覆盖其他内存区域的数据，甚至可能导致程序崩溃或产生安全漏洞。例如，如果<code>destination</code>的大小只有6 字节，而<code>source</code>是一个长度大于 6的字符串，如<code>"abcdefg"</code>，使用<code>strcpy</code>就会出现问题。</li><li><strong>strncpy</strong>：虽然可以通过指定复制的字符数<code>n</code>来在一定程度上避免缓冲区溢出，但是如果使用不当，也会出现问题。如忘记在<code>source</code>长度大于等于<code>n</code>时手动添加'\0'，会导致<code>destination</code>字符串可能没有正确结束，从而在后续使用这个字符串时产生意外的结果。</li></ul></li><li><strong>适用场景</strong><ul><li><strong>strcpy</strong>：适用于已知<code>destination</code>足够大，能够容纳<code>source</code>字符串的情况，比如在对一些已经初始化好足够空间的字符串进行复制操作时。例如，在处理固定大小且足够大的缓冲区来接收另一个已知长度不会超过它的字符串时可以使用。</li><li><strong>strncpy</strong>：适用于对复制字符数量有明确限制的情况，比如只需要复制字符串的前一部分，或者在处理可能会出现缓冲区大小不确定的情况，通过限制复制字符数来防止缓冲区溢出。例如，在从网络接收数据，并且只希望将接收到的前几个字节作为字符串处理时，可以使用<code>strncpy</code>。</li></ul></li></ol><h3 id="strcat-与strncat">strcat 与strncat</h3><ol type="1"><li><strong>含义</strong><ul><li><strong>strcat</strong>：是 C语言中的字符串拼接函数。它的函数原型是<code>char* strcat(char* destination, const char* source)</code>。该函数会将<code>source</code>字符串（包括结束符'\0'）追加到<code>destination</code>字符串的末尾。它首先会找到<code>destination</code>字符串的结束符'\0'的位置，然后从这个位置开始，将<code>source</code>字符串的内容逐个字符地复制到<code>destination</code>中，最后在新的<code>destination</code>字符串的末尾添加'\0'。</li><li><strong>strncat</strong>：同样是字符串拼接函数，函数原型为<code>char* strncat(char* destination, const char* source, size_t n)</code>。这个函数会将<code>source</code>字符串中的最多<code>n</code>个字符追加到<code>destination</code>字符串的末尾。它也会先找到<code>destination</code>字符串的结束符'\0'，然后从这个位置开始复制。如果<code>source</code>字符串的长度小于<code>n</code>，则会将整个<code>source</code>字符串复制过去，并添加'\0'；如果<code>source</code>字符串的长度大于等于<code>n</code>，则只复制<code>n</code>个字符，然后添加'\0'。</li></ul></li><li><strong>使用示例</strong><ul><li><p><strong>strcat 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">30</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(destination, source);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Concatenated string: %s\n&quot;</span>, destination);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>strcat</code>函数会将<code>source</code>字符串（"world!"）追加到<code>destination</code>字符串（"Hello,"）的末尾，最终输出<code>Concatenated string: Hello, world!</code>。</p></li><li><p><strong>strncat 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">30</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;beautiful world!&quot;</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(destination, source, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Concatenated string: %s\n&quot;</span>, destination);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>strncat</code>函数会将<code>source</code>字符串中的前 7个字符（"beautiful" 中的前 7 个字符，即"beauti"）追加到<code>destination</code>字符串（"Hello,"）的末尾，最后输出<code>Concatenated string: Hello, beauti</code>。</p></li></ul></li><li><strong>安全风险和注意事项</strong><ul><li><strong>strcat</strong>：存在缓冲区溢出的风险。如果<code>destination</code>字符串没有足够的空间来容纳<code>source</code>字符串以及自身原有的内容，就会导致缓冲区溢出。例如，如果<code>destination</code>的长度为10 字节，已经有内容占用了 6 字节，而<code>source</code>的长度为 5字节，使用<code>strcat</code>就会超出<code>destination</code>的范围，可能会覆盖其他内存区域的数据。</li><li><strong>strncat</strong>：相比<code>strcat</code>，在一定程度上降低了缓冲区溢出的风险。但是如果<code>n</code>的值设置不合理，仍然可能会出现问题。比如，当<code>n</code>设置得过大，使得<code>destination</code>无法容纳追加后的内容，就会出现溢出；当<code>n</code>设置得过小，可能无法完整地追加想要的内容。</li></ul></li><li><strong>适用场景</strong><ul><li><strong>strcat</strong>：适用于能够确定<code>destination</code>字符串有足够的空间来容纳拼接后的字符串的情况。例如，在处理一些内部缓冲区大小固定且足够大，并且已经对拼接后的长度有预估的字符串拼接操作时可以使用。</li><li><strong>strncat</strong>：更适合用于对拼接字符数量有明确限制的情况，特别是当不确定<code>source</code>字符串的长度或者担心<code>destination</code>的空间不够时。比如，在从用户输入或网络接收数据进行拼接时，为了避免缓冲区溢出，可以使用<code>strncat</code>来限制每次拼接的字符数量。</li></ul></li></ol><h3 id="strcmp-与strncmp">strcmp 与strncmp</h3><ol type="1"><li><p><strong>含义</strong></p><ul><li><strong>strcmp</strong>：是 C语言中的字符串比较函数，函数原型为<code>int strcmp(const char* s1, const char* s2)</code>。它用于比较两个字符串<code>s1</code>和<code>s2</code>的内容。比较是基于字符的ASCII码值进行的，从两个字符串的第一个字符开始，逐个字符比较。如果<code>s1</code>中的字符的ASCII 码值小于<code>s2</code>中的相应字符的 ASCII码值，那么<code>strcmp</code>返回一个负整数；如果<code>s1</code>中的字符的ASCII 码值大于<code>s2</code>中的相应字符的 ASCII码值，那么<code>strcmp</code>返回一个正整数；如果两个字符串完全相同（长度相等且每个对应字符都相同），则返回0。</li><li><strong>strncmp</strong>：也是一个字符串比较函数，函数原型是<code>int strncmp(const char* s1, const char* s2, size_t n)</code>。它用于比较两个字符串<code>s1</code>和<code>s2</code>的前<code>n</code>个字符。比较规则和<code>strcmp</code>类似，也是基于字符的ASCII码值进行比较。如果在比较的前<code>n</code>个字符中，<code>s1</code>中的字符的ASCII 码值小于<code>s2</code>中的相应字符的 ASCII码值，那么<code>strncmp</code>返回一个负整数；如果<code>s1</code>中的字符的ASCII 码值大于<code>s2</code>中的相应字符的 ASCII码值，那么<code>strncmp</code>返回一个正整数；如果前<code>n</code>个字符完全相同，则返回0。</li></ul></li><li><p><strong>使用示例</strong></p><ul><li><p><strong>strcmp 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is equal to s2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，因为<code>apple</code>的第一个字符<code>a</code>的ASCII 码值小于<code>banana</code>的第一个字符<code>b</code>的 ASCII码值，所以<code>strcmp(s1, s2)</code>返回一个负整数，程序输出<code>s1 is less than s2</code>。</p></li><li><p><strong>strncmp 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;abcghi&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">strncmp</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2 (first 3 characters)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2 (first 3 characters)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is equal to s2 (first 3 characters)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里比较了<code>s1</code>和<code>s2</code>的前 3 个字符，因为这 3个字符（<code>abc</code>）完全相同，所以<code>strncmp(s1, s2, 3)</code>返回0，程序输出<code>s1 is equal to s2 (first 3 characters)</code>。</p></li></ul></li><li><p><strong>区别和注意事项</strong></p><ul><li><strong>比较范围</strong>：<ul><li><strong>strcmp</strong>：会比较两个字符串的全部内容，直到遇到字符串结束符'\0'。这意味着它会考虑两个字符串的完整长度来判断是否相等或大小关系。</li><li><strong>strncmp</strong>：只比较指定的前<code>n</code>个字符，不考虑字符串后面部分的内容。这种比较方式在只需要关注字符串开头部分是否相同的情况下非常有用，例如比较文件名的前缀或者协议头的部分内容。</li></ul></li><li><strong>返回值用途</strong>：<ul><li><strong>strcmp</strong>：常用于判断两个完整的字符串是否完全相同。例如，在验证用户输入的密码和存储的密码是否一致时，可以使用<code>strcmp</code>。</li><li><strong>strncmp</strong>：可以用于在不需要比较完整字符串的情况下，快速判断部分字符是否相同。比如，在搜索文件系统中以特定前缀开头的文件时，可以使用<code>strncmp</code>来比较文件名的前缀部分。</li></ul></li><li><strong>安全性和边界情况</strong>：<ul><li><strong>strcmp</strong>：如果两个字符串没有正确地以 '\0'结束，可能会导致比较结果错误或者程序出现异常行为，因为它会一直比较下去，直到遇到'\0'。</li><li><strong>strncmp</strong>：虽然只比较前<code>n</code>个字符，但也需要注意<code>n</code>的取值。如果<code>n</code>大于字符串的长度，可能会导致访问越界的风险，因为它会尝试读取超出字符串实际长度的字符。同时，如果<code>n</code>取值过小，可能无法得到想要的比较结果。</li></ul></li></ul></li></ol><h3 id="strchr-与-strrchr">strchr 与 strrchr</h3><ol type="1"><li><p><strong>含义</strong></p><ul><li><strong>strchr</strong>：是 C语言中的字符串处理函数，其函数原型为<code>char* strchr(const char* s, int c)</code>。它的主要功能是在字符串<code>s</code>中查找字符<code>c</code>第一次出现的位置。返回值是一个指向字符<code>c</code>在字符串<code>s</code>中第一次出现位置的指针，如果字符串<code>s</code>中不存在字符<code>c</code>，则返回<code>NULL</code>。这里的字符<code>c</code>可以是普通字符，也可以是字符串结束符<code>'\0'</code>。</li><li><strong>strrchr</strong>：也是一个用于字符串查找的函数，函数原型是<code>char* strrchr(const char* s, int c)</code>。它与<code>strchr</code>不同的是，<code>strrchr</code>是在字符串<code>s</code>中查找字符<code>c</code>最后一次出现的位置。返回值同样是一个指向字符<code>c</code>在字符串<code>s</code>中最后一次出现位置的指针，若未找到则返回<code>NULL</code>。</li></ul></li><li><p><strong>使用示例</strong></p><ul><li><p><strong>strchr 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">      <span class="type">char</span>* ptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;o&#x27;</span>);<span class="comment">//注意有单引号</span></span><br><span class="line"><span class="keyword">if</span> (ptr!= <span class="literal">NULL</span>)<span class="comment">//表示是空指针</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;The first &#x27;o&#x27; is at position %ld\n&quot;</span>, ptr - str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;o&#x27; not found.\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>strchr(str, 'o')</code>会在字符串<code>str</code>（"helloworld"）中查找字符<code>o</code>第一次出现的位置。如果找到，<code>ptr</code>会指向这个位置，通过<code>ptr - str</code>可以计算出字符<code>o</code>在字符串中的位置索引（从0 开始）。在这里，第一个<code>o</code>的位置是4，所以会输出<code>The first 'o' is at position 4</code>。</p></li><li><p><strong>strrchr 示例（C 语言）</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* ptr = <span class="built_in">strrchr</span>(str, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The last &#x27;o&#x27; is at position %ld\n&quot;</span>, ptr - str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;o&#x27; not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>strrchr(str, 'o')</code>，它会在字符串<code>str</code>中查找字符<code>o</code>最后一次出现的位置。在这个例子中，最后一个<code>o</code>的位置是7，所以会输出<code>The last 'o' is at position 7</code>。</p></li></ul></li><li><p><strong>区别与应用场景</strong></p><ul><li><strong>查找方向</strong>：<ul><li><strong>strchr</strong>：是从字符串的开头开始查找，一旦找到目标字符就停止查找并返回指针。这种查找方式适用于需要找到某个字符在字符串中首次出现的情况，比如在解析配置文件时，查找某个参数首次出现的位置，以获取其对应的值。</li><li><strong>strrchr</strong>：是从字符串的末尾开始往前查找，找到目标字符最后一次出现的位置后返回指针。例如，在处理文件路径时，可能需要找到最后一个目录分隔符（如<code>/</code>或<code>\</code>）的位置，以便提取文件名部分，这时<code>strrchr</code>就非常有用。</li></ul></li><li><strong>应用场景举例</strong>：<ul><li><strong>strchr</strong>：在处理文本文件中的命令行格式内容时，如果命令格式是<code>command -option value</code>，可以使用<code>strchr</code>来查找<code>-</code>首次出现的位置，从而确定命令选项的开始位置。</li><li><strong>strrchr</strong>：当处理 URL时，比如<code>https://example.com/path/to/file.html</code>，可以使用<code>strrchr</code>来找到最后一个<code>/</code>的位置，进而提取出文件名<code>file.html</code>。</li></ul></li></ul></li></ol><h3 id="strstr">strstr</h3><ol type="1"><li><p><strong>函数定义与功能</strong></p><ul><li><strong>strstr</strong>是 C语言中的一个字符串处理函数，函数原型为<code>char* strstr(const char* haystack, const char* needle)</code>。它的主要作用是在字符串<code>haystack</code>中查找第一次出现字符串<code>needle</code>的位置。</li><li>如果找到了<code>needle</code>，则返回一个指向<code>haystack</code>中<code>needle</code>首次出现位置的指针；如果<code>needle</code>为空字符串，则返回<code>haystack</code>本身；如果在<code>haystack</code>中没有找到<code>needle</code>，则返回<code>NULL</code>。</li></ul></li><li><p><strong>使用示例</strong></p><ul><li><p><strong>示例一：简单查找子串</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> haystack[] = <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> needle[] = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">strstr</span>(haystack, needle);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Substring found at position %ld\n&quot;</span>, result - haystack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Substring not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>strstr(haystack, needle)</code>会在<code>haystack</code>（"Thisis a teststring"）中查找<code>needle</code>（"test"）第一次出现的位置。如果找到，<code>result</code>会指向这个位置，通过<code>result - haystack</code>可以计算出子串在原字符串中的位置索引（从0 开始）。在这里，子串 "test" 的位置是10，所以会输出<code>Substring found at position 10</code>。</p></li><li><p><strong>示例二：空字符串作为查找内容</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> haystack[] = <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> needle[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">strstr</span>(haystack, needle);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty substring found, and the pointer is: %p\n&quot;</span>, (<span class="type">void</span>*)result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Substring not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当<code>needle</code>为空字符串时，按照函数定义，<code>strstr</code>会返回<code>haystack</code>本身。这里会输出<code>Empty substring found, and the pointer is: 0x7ffee7c0</code>（地址值可能因运行环境不同而不同）。</p></li></ul></li><li><p><strong>应用场景</strong></p><ul><li><strong>文本处理与搜索</strong>：在文本编辑器或者文档处理软件中，可以使用<code>strstr</code>来实现查找功能。例如，在一个长篇文档中查找特定的单词或者短语，确定它们在文档中的位置，方便后续的编辑操作，如替换、标记等。</li><li><strong>数据解析</strong>：在解析网络协议、配置文件等数据格式时，<code>strstr</code>可以帮助查找特定的关键字或者标签。比如，在解析HTML文件时，通过查找<code>&lt;body&gt;</code>标签来定位文档主体部分的开始位置，或者查找特定的CSS 类名来提取对应的样式信息。</li><li><strong>代码文本分析</strong>：在代码格式化工具或者代码审查工具中，<code>strstr</code>可以用于查找特定的代码结构或者关键字。例如，在C/C++代码中查找函数定义的位置，通过查找<code>&#123;</code>和<code>&#125;</code>来确定函数体的范围，或者查找特定的头文件引用等。</li></ul></li></ol><h3 id="strtok">strtok</h3><ol type="1"><li><strong>函数定义与原理</strong><ul><li><strong>strtok</strong>是 C语言中用于字符串分割的函数，函数原型为<code>char* strtok(char* str, const char* delimiters)</code>。</li><li>它的工作原理是在字符串<code>str</code>中根据<code>delimiters</code>指定的分隔符来分割字符串。第一次调用<code>strtok</code>时，它会在<code>str</code>中查找第一个非分隔符字符，然后从这个字符开始，查找下一个分隔符，将分隔符替换为<code>'\0'</code>，并返回指向这个非分隔符字符的指针。后续调用<code>strtok</code>（传递<code>NULL</code>作为第一个参数）时，它会从上次结束的位置继续，在剩余的字符串中继续按照相同的规则进行分割。</li></ul></li><li><strong>使用示例</strong><ul><li><p><strong>简单的字符串分割示例</strong></p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;apple,banana;cherry&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* token = strtok(str, <span class="string">&quot;,;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (token!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,;&quot;</span>);<span class="comment">//从上次结束的位置开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，首先定义了一个包含多种分隔符（<code>,;</code>）的字符串<code>str</code>。第一次调用<code>strtok(str, ",;")</code>时，它会在<code>str</code>中找到第一个非分隔符字符（<code>a</code>），然后找到第一个分隔符（<code>,</code>），将其替换为<code>'\0'</code>，并返回指向<code>apple</code>的指针。在<code>while</code>循环中，每次输出当前的<code>token</code>（即分割后的子字符串），然后再次调用<code>strtok(NULL, ",;")</code>，它会从上次结束的位置（在第一次循环后，是<code>banana;cherry</code>）继续进行分割，直到返回<code>NULL</code>，表示已经分割完所有的子字符串。这个程序会输出：</p><p>收起</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">cherry</span><br></pre></td></tr></table></figure></p></li></ul></li><li><strong>注意事项</strong><ul><li><strong>修改原字符串</strong>：<code>strtok</code>会修改原始字符串，将分隔符替换为<code>'\0'</code>，这在某些情况下可能会影响原始数据的完整性。如果不希望修改原始字符串，可以先复制一份再进行分割操作。</li><li><strong>多线程环境</strong>：<code>strtok</code>不是线程安全的。在多线程环境下，如果多个线程同时调用<code>strtok</code>，可能会导致不可预测的结果。如果需要在多线程环境下进行字符串分割，可以考虑使用可重入的替代函数，如<code>strtok_r</code>（在一些系统中提供）。</li><li><strong>分隔符字符串的处理</strong>：分隔符字符串中的每个字符都被视为独立的分隔符。例如，在上面的示例中，<code>,;</code>表示字符串可以被逗号或者分号分割。</li></ul></li><li><strong>应用场景</strong><ul><li><strong>命令行参数解析</strong>：在处理命令行输入的程序中，<code>strtok</code>可以用于将命令行字符串分割成各个参数。例如，对于命令<code>cp file1.txt file2.txt</code>，可以使用<code>strtok</code>将其分割为<code>cp</code>、<code>file1.txt</code>和<code>file2.txt</code>，以便进一步处理每个参数。</li><li><strong>文本数据提取</strong>：在处理文本文件，如CSV（逗号分隔值）文件时，<code>strtok</code>可以用于提取每一列的数据。例如，对于一行CSV数据<code>"John,Doe,30"</code>，可以使用<code>strtok</code>将其分割为<code>John</code>、<code>Doe</code>和<code>30</code>，方便后续的数据存储和处理。</li></ul></li></ol><h2 id="函数所在标准库必看">函数所在标准库（必看）</h2><ol type="1"><li><strong><code>&lt;string.h&gt;</code>库</strong><ul><li><strong>strlen</strong>、<strong>strcpy</strong>、<strong>strncpy</strong>、<strong>strcat</strong>、<strong>strncat</strong>、<strong>strcmp</strong>、<strong>strncmp</strong>、<strong>strchr</strong>、<strong>strrchr</strong>、<strong>strstr</strong>、<strong>strtok</strong>这些函数都在C语言的<code>&lt;string.h&gt;</code>标准库中。这个库提供了一系列用于处理C 风格字符串（以<code>'\0'</code>结尾的字符数组）的函数。</li><li>例如，在 C程序中，如果要使用<code>strcpy</code>函数来复制字符串，需要在代码开头包含<code>#include &lt;string.h&gt;</code>头文件，这样编译器才能找到<code>strcpy</code>函数的定义并正确地编译程序。</li></ul></li><li><strong><code>&lt;stdio.h&gt;</code>库</strong><ul><li><strong>sprintf</strong>和<strong>sscanf</strong>函数在 C语言的<code>&lt;stdio.h&gt;</code>标准库中。这个库主要用于输入 /输出操作，<code>sprintf</code>和<code>sscanf</code>函数在一定程度上与格式化的输入输出有关。<code>sprintf</code>用于将格式化的数据写入字符串，<code>sscanf</code>用于从字符串中读取并解析格式化的数据，它们的功能和<code>printf</code>、<code>scanf</code>类似，只是操作对象是字符串而不是标准输入输出设备。</li><li>同样，在使用<code>sprintf</code>或<code>sscanf</code>函数时，需要在程序开头包含<code>#include &lt;stdio.h&gt;</code>头文件，以确保程序能够正确调用这些函数。</li></ul></li></ol><h1 id="文件">文件</h1><h2 id="读写函数">读写函数</h2><h3 id="fputc-fgetc">fputc fgetc</h3><ol type="1"><li><strong><code>fputc</code>函数</strong><ul><li><strong>函数原型</strong>：<code>int fputc(int c, FILE *stream);</code></li><li><strong>功能描述</strong>：<ul><li>将字符<code>c</code>写入到指定的文件流<code>stream</code>中。其中<code>c</code>是要写入的字符（可以是一个字符常量或字符变量），<code>stream</code>是指向<code>FILE</code>类型的指针，它表示一个文件流，通常是通过<code>fopen</code>函数打开文件后返回的文件指针。</li></ul></li><li><strong>返回值</strong>：<ul><li>如果写入成功，返回写入的字符（即参数<code>c</code>的值）。</li><li>如果发生错误，返回<code>EOF</code>（<code>EOF</code>是在<code>&lt;stdio.h&gt;</code>头文件中定义的一个常量，通常值为- 1）。</li></ul></li><li><strong>示例</strong>：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = fputc(ch, fp);</span><br><span class="line">    <span class="keyword">if</span> (result == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error writing to file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    eclse</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;%c&#x27; written successfully.\n&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，首先打开一个名为<code>test.txt</code>的文件（如果文件不存在则创建，如果存在则截断内容），然后使用<code>fputc</code>函数将字符<code>'A'</code>写入文件。最后关闭文件。如果写入过程中出现错误，<code>fputc</code>会返回<code>EOF</code>，程序会输出错误信息；如果写入成功，会输出成功信息。</li></ul><ol start="2" type="1"><li><strong><code>fgetc</code>函数</strong><ul><li><strong>函数原型</strong>：<code>int fgetc(FILE *stream);</code></li><li><strong>功能描述</strong>：<ul><li>从指定的文件流<code>stream</code>中读取一个字符。它会返回读取到的字符（以<code>int</code>类型返回，因为<code>EOF</code>也是一个特殊的返回值，<code>EOF</code>的值不能和任何有效的字符值混淆，所以使用<code>int</code>类型来接收返回值）。</li></ul></li><li><strong>返回值</strong>：<ul><li>如果读取成功，返回读取到的字符（其值范围是 0 - 255，表示 ASCII码值）。</li><li>如果到达文件末尾或者发生错误，返回<code>EOF</code>。</li></ul></li><li><strong>示例</strong>：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = fgetc(fp);</span><br><span class="line">    <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (feof(fp))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;End of file reached.\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          perror(<span class="string">&quot;cError reading file&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Character read: %c\n&quot;</span>, (<span class="type">char</span>)ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，首先尝试打开一个名为<code>test.txt</code>的文件用于读取。然后使用<code>fgetc</code>函数从文件中读取一个字符。如果读取到的是<code>EOF</code>，会进一步判断是因为到达文件末尾（使用<code>feof</code>函数判断）还是发生错误。如果读取成功，则输出读取到的字符。最后关闭文件。</li><li><h3 id="fputs-fgets">fputs fgets</h3></li></ul><ol type="1"><li><strong><code>fputs</code>函数</strong><ul><li><strong>函数原型</strong>：<code>int fputs(const char *str, FILE *stream);</code></li><li><strong>功能描述</strong>：<ul><li>用于将一个字符串<code>str</code>写入到指定的文件流<code>stream</code>中。这里的字符串<code>str</code>以空字符<code>'\0'</code>作为结束标志，但<code>fputs</code>函数不会将空字符写入文件。它是顺序写入，从字符串的第一个字符开始，直到遇到<code>'\0'</code>结束。</li></ul></li><li><strong>返回值</strong>：<ul><li>如果写入成功，返回一个非负整数。</li><li>如果发生错误，返回<code>EOF</code>。</li></ul></li><li><strong>示例</strong>：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fputs</span>(str, fp);</span><br><span class="line">    <span class="keyword">if</span> (result == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error writing to file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elsec</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;String written successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，首先打开一个文件<code>test.txt</code>用于写入。然后使用<code>fputs</code>函数将字符串<code>"Hello, World!"</code>写入文件。如果写入过程没有错误，会输出成功信息；如果出现错误，则会输出错误信息。最后关闭文件。</li></ul><ol start="2" type="1"><li><strong><code>fgets</code>函数</strong><ul><li><strong>函数原型</strong>：<code>char *fgets(char *str, int n, FILE *stream);</code></li><li><strong>功能描述</strong>：<ul><li>从指定的文件流<code>stream</code>中读取最多<code>n - 1</code>个字符，并将它们存储到字符数组<code>str</code>中。读取过程会在遇到换行符<code>'\n'</code>、文件末尾或者已经读取了<code>n - 1</code>个字符时停止。最后会在读取的字符数组末尾添加一个空字符<code>'\0'</code>，以形成一个有效的C 字符串。</li></ul></li><li><strong>返回值</strong>：<ul><li>如果读取成功，返回指向字符数组<code>str</code>的指针。</li><li>如果遇到文件末尾且没有读取到任何字符，返回<code>NULL</code>。</li><li>如果发生错误，返回<code>NULL</code>。</li></ul></li><li><strong>示例</strong>：</li></ul></li></ol><p>c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *result = fgets(str, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (feof(fp))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;End of file reached.\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;String read: %s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，首先打开一个文件<code>test.txt</code>用于读取。然后使用<code>fgets</code>函数从文件中读取最多99个字符（因为要预留一个位置给空字符<code>'\0'</code>）到字符数组<code>str</code>中。如果读取成功，会输出读取到的字符串；如果遇到文件末尾或者发生错误，会根据具体情况输出相应的信息。最后关闭文件。</li></ul><h3 id="fprintf-fscanf">fprintf fscanf</h3><ol type="1"><li>. <strong><code>fprintf</code>函数</strong><ul><li><strong>函数原型</strong>：<code>int fprintf(FILE *stream, const char *format,...);</code></li><li><strong>功能描述</strong><ul><li>将格式化的数据输出到指定的文件流<code>stream</code>中。<code>format</code>参数是格式化字符串，与<code>printf</code>函数的格式化字符串类似，用于指定输出数据的格式。<code>...</code>表示可变参数列表，包含要输出的数据。例如，可以使用<code>%d</code>输出整数，<code>%f</code>输出浮点数，<code>%s</code>输出字符串等格式。</li></ul></li><li><strong>返回值</strong><ul><li>成功写入的字符数（不包括结束符<code>'\0'</code>）。如果出现错误，返回一个负数。</li></ul></li><li><strong>示例</strong></li></ul></li></ol><p>c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> fnum = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Number: %d, Float number: %.2f, String: %s\n&quot;</span>, num, fnum, str);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error writing to file&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data written successfully. %d characters written.\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，打开一个名为<code>output.txt</code>的文件用于写入。然后使用<code>fprintf</code>函数将变量<code>num</code>（整数）、<code>fnum</code>（浮点数）和<code>str</code>（字符串）按照指定的格式输出到文件中。根据<code>fprintf</code>的返回值判断写入是否成功。最后关闭文件。</li></ul><ol start="2" type="1"><li><strong><code>fscanf</code>函数</strong><ul><li><strong>函数原型</strong>：<code>int fscanf(FILE *stream, const char *format,...);</code></li><li><strong>功能描述</strong><ul><li>从指定的文件流<code>stream</code>中按照<code>format</code>指定的格式读取数据。<code>format</code>参数是一个格式化字符串，与<code>scanf</code>函数的格式化字符串类似，用于指定读取数据的类型和格式。例如，<code>%d</code>用于读取整数，<code>%f</code>用于读取浮点数，<code>%s</code>用于读取字符串等。<code>...</code>表示可变参数列表，用于接收从文件中读取的数据并存储到相应的变量中。</li></ul></li><li><strong>返回值</strong><ul><li>成功读取的输入项的数目。如果在读取任何数据之前到达文件末尾，则返回<code>EOF</code>。如果读取过程中出现错误，返回值是不确定的，可能小于预期读取的项数。</li></ul></li><li><strong>示例</strong></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> fnum;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d %f %s&quot;</span>, &amp;num, &amp;fnum, str);</span><br><span class="line">    <span class="keyword">if</span> (result == EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;End of file reached before any data was read.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data read successfully: num = %d, fnum = %.2f, str = %s\n&quot;</span>, num, fnum, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Partial data read. Expected 3 items, but read %d.\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，假设<code>data.txt</code>文件中包含一行数据，格式为“整数 浮点数字符串”。通过<code>fscanf</code>函数从文件中读取数据到变量<code>num</code>（整数）、<code>fnum</code>（浮点数）和<code>str</code>（字符串）中。根据<code>fscanf</code>的返回值来判断读取是否成功以及读取的完整程度。最后关闭文件。</li></ul><h2 id="文件定位">文件定位</h2><h3 id="feof">feof</h3><ol type="1"><li><strong>函数原型</strong><ul><li><code>int feof(FILE *stream);</code></li></ul></li><li><strong>功能描述</strong><ul><li><p><code>feof</code>函数用于检测文件流<code>stream</code>是否到达了文件末尾。它通过检查文件结束标志来判断。当文件读取操作已经尝试读取超过文件的最后一个字节时，文件结束标志会被设置，此时<code>feof</code>函数会返回一个非零值（通常为1），表示已经到达文件末尾。</p></li><li><p>例如，在循环读取文件内容时，当<code>fgetc</code>或者<code>fgets</code>等读取函数返回<code>EOF</code>（文件结束符，在<code>&lt;stdio.h&gt;</code>中定义，通常值为-1）时，不能简单地认为就是到达了文件末尾。因为<code>EOF</code>也可能是由于读取错误而返回的。这时就需要使用<code>feof</code>函数来进一步确认是否真的是到达了文件末尾。如果<code>feof</code>返回非零值，那就是到达文件末尾；如果<code>feof</code>返回0，那可能是读取过程中出现了错误。</p></li></ul></li><li><strong>示例</strong><ul><li>以下是一个简单的示例，用于读取一个文本文件的内容，直到到达文件末尾。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环读取文件内容</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(fp))!= EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否是因为到达文件末尾而结束读取</span></span><br><span class="line">    <span class="keyword">if</span> (feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\nEnd of file reached.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，首先打开文件<code>test.txt</code>用于读取。然后通过一个<code>while</code>循环使用<code>fgetc</code>函数逐个字符地读取文件内容，并将读取到的字符输出到控制台。当<code>fgetc</code>返回<code>EOF</code>时，循环结束。接着使用<code>feof</code>函数来检查是否是因为到达文件末尾而结束读取。如果是，就输出相应的提示信息；如果不是，就输出读取错误的提示信息。最后关闭文件。</li></ul><ol start="4" type="1"><li><strong>需要注意的地方</strong><ul><li>只有在尝试读取文件结束后的位置时，<code>feof</code>函数才会返回非零值。也就是说，在最后一次成功读取之后，文件结束标志还没有被设置。当读取函数返回<code>EOF</code>后，再调用<code>feof</code>函数才能正确判断是否到达文件末尾。</li><li>不能仅仅依靠<code>feof</code>来控制文件读取的循环，因为如果文件一开始就是空文件，<code>feof</code>函数在还没有进行任何读取操作时是不会返回非零值的。所以通常是结合读取函数（如<code>fgetc</code>或<code>fgets</code>）的返回值和<code>feof</code>函数来准确地判断文件读取的状态。</li></ul></li></ol><h3 id="fseek">fseek</h3><ol type="1"><li><strong>函数原型</strong><ul><li><code>int fseek(FILE *stream, long int offset, int whence);</code></li></ul></li><li><strong>参数含义</strong><ul><li><strong><code>stream</code></strong>：这是一个指向<code>FILE</code>类型的指针，表示已经打开的文件流。例如，通过<code>fopen</code>函数打开文件后得到的文件指针。</li><li><strong><code>offset</code></strong>：这是一个长整型的值，表示相对于<code>whence</code>位置的偏移量。它可以是正数、负数或者零。如果是正数，表示向文件末尾方向移动；如果是负数，表示向文件开头方向移动。</li><li><strong><code>whence</code></strong>：这是一个整型常量，用于指定偏移量<code>offset</code>的起始位置。它有以下三个可能的值：<ul><li><strong><code>SEEK_SET</code>（0）</strong>：文件开头。此时<code>offset</code>是从文件开头开始计算的字节数。例如，如果<code>offset</code>为0，那么文件指针将定位到文件的第一个字节；如果<code>offset</code>为5，文件指针将定位到文件的第 6 个字节（因为字节索引从 0 开始）。</li><li><strong><code>SEEK_CUR</code>（1）</strong>：文件当前位置。<code>offset</code>是相对于当前文件指针位置的字节数。例如，如果当前文件指针在第10 个字节处，<code>offset</code>为 3，那么文件指针将移动到第 13个字节处。</li><li><strong><code>SEEK_END</code>（2）</strong>：文件末尾。<code>offset</code>是相对于文件末尾的字节数。需要注意的是，当<code>offset</code>为0 时，文件指针将定位到文件的最后一个字节；如果<code>offset</code>为 -5，文件指针将定位到倒数第 5 个字节。</li></ul></li></ul></li><li><strong>功能描述</strong><ul><li><code>fseek</code>函数主要用于移动文件内部的读写指针。通过调整指针的位置，可以实现对文件中任意位置的数据进行读写操作。例如，在处理大型文件时，可能需要跳转到文件中间的某个位置读取特定的数据块，或者在文件末尾添加新的数据之前先将指针移动到文件末尾。</li></ul></li><li><strong>返回值</strong><ul><li>如果成功移动文件指针，<code>fseek</code>函数返回 0。</li><li>如果发生错误，例如试图移动到文件范围之外的位置或者文件不支持定位操作（如某些特殊的管道文件或设备文件），则返回非零值。</li></ul></li><li><strong>示例</strong><ul><li>以下示例展示了如何使用<code>fseek</code>函数。假设存在一个文本文件<code>test.txt</code>，文件内容为“Hello World”。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将文件指针移动到文件的第6个字节（索引为5）</span></span><br><span class="line">    <span class="type">int</span> result = fseek(fp, <span class="number">5</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error seeking in file&quot;</span>);</span><br><span class="line">       fclose(fp);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = fgetc(fp);</span><br><span class="line">    <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (feof(fp))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;End of file reached.\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Character read after seeking: %c\n&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，首先打开文件<code>test.txt</code>用于读取。然后使用<code>fseek</code>函数将文件指针从文件开头（<code>SEEK_SET</code>）移动到第6 个字节（偏移量为5）。如果<code>fseek</code>操作成功，接着使用<code>fgetc</code>函数读取文件指针当前位置的字符，并输出该字符。最后关闭文件。</li></ul><h3 id="rewind">rewind</h3><ol type="1"><li><strong>函数原型</strong><ul><li><code>void rewind(FILE *stream);</code></li></ul></li><li><strong>功能描述</strong><ul><li><code>rewind</code>函数用于将文件指针重新定位到文件的开头。当对一个文件进行了多次读写操作，且读写指针已经移动到文件中的其他位置后，使用<code>rewind</code>函数可以快速地将指针重置，以便重新从文件的开头进行读取或写入操作。</li><li>这个函数实际上等价于<code>fseek(stream, 0L, SEEK_SET)</code>，也就是将文件指针相对于文件开头（<code>SEEK_SET</code>）移动0 个字节，从而达到将文件指针定位到文件起始位置的目的。</li></ul></li><li><strong>示例</strong><ul><li>假设我们有一个文件<code>data.txt</code>，里面包含一些文本内容。以下示例展示了如何先读取一部分内容，然后使用<code>rewind</code>函数重新回到文件开头再次读取。</li></ul></li></ol><p>c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次读取部分内容</span></span><br><span class="line">    fgets(buffer, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First read: %s&quot;</span>, buffer);</span><br><span class="line">    <span class="comment">// 将文件指针重置到文件开头</span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">// 第二次读取部分内容</span></span><br><span class="line">    fgets(buffer, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second read after rewind: %s&quot;</span>, buffer);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，首先打开文件<code>data.txt</code>用于读取。通过<code>fgets</code>函数第一次读取文件中的一部分内容并打印出来。然后使用<code>rewind</code>函数将文件指针重新定位到文件开头。接着再次使用<code>fgets</code>函数读取文件内容并打印，此时读取的内容和第一次开始读取的内容是相同的（如果文件内容没有被修改），这展示了<code>rewind</code>函数将文件指针复位的功能。</li></ul><h1 id="stdlib库中常见函数">stdlib库中常见函数</h1><ol type="1"><li><strong>内存分配与释放相关函数</strong><ul><li><strong>malloc</strong>：<ul><li>功能：用于动态分配指定字节数的内存空间。函数原型为<code>void* malloc(size_t size)</code>，它返回一个指向所分配内存空间起始地址的指针。例如，<code>int* ptr = (int*)malloc(10 * sizeof(int));</code>会分配可以存储10个<code>int</code>类型数据的内存空间，返回的指针需要进行类型转换后存储在<code>ptr</code>中。</li><li>应用场景：当程序运行时不确定需要多少内存来存储数据，比如读取一个文件，文件大小事先未知，就可以使用<code>malloc</code>来动态分配足够的内存空间来存储文件内容。</li></ul></li><li><strong>calloc</strong>：<ul><li>功能：用于动态分配内存空间并将其初始化为0。函数原型是<code>void* calloc(size_t num, size_t size)</code>，它会分配<code>num</code>个大小为<code>size</code>字节的内存块，并将这些内存块的内容初始化为0。例如，<code>float* arr = (float*)calloc(5, sizeof(float));</code>会分配可以存储5 个<code>float</code>类型数据的内存空间，并且这些空间初始化为 0。</li><li>应用场景：在创建数组时，如果希望数组元素初始值为0，使用<code>calloc</code>会很方便。比如在统计数据的程序中，初始化一个计数器数组。</li></ul></li><li><strong>realloc</strong>：<ul><li>功能：用于重新分配已经通过<code>malloc</code>或<code>calloc</code>等函数分配的内存空间的大小。函数原型为<code>void* realloc(void* ptr, size_t size)</code>，它会尝试调整<code>ptr</code>所指向的内存块的大小为<code>size</code>字节。如果调整成功，返回一个指向重新分配后的内存块起始地址的指针；如果无法调整（比如没有足够的连续内存），返回<code>NULL</code>，并且原来的内存块不会被释放。例如，<code>int* new_ptr = (int*)realloc(ptr, 20 * sizeof(int));</code>尝试将<code>ptr</code>指向的内存空间大小调整为可以存储20 个<code>int</code>类型数据的空间。</li><li>应用场景：当程序对数据的需求发生变化，比如需要存储更多的数据时，可以使用<code>realloc</code>来扩展已经分配的内存空间，而不是重新分配一块全新的内存，这样可以避免浪费之前已经存储的数据。</li></ul></li><li><strong>free</strong>：<ul><li>功能：用于释放通过<code>malloc</code>、<code>calloc</code>或<code>realloc</code>等函数分配的内存空间。函数原型为<code>void free(void* ptr)</code>。例如，<code>free(ptr);</code>会释放<code>ptr</code>所指向的内存空间，之后这块内存可以被操作系统重新分配给其他程序或进程使用。</li><li>应用场景：在动态分配的内存不再需要时，必须使用<code>free</code>释放，以避免内存泄漏。比如一个函数中动态分配了内存来存储临时数据，当函数执行完毕，这些内存应该被释放。</li></ul></li></ul></li><li><strong>数值转换函数</strong><ul><li><strong>atoi</strong>：<ul><li>功能：将字符串转换为整数。函数原型为<code>int atoi(const char* str)</code>，它会扫描字符串<code>str</code>，跳过前面的空白字符（空格、制表符、换行符等），然后从第一个非空白字符开始解析整数。如果字符串无法正确解析为整数，返回0。例如，<code>int num = atoi("123");</code>会将字符串<code>"123"</code>转换为整数123。</li><li>应用场景：在处理用户输入或读取配置文件中的数字字符串时很有用。比如用户在命令行输入一个数字作为参数，程序可以使用<code>atoi</code>将这个字符串参数转换为整数进行后续计算。</li></ul></li><li><strong>atol</strong>：<ul><li>功能：将字符串转换为长整数。函数原型为<code>long atol(const char* str)</code>，其工作原理和<code>atoi</code>类似，只是转换的结果是长整数类型。例如，<code>long num = atol("1234567890");</code>会将字符串<code>"1234567890"</code>转换为长整数1234567890。</li><li>应用场景：当需要处理可能超出<code>int</code>范围的整数字符串时可以使用<code>atol</code>，比如处理文件大小等可能是较大整数的情况。</li></ul></li><li><strong>atof</strong>：<ul><li>功能：将字符串转换为浮点数。函数原型为<code>float atof(const char* str)</code>，它会扫描字符串<code>str</code>，跳过空白字符，然后从第一个非空白字符开始解析浮点数。例如，<code>float num = atof("3.14");</code>会将字符串<code>"3.14"</code>转换为浮点数3.14。</li><li>应用场景：在读取包含浮点数信息的文本文件或者用户输入的浮点数字符串时，用于将字符串转换为浮点数进行数学运算。</li></ul></li></ul></li><li><strong>随机数生成相关函数（以 srand 和 rand 为例）</strong><ul><li><strong>srand</strong>：<ul><li>功能：用于初始化随机数生成器。函数原型为<code>void srand(unsigned int seed)</code>，它接受一个无符号整数<code>seed</code>作为种子，不同的种子会导致<code>rand</code>函数（下面介绍）生成不同序列的随机数。例如，<code>srand((unsigned int)time(NULL));</code>使用当前时间作为种子来初始化随机数生成器，这样每次程序运行时由于时间不同，生成的随机数序列也会不同。</li><li>应用场景：在需要生成伪随机数的程序中，如游戏中的随机事件（怪物掉落物品的概率、随机地图生成等）、模拟实验中的随机样本等场景下，需要先使用<code>srand</code>初始化随机数生成器。</li></ul></li><li><strong>rand</strong>：<ul><li>功能：用于生成伪随机数。函数原型为<code>int rand(void)</code>，它会返回一个介于0和<code>RAND_MAX</code>（一个在<code>&lt;stdlib.h&gt;</code>中定义的常量，通常是一个较大的整数）之间的整数。例如，<code>int random_num = rand();</code>会生成一个随机整数。</li><li>应用场景：结合<code>srand</code>使用，可以在很多需要随机元素的程序中生成随机数。比如在抽奖程序中，使用<code>rand</code>来确定中奖号码；在生成随机测试数据时，使用<code>rand</code>来生成各种数值。</li></ul></li></ul></li><li><strong>程序终止相关函数（以 exit 为例）</strong><ul><li><strong>exit</strong>：<ul><li>功能：用于立即终止程序的执行。函数原型为<code>void exit(int status)</code>，其中<code>status</code>是程序的退出状态码，0表示正常退出，非 0值表示异常退出。例如，<code>exit(0);</code>会正常结束程序，而<code>exit(1);</code>会以错误状态结束程序。</li><li>应用场景：当程序遇到无法恢复的错误，如无法打开关键的配置文件、内存分配失败等情况时，可以使用<code>exit</code>来终止程序，以避免程序继续执行产生不可预测的结果。同时，在一些脚本或简单的命令行工具中，完成任务后可以使用<code>exit</code>正常退出。</li></ul></li></ul></li></ol><h1 id="math库中常见函数">math库中常见函数</h1><h2 id="三角函数相关函数"><strong>三角函数相关函数</strong></h2><ol type="1"><li><ul><li><strong><code>sin</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double sin(double x);</code></li><li><strong>功能描述</strong>：计算弧度为<code>x</code>的正弦值。返回值的范围是<code>[-1,1]</code>。例如，<code>sin(0)</code>返回<code>0</code>，<code>sin(M_PI/2)</code>（假设已经定义了<code>M_PI</code>为圆周率<code>π</code>的值）返回<code>1</code>。</li></ul></li></ul></li><li><ul><li><strong><code>cos</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double cos(double x);</code></li><li><strong>功能描述</strong>：计算弧度为<code>x</code>的余弦值。返回值范围也是<code>[-1,1]</code>。例如，<code>cos(0)</code>返回<code>1</code>，<code>cos(M_PI)</code>返回 <code>- 1</code>。</li></ul></li></ul></li><li><ul><li><strong><code>tan</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double tan(double x);</code></li><li><strong>功能描述</strong>：计算弧度为<code>x</code>的正切值。当<code>x</code>是<code>π/2 + kπ</code>（<code>k</code>为整数）时，函数值趋近于无穷大，此时可能会产生溢出等错误。例如，<code>tan(M_PI/4)</code>返回<code>1</code>。</li><li><h2id="反三角函数相关函数"><strong>反三角函数相关函数</strong></h2></li></ul></li></ul></li><li><ul><li><strong><code>asin</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double asin(double x);</code></li><li><strong>功能描述</strong>：计算<code>x</code>的反正弦值，返回值的范围是<code>[-π/2,π/2]</code>。<code>x</code>的取值范围是<code>[-1,1]</code>，如果<code>x</code>不在这个范围内，函数会产生定义域错误。例如，<code>asin(0.5)</code>返回约<code>0.5236</code>（弧度，即<code>π/6</code>）。</li></ul></li></ul></li><li><ul><li><strong><code>acos</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double acos(double x);</code></li><li><strong>功能描述</strong>：计算<code>x</code>的反余弦值，返回值范围是<code>[0,π]</code>。<code>x</code>的取值范围是<code>[-1,1]</code>。例如，<code>acos(0.5)</code>返回约<code>1.0472</code>（弧度，即<code>π/3</code>）。</li></ul></li></ul></li><li><ul><li><strong><code>atan</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double atan(double x);</code></li><li><strong>功能描述</strong>：计算<code>x</code>的反正切值，返回值范围是<code>(-π/2,π/2)</code>。例如，<code>atan(1)</code>返回约<code>0.7854</code>（弧度，即<code>π/4</code>）。</li></ul></li></ul></li><li><ul><li><strong><code>atan2</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double atan2(double y, double x);</code></li><li><strong>功能描述</strong>：计算<code>y/x</code>的反正切值，但它会考虑<code>x</code>和<code>y</code>的符号来确定正确的象限。返回值范围是<code>(-π,π]</code>。这个函数在计算向量的角度等场景中非常有用，例如，<code>atan2(1,1)</code>返回约<code>0.7854</code>（弧度，即<code>π/4</code>）。</li><li><h2 id="指数和对数函数"><strong>指数和对数函数</strong></h2></li></ul></li></ul></li><li><ul><li><strong><code>exp</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double exp(double x);</code></li><li><strong>功能描述</strong>：计算自然常数<code>e</code>（约为<code>2.71828</code>）的<code>x</code>次幂。例如，<code>exp(1)</code>返回<code>e</code>的值，<code>exp(0)</code>返回<code>1</code>。</li></ul></li></ul></li><li><ul><li><strong><code>log</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double log(double x);</code></li><li><strong>功能描述</strong>：计算以自然常数<code>e</code>为底<code>x</code>的对数。<code>x</code>必须大于<code>0</code>，否则会产生定义域错误。例如，<code>log(exp(1))</code>返回<code>1</code>。</li></ul></li></ul></li><li><ul><li><strong><code>log10</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double log10(double x);</code></li><li><strong>功能描述</strong>：计算以<code>10</code>为底<code>x</code>的对数。<code>x</code>同样必须大于<code>0</code>。例如，<code>log10(100)</code>返回<code>2</code>。## <strong>幂函数和开方函数</strong></li></ul></li></ul></li><li><ul><li><strong><code>pow</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double pow(double x, double y);</code></li><li><strong>功能描述</strong>：计算<code>x</code>的<code>y</code>次幂。例如，<code>pow(2,3)</code>计算<code>2</code>的<code>3</code>次方，返回<code>8</code>。需要注意的是，当<code>x</code>为负数且<code>y</code>不是整数时，结果可能是复数，在这种情况下可能会产生错误或者不符合预期的结果。</li></ul></li></ul></li><li><ul><li><strong><code>sqrt</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double sqrt(double x);</code></li><li><strong>功能描述</strong>：计算<code>x</code>的平方根。<code>x</code>必须大于等于<code>0</code>，否则会产生定义域错误。例如，<code>sqrt(4)</code>返回<code>2</code>。</li><li><h2id="绝对值和取整函数等辅助函数"><strong>绝对值和取整函数等辅助函数</strong></h2></li></ul></li></ul></li><li><ul><li><strong><code>fabs</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double fabs(double x);</code></li><li><strong>功能描述</strong>：计算实数<code>x</code>的绝对值。例如，<code>fabs(-3.14)</code>返回<code>3.14</code>。</li></ul></li></ul></li><li><ul><li><strong><code>ceil</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double ceil(double x);</code></li><li><strong>功能描述</strong>：向上取整函数，返回不小于<code>x</code>的最小整数。例如，<code>ceil(3.14)</code>返回<code>4</code>，<code>ceil(-3.14)</code>返回 <code>- 3</code>。</li></ul></li></ul></li><li><ul><li><strong><code>floor</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double floor(double x);</code></li><li><strong>功能描述</strong>：向下取整函数，返回不大于<code>x</code>的最大整数。例如，<code>floor(3.14)</code>返回<code>3</code>，<code>floor(-3.14)</code>返回 <code>- 4</code>。</li></ul></li></ul></li><li><ul><li><strong><code>round</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double round(double x);</code></li><li><strong>功能描述</strong>：将<code>x</code>四舍五入到最接近的整数。例如，<code>round(3.4)</code>返回<code>3</code>，<code>round(3.6)</code>返回<code>4</code>。</li></ul></li></ul></li><li><strong><code>fmod</code>函数</strong><ul><li><strong>函数原型</strong>：<code>double fmod(double x, double y);</code></li><li><strong>功能描述</strong>：<ul><li>该函数用于计算<code>x</code>除以<code>y</code>的浮点数余数。它与整数取余运算<code>%</code>在浮点数环境下的功能类似，但<code>%</code>通常用于整数运算，而<code>fmod</code>用于双精度浮点数运算。</li><li>计算结果的符号与<code>x</code>的符号相同。例如，<code>fmod(7.5, 2.0)</code>的结果是<code>1.5</code>，因为<code>7.5</code>除以<code>2.0</code>商为<code>3</code>，余数为<code>1.5</code>；<code>fmod(-7.5, 2.0)</code>的结果是<code>-1.5</code>，这是因为计算过程是<code>-7.5 = -4*2.0+(-1.5)</code>。</li></ul></li><li><strong>应用场景示例</strong>：<ul><li>在周期性的计算中很有用。比如在计算角度的周期性变化时，假设有一个角度变量<code>theta</code>，它的取值范围应该是<code>[0, 2*PI)</code>（以弧度为单位），如果<code>theta</code>的值超过了这个范围，可以使用<code>fmod</code>函数来将其调整回这个范围内。</li></ul></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265358979323846</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> angle = <span class="number">7.0</span> * PI;</span><br><span class="line">    <span class="type">double</span> adjusted_angle = <span class="built_in">fmod</span>(angle, <span class="number">2</span> * PI);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始角度: %lf\n&quot;</span>, angle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调整后的角度: %lf\n&quot;</span>, adjusted_angle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个示例中，首先定义了一个角度<code>angle</code>，它的值大于<code>2*PI</code>。然后使用<code>fmod</code>函数将其调整到<code>[0, 2*PI)</code>范围内，这对于处理周期性的角度变化（如在三角函数相关的计算中）是非常有用的。</li></ul><h1 id="函数题练习">函数题练习</h1><h1 id="编程题练习">编程题练习</h1><h2 id="大笨钟">7-10 大笨钟</h2><p>微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。</p><p>下面就请你写个程序，根据当前时间替大笨钟敲钟。</p><h3 id="输入格式">输入格式：</h3><p>输入第一行按照<code>hh:mm</code>的格式给出当前时间。其中<code>hh</code>是小时，在00到23之间；<code>mm</code>是分钟，在00到59之间。</p><h3 id="输出格式">输出格式：</h3><p>根据当前时间替大笨钟敲钟，即在一行中输出相应数量个<code>Dang</code>。如果不是敲钟期，则输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Only</span> hh:mm.  Too early <span class="keyword">to</span> Dang.</span><br></pre></td></tr></table></figure><p>其中<code>hh:mm</code>是输入的时间。</p><h3 id="输入样例1">输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19:05</span><br></pre></td></tr></table></figure><h3 id="输出样例1">输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DangDangDangDangDangDangDangDang</span><br></pre></td></tr></table></figure><h3 id="输入样例2">输入样例2：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">07</span>:<span class="number">05</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2">输出样例2：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Only</span> <span class="number">07</span>:<span class="number">05</span>.  Too early to Dang.</span><br></pre></td></tr></table></figure><p>code： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> h,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d:%d&quot;</span>,&amp;h,&amp;m);</span><br><span class="line"><span class="keyword">if</span>((h==<span class="number">12</span>&amp;&amp;m!=<span class="number">0</span>)||(h&gt;<span class="number">12</span>&amp;&amp;h&lt;<span class="number">24</span>))<span class="comment">//12点临界值不包括</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h<span class="number">-12</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Dang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Dang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Only %0.2d:%0.2d.  Too early to Dang.&quot;</span>,h,m);<span class="comment">//注意这里的格式化输出%0.2d:%0.2d</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="求整数的位数及各位数字之和">7-19 求整数的位数及各位数字之和</h2><p>对于给定的非负整数N，求它的位数及其各位数字之和。</p><h3 id="输入格式-1">输入格式:</h3><p>输入在一行中给出一个非负整数N。</p><h3 id="输出格式-1">输出格式:</h3><p>在一行中输出N的位数及其各位数字之和，中间用一个空格隔开。</p><h3 id="输入样例">输入样例:</h3><p>在这里给出一组输入。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">321</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例:</h3><p>在这里给出相应的输出。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6</span><br></pre></td></tr></table></figure><p>code: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> num[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len=<span class="built_in">strlen</span>(num);</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">a+=num[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//减去0的ASCII码值完成转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,len,a);</span><br><span class="line">&#125;</span><br><span class="line">                             </span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数期末复习</title>
      <link href="/2025/01/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/01/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<div class="note warning flat"><p>由于前三章为期中考内容,本文较少涉及</p></div><p>前两章内容可以看<strong>伍耀文</strong>同学整理的：</p><p><ahref="https://pan.baidu.com/s/15MrisiuI-YOabIyxM4pKsQ?pwd=qaus">复习资料</a>提取码: qaus</p><p>以下为杭电历年期末试卷：</p><p><ahref="https://pan.baidu.com/s/1srFeirXys95NvtCtkgGK5Q?pwd=p8bf">历年真题</a>提取码: p8bf</p><h1 id="第1章">第1章</h1><h2 id="沙路法萨吕法则适用范围">沙路法（萨吕法则）适用范围</h2><div class="note warning flat"><p>三阶以上行列式不适用</p></div><p><a href="http://www.shuxueji.com/w/48891">萨吕法则-数学百科(shuxueji.com)</a></p><h1 id="第2章">第2章</h1><h2 id="矩阵的秩">矩阵的秩</h2><p><span class="math display">\[定理2 若  \boldsymbol{A} \sim\boldsymbol{B}  ，则  R(\boldsymbol{A})=R(\boldsymbol{B})（充要条件）\]</span> <span class="math display">\[（1）  0 \leq R\left(\boldsymbol{A}_{m \times n}\right) \leq \min \{m,n\} \]</span> <span class="math display">\[（2） R\left(\boldsymbol{A}^{T}\right)=R(\boldsymbol{A}) \]</span> <spanclass="math display">\[（3）若  \boldsymbol{A} \sim\boldsymbol{B}  ，则  R(\boldsymbol{A})=R(\boldsymbol{B}) \]</span><span class="math display">\[（4）若  \boldsymbol{P}, \boldsymbol{Q}  可逆，则  R(\boldsymbol{P}\boldsymbol{A} \boldsymbol{Q})=R(\boldsymbol{A}) \]</span> <spanclass="math display">\[（5）  \max \{R(\boldsymbol{A}),R(\boldsymbol{B})\} \leq R(\boldsymbol{A}, \boldsymbol{B}) \leqR(\boldsymbol{A})+R(\boldsymbol{B}) \]</span> <spanclass="math display">\[（6） R(\boldsymbol{A}+\boldsymbol{B}) \leqR(\boldsymbol{A})+R(\boldsymbol{B}) \]</span> <spanclass="math display">\[（7） R(\boldsymbol{A B}) \leq \min\{R(\boldsymbol{A}), R(\boldsymbol{B})\} \]</span> <spanclass="math display">\[（8）若  \boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \timesl}=\boldsymbol{O}  ，则  R(\boldsymbol{A})+R(\boldsymbol{B}) \leq n\]</span></p><h2 id="易忘记的计算公式">易忘记的计算公式</h2><p><span class="math display">\[AA^{*} =A^{*}A=\left |A  \right |E\]</span></p><h1 id="第3章-矩阵的初等变换与线性方程组">第3章矩阵的初等变换与线性方程组</h1><h2 id="初等矩阵">初等矩阵</h2><p>初等矩阵是指由单位矩阵经过<strong>一次</strong><ahref="https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400?fromModule=lemma_inlink">初等变换</a>得到的矩阵，矩阵的初等变换是矩阵的一种最基本的运算。</p><p><ahref="https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400?fromModule=lemma_inlink">初等变换</a>有三种 [2]</p><p>（1）交换矩阵中某两行（列）的位置；</p><p>（2）用一个非零常数k乘以矩阵的某一行（列）；</p><p>（3）将矩阵的某一行（列）乘以常数k后加到另一行（列）上去。</p><p>三类初等矩阵都是<ahref="https://baike.baidu.com/item/%E5%8F%AF%E9%80%86%E7%9F%A9%E9%98%B5/0?fromModule=lemma_inlink">可逆矩阵</a>，即非奇异阵。</p><div class="note warning flat"><p>初等矩阵相加/相乘不一定为初等矩阵</p></div><h2 id="线性方程组的解">线性方程组的解</h2><p><imgsrc="https://pic1.imgdb.cn/item/677e6c53d0e0a243d4f23978.png" /></p><h1 id="第4章-向量组的线性相关性">第4章 向量组的线性相关性</h1><h2 id="判别向量组的线性相关性">判别向量组的线性相关性</h2><h3 id="数字型">数字型</h3><p>两个向量对应成比例</p><p>多个向量：方阵行列式=0或者矩阵的秩=向量个数</p><div class="note warning flat"><p>个数&gt;维数一定相关</p></div><h3 id="抽象型">抽象型</h3><p>1.抽象向量组的表示方法（逆向思维）：</p><p>eg.</p><p><span class="math display">\[\left(\alpha_{1},\alpha_{4}\right)\left(\begin{array}{ll}1 &amp; 2 \\3 &amp; 4\end{array}\right)=\left(\alpha_{1}+3 \alpha_{2}, 2 \alpha_{1}+4\alpha_{2}\right)\]</span></p><p>2.判断是否可逆</p><p>无关组*可逆阵-&gt;无关</p><p>无关组*不可逆阵-&gt;相关</p><h2 id="基变换公式和坐标变换公式">基变换公式和坐标变换公式</h2><h3 id="基变换公式">基变换公式</h3><p>取旧基为<span class="math inline">\(a_{1}，a_{2}，…，a_{n}\)</span>，新基为<span class="math inline">\(b_{1}，b_{2}，…，b_{n}\)</span>，则<spanclass="math inline">\(B=AP\)</span>(A，B为对应基构成的矩阵)，此式为基变换公式，P为从基<spanclass="math inline">\(a_{1}， a_{2}，…，a_{n}\)</span>到基<spanclass="math inline">\(b_{1}，b_{2}，…，b_{n}\)</span>的<strong>过度矩阵</strong> ,其中 <spanclass="math inline">\(P=A^{-}B\)</span></p><h3 id="坐标变换公式">坐标变换公式</h3><p>定义11 设 <span class="math inline">\(\boldsymbol{a}_{1},\boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{n}\)</span> 与 <spanclass="math inline">\(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots,\boldsymbol{b}_{n}\)</span> 是向量空间 V 的两个基． <spanclass="math inline">\(\forall \boldsymbol{\alpha} \in V\)</span> ，设<span class="math inline">\(\boldsymbol{\alpha}\)</span> 在基 <spanclass="math inline">\(a_{1}, a_{2}, \cdots, a_{n}\)</span> 下的坐标为<span class="math inline">\(\boldsymbol{x}\)</span> ，在基 <spanclass="math inline">\(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots,\boldsymbol{b}_{n}\)</span> 下的坐标为 <spanclass="math inline">\(\boldsymbol{y}\)</span></p><p>有<span class="math inline">\(x=Py\)</span>，称为坐标变换公式。(<spanclass="math inline">\(y=P^{-}x\)</span>)</p><h2 id="求向量组的秩和最大无关组">求向量组的秩和最大无关组</h2><p>秩=矩阵阶梯型非0行数</p><p>极大无关组一般取“拐弯处”所在的列向量</p><h2 id="基础解系">基础解系</h2><p>齐次线性方程组的解空间的一个基为该齐次线性方程组的<strong>基础解系</strong></p><p>线性方程组构成的矩阵<span class="math inline">\(A_{m\times n}\)</span>基础解系所含解向量的个数=n-r(A)个=自由变量个数</p><h1 id="第5章-相似矩阵及二次型">第5章 相似矩阵及二次型</h1><h2 id="柯西-施瓦兹不等式">柯西-施瓦兹不等式</h2><p><ahref="https://blog.csdn.net/zhouchangyu1221/article/details/89682356">柯西-施瓦兹(Cauchy-Schwarz)不等式_柯西施瓦茨不等式-CSDN博客</a></p><h2 id="相似矩阵的性质">相似矩阵的性质</h2><p>若A与B相似，则有</p><p><span class="math display">\[detA=detB\]</span> <spanclass="math display">\[tr(A)=tr(B)\]</span> <spanclass="math display">\[r(A)=r(B)\]</span> <spanclass="math display">\[\lambda _{A} =\lambda _{B} ,\lambda为特征值\]</span></p><h2 id="施密特正交化公式">施密特正交化公式</h2><p>详解+示例:<ahref="https://blog.csdn.net/hpdlzu80100/article/details/100677372">线性代数学习笔记——第七十讲——格拉姆—施密特（Gram-Schmidt）正交化方法-CSDN博客</a></p><p>公式</p><p><span class="math display">\[\begin{array}{l}\beta_{1}=\alpha_{1} \\\beta_{2}= \alpha_{2}-\frac{\left(\alpha_{2},\beta_{1}\right)}{\left(\beta_{1}, \beta_{1}\right)} \beta_{1} \\\beta_{3}= \alpha_{3}-\frac{\left(\alpha_{3},\beta_{1}\right)}{\left(\beta_{1}, \beta_{1}\right)}\beta_{1}-\frac{\left(\alpha_{3}, \beta_{2}\right)}{\left(\beta_{2},\beta_{2}\right)} \beta_{2} \\\ldots \ldots \ldots \\\beta_{s}= \alpha_{s}-\frac{\left(\alpha_{s},\beta_{1}\right)}{\left(\beta_{1}, \beta_{1}\right)}\beta_{1}-\frac{\left(\alpha_{s}, \beta_{2}\right)}{\left(\beta_{2},\beta_{2}\right)} \beta_{2}-\cdots-\frac{\left(\alpha_{s},\beta_{s-1}\right)}{\left(\beta_{s-1}, \beta_{s-1}\right)} \beta_{s-1} .\\\ldots \ldots \ldots \\\gamma_{i}=\frac{1}{\left\|\beta_{i}\right\|} \beta_{i} \quad(i=1,2,\cdots, n)\end{array}\]</span></p><h2 id="已知特征值和特征向量求原矩阵">已知特征值和特征向量求原矩阵</h2><h3 id="知全部型">知全部型</h3><p>由<span class="math display">\[A=P\Lambda P^{-1} \]</span>可得A</p><h3 id="知部分实对称阵">知部分+实对称阵</h3><p>先根据特征向量正交求出剩余的特征向量</p><p>再由<span class="math display">\[A=Q\Lambda Q^{-1}=Q\LambdaQ^\mathrm{T}\]</span>可得A</p><h2id="不同特征值对应的特征向量不可以进行正交化的理解">“不同特征值对应的特征向量不可以进行正交化”的理解</h2><p><ahref="https://blog.csdn.net/weixin_46221946/article/details/122941338">“不同特征值对应的特征向量不可以进行正交化”的理解_特征向量正交化-CSDN博客</a></p><p><strong>总结：不同特征值对应的特征向量进行施密特正交化会导致新向量对应的特征值发生改变。</strong></p><h2 id="矩阵等价相似合同">矩阵等价，相似，合同</h2><p><ahref="https://blog.csdn.net/huangmingleiluo/article/details/104211738">一图说明矩阵等价，相似，合同_矩阵等价相似合同的区别-CSDN博客</a></p><h2 id="正定的判定方法">正定的判定方法</h2><p>1.A的特征值全大于0（即f的正惯性指数（标准型中正平方项个数）=未知数个数）</p><p>2.A的各阶顺序主子式全大于0</p>]]></content>
      
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数复习过程中的问题及重要结论</title>
      <link href="/2025/01/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA/"/>
      <url>/2025/01/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<div class="note warning flat"><p>由于前三章为期中考内容,本文较少涉及</p></div><p>前两章内容可以看<strong>伍耀文</strong>同学整理的：</p><p><ahref="https://pan.baidu.com/s/1frfdlhr7z33ZlJUp_STICQ?pwd=7w72">复习资料</a>提取码:7w72</p><p>以下为杭电历年期末试卷：</p><p><ahref="https://pan.baidu.com/s/1srFeirXys95NvtCtkgGK5Q?pwd=p8bf">历年真题</a>提取码: p8bf</p><h1 id="第1章">第1章</h1><h2 id="沙路法萨吕法则适用范围">沙路法（萨吕法则）适用范围</h2><div class="note warning flat"><p>三阶以上行列式不适用</p></div><p><a href="http://www.shuxueji.com/w/48891">萨吕法则-数学百科(shuxueji.com)</a></p><h1 id="第2章">第2章</h1><h2 id="矩阵的秩">矩阵的秩</h2><p><span class="math display">\[定理2 若  \boldsymbol{A} \sim\boldsymbol{B}  ，则  R(\boldsymbol{A})=R(\boldsymbol{B})（充要条件）\]</span> <span class="math display">\[（1）  0 \leq R\left(\boldsymbol{A}_{m \times n}\right) \leq \min \{m,n\} \]</span> <span class="math display">\[（2） R\left(\boldsymbol{A}^{T}\right)=R(\boldsymbol{A}) \]</span> <spanclass="math display">\[（3）若  \boldsymbol{A} \sim\boldsymbol{B}  ，则  R(\boldsymbol{A})=R(\boldsymbol{B}) \]</span><span class="math display">\[（4）若  \boldsymbol{P}, \boldsymbol{Q}  可逆，则  R(\boldsymbol{P}\boldsymbol{A} \boldsymbol{Q})=R(\boldsymbol{A}) \]</span> <spanclass="math display">\[（5）  \max \{R(\boldsymbol{A}),R(\boldsymbol{B})\} \leq R(\boldsymbol{A}, \boldsymbol{B}) \leqR(\boldsymbol{A})+R(\boldsymbol{B}) \]</span> <spanclass="math display">\[（6） R(\boldsymbol{A}+\boldsymbol{B}) \leqR(\boldsymbol{A})+R(\boldsymbol{B}) \]</span> <spanclass="math display">\[（7） R(\boldsymbol{A B}) \leq \min\{R(\boldsymbol{A}), R(\boldsymbol{B})\} \]</span> <spanclass="math display">\[（8）若  \boldsymbol{A}_{m \times n}\boldsymbol{B}_{n \timesl}=\boldsymbol{O}  ，则  R(\boldsymbol{A})+R(\boldsymbol{B}) \leq n\]</span></p><h2 id="易忘记的计算公式">易忘记的计算公式</h2><p><span class="math display">\[AA^{*} =A^{*}A=\left |A  \right |E\]</span></p><h1 id="第3章-矩阵的初等变换与线性方程组">第3章矩阵的初等变换与线性方程组</h1><h2 id="初等矩阵">初等矩阵</h2><p>初等矩阵是指由单位矩阵经过<strong>一次</strong><ahref="https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400?fromModule=lemma_inlink">初等变换</a>得到的矩阵，矩阵的初等变换是矩阵的一种最基本的运算。</p><p><ahref="https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400?fromModule=lemma_inlink">初等变换</a>有三种 [2]</p><p>（1）交换矩阵中某两行（列）的位置；</p><p>（2）用一个非零常数k乘以矩阵的某一行（列）；</p><p>（3）将矩阵的某一行（列）乘以常数k后加到另一行（列）上去。</p><p>三类初等矩阵都是<ahref="https://baike.baidu.com/item/%E5%8F%AF%E9%80%86%E7%9F%A9%E9%98%B5/0?fromModule=lemma_inlink">可逆矩阵</a>，即非奇异阵。</p><div class="note warning flat"><p>初等矩阵相加/相乘不一定为初等矩阵</p></div><h2 id="线性方程组的解">线性方程组的解</h2><p><imgsrc="https://pic1.imgdb.cn/item/677e6c53d0e0a243d4f23978.png" /></p><h1 id="第4章-向量组的线性相关性">第4章 向量组的线性相关性</h1><h2 id="判别向量组的线性相关性">判别向量组的线性相关性</h2><h3 id="数字型">数字型</h3><p>两个向量对应成比例</p><p>多个向量：方阵行列式=0或者矩阵的秩=向量个数</p><div class="note warning flat"><p>个数&gt;维数一定相关</p></div><h3 id="抽象型">抽象型</h3><p>1.抽象向量组的表示方法（逆向思维）：</p><p>eg.</p><p><span class="math display">\[\left(\alpha_{1},\alpha_{4}\right)\left(\begin{array}{ll}1 &amp; 2 \\3 &amp; 4\end{array}\right)=\left(\alpha_{1}+3 \alpha_{2}, 2 \alpha_{1}+4\alpha_{2}\right)\]</span></p><p>2.判断是否可逆</p><p>无关组*可逆阵-&gt;无关</p><p>无关组*不可逆阵-&gt;相关</p><h2 id="基变换公式和坐标变换公式">基变换公式和坐标变换公式</h2><h3 id="基变换公式">基变换公式</h3><p>取旧基为<span class="math inline">\(a_{1}，a_{2}，…，a_{n}\)</span>，新基为<span class="math inline">\(b_{1}，b_{2}，…，b_{n}\)</span>，则<spanclass="math inline">\(B=AP\)</span>(A，B为对应基构成的矩阵)，此式为基变换公式，P为从基<spanclass="math inline">\(a_{1}， a_{2}，…，a_{n}\)</span>到基<spanclass="math inline">\(b_{1}，b_{2}，…，b_{n}\)</span>的<strong>过度矩阵</strong> ,其中 <spanclass="math inline">\(P=A^{-}B\)</span></p><h3 id="坐标变换公式">坐标变换公式</h3><p>定义11 设 <span class="math inline">\(\boldsymbol{a}_{1},\boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{n}\)</span> 与 <spanclass="math inline">\(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots,\boldsymbol{b}_{n}\)</span> 是向量空间 V 的两个基． <spanclass="math inline">\(\forall \boldsymbol{\alpha} \in V\)</span> ，设<span class="math inline">\(\boldsymbol{\alpha}\)</span> 在基 <spanclass="math inline">\(a_{1}, a_{2}, \cdots, a_{n}\)</span> 下的坐标为<span class="math inline">\(\boldsymbol{x}\)</span> ，在基 <spanclass="math inline">\(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots,\boldsymbol{b}_{n}\)</span> 下的坐标为 <spanclass="math inline">\(\boldsymbol{y}\)</span></p><p>有<span class="math inline">\(x=Py\)</span>，称为坐标变换公式。(<spanclass="math inline">\(y=P^{-}x\)</span>)</p><h2 id="求向量组的秩和最大无关组">求向量组的秩和最大无关组</h2><p>秩=矩阵阶梯型非0行数</p><p>极大无关组一般取“拐弯处”所在的列向量</p><h2 id="基础解系">基础解系</h2><p>齐次线性方程组的解空间的一个基为该齐次线性方程组的<strong>基础解系</strong></p><p>线性方程组构成的矩阵<span class="math inline">\(A_{m\times n}\)</span>基础解系所含解向量的个数=n-r(A)个=自由变量个数</p><h1 id="第5章-相似矩阵及二次型">第5章 相似矩阵及二次型</h1><h2 id="柯西-施瓦兹不等式">柯西-施瓦兹不等式</h2><p><ahref="https://blog.csdn.net/zhouchangyu1221/article/details/89682356">柯西-施瓦兹(Cauchy-Schwarz)不等式_柯西施瓦茨不等式-CSDN博客</a></p><h2 id="相似矩阵的性质">相似矩阵的性质</h2><p>若A与B相似，则有</p><p><span class="math display">\[detA=detB\]</span> <spanclass="math display">\[tr(A)=tr(B)\]</span> <spanclass="math display">\[r(A)=r(B)\]</span> <spanclass="math display">\[\lambda _{A} =\lambda _{B} ,\lambda为特征值\]</span></p><h2 id="施密特正交化公式">施密特正交化公式</h2><p>详解+示例:<ahref="https://blog.csdn.net/hpdlzu80100/article/details/100677372">线性代数学习笔记——第七十讲——格拉姆—施密特（Gram-Schmidt）正交化方法-CSDN博客</a></p><p>公式</p><p><span class="math display">\[\begin{array}{l}\beta_{1}=\alpha_{1} \\\beta_{2}= \alpha_{2}-\frac{\left(\alpha_{2},\beta_{1}\right)}{\left(\beta_{1}, \beta_{1}\right)} \beta_{1} \\\beta_{3}= \alpha_{3}-\frac{\left(\alpha_{3},\beta_{1}\right)}{\left(\beta_{1}, \beta_{1}\right)}\beta_{1}-\frac{\left(\alpha_{3}, \beta_{2}\right)}{\left(\beta_{2},\beta_{2}\right)} \beta_{2} \\\ldots \ldots \ldots \\\beta_{s}= \alpha_{s}-\frac{\left(\alpha_{s},\beta_{1}\right)}{\left(\beta_{1}, \beta_{1}\right)}\beta_{1}-\frac{\left(\alpha_{s}, \beta_{2}\right)}{\left(\beta_{2},\beta_{2}\right)} \beta_{2}-\cdots-\frac{\left(\alpha_{s},\beta_{s-1}\right)}{\left(\beta_{s-1}, \beta_{s-1}\right)} \beta_{s-1} .\\\ldots \ldots \ldots \\\gamma_{i}=\frac{1}{\left\|\beta_{i}\right\|} \beta_{i} \quad(i=1,2,\cdots, n)\end{array}\]</span></p><h2 id="已知特征值和特征向量求原矩阵">已知特征值和特征向量求原矩阵</h2><h3 id="知全部型">知全部型</h3><p>由<span class="math display">\[A=P\Lambda P^{-1} \]</span>可得A</p><h3 id="知部分实对称阵">知部分+实对称阵</h3><p>先根据特征向量正交求出剩余的特征向量</p><p>再由<span class="math display">\[A=Q\Lambda Q^{-1}=Q\LambdaQ^\mathrm{T}\]</span>可得A</p><h2id="不同特征值对应的特征向量不可以进行正交化的理解">“不同特征值对应的特征向量不可以进行正交化”的理解</h2><p><ahref="https://blog.csdn.net/weixin_46221946/article/details/122941338">“不同特征值对应的特征向量不可以进行正交化”的理解_特征向量正交化-CSDN博客</a></p><p><strong>总结：不同特征值对应的特征向量进行施密特正交化会导致新向量对应的特征值发生改变。</strong></p><h2 id="矩阵等价相似合同">矩阵等价，相似，合同</h2><p><ahref="https://blog.csdn.net/huangmingleiluo/article/details/104211738">一图说明矩阵等价，相似，合同_矩阵等价相似合同的区别-CSDN博客</a></p><h2 id="正定的判定方法">正定的判定方法</h2><p>1.A的特征值全大于0（即f的正惯性指数（标准型中正平方项个数）=未知数个数）</p><p>2.A的各阶顺序主子式全大于0</p>]]></content>
      
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12306 车票信息爬虫实验答辩报告+源码-python期末作业</title>
      <link href="/2024/12/03/12306%20%E8%BD%A6%E7%A5%A8%E4%BF%A1%E6%81%AF%E7%88%AC%E8%99%AB%E5%AE%9E%E9%AA%8C%E7%AD%94%E8%BE%A9%E6%8A%A5%E5%91%8A+%E6%BA%90%E7%A0%81-python%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/"/>
      <url>/2024/12/03/12306%20%E8%BD%A6%E7%A5%A8%E4%BF%A1%E6%81%AF%E7%88%AC%E8%99%AB%E5%AE%9E%E9%AA%8C%E7%AD%94%E8%BE%A9%E6%8A%A5%E5%91%8A+%E6%BA%90%E7%A0%81-python%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>/*</p><p>答辩报告为一份word报告，内容包括以下几个部分：⑴实验目的；⑵实验方案分析比较；⑶实验过程（含实验方案、流程图、程序等）；⑷实验结果及结果分析；⑸实验总结；</p><p>*/</p><p>12306 车票信息爬虫实验答辩报告</p><h1 id="实验目的">1 实验目的</h1><p>鉴于在使用 12306网页查票时操作复杂，本实验运用爬虫技术编写一个程序来自动提取各车次剩余车票的数据，并整理为Excel 表格。通过该实验，旨在实现以下目标：</p><ol type="1"><li><p>提高获取车票信息的效率，减少人工查询的繁琐操作。</p></li><li><p>熟练掌握爬虫技术，包括网页数据抓取、解析和存储等环节。</p></li><li><p>能够将爬取到的数据进行有效的整理和分析，为用户提供更直观的车票信息展示。</p></li></ol><h1 id="实验方案分析比较">2 实验方案分析比较</h1><h2 id="方案一传统的网页抓取工具">2.1 方案一：传统的网页抓取工具</h2><h3 id="工具选择">2.1.1 工具选择：</h3><p>可以考虑使用一些常见的网页抓取工具，如八爪鱼采集器等。这些工具通常具有图形化界面，操作相对简单，不需要编写大量代码。</p><h3 id="优点">2.1.2 优点：</h3><p>对于没有编程经验的用户较为友好，通过简单的配置即可实现网页数据的抓取。</p><p>提供了一些数据预处理功能，如数据清洗、格式转换等。</p><h3 id="缺点">2.1.3 缺点：</h3><p>灵活性较差，对于复杂的网页结构和特定的数据需求，可能无法满足。</p><p>可能受到工具本身的功能限制，无法进行深度定制和扩展。</p><h2 id="方案二自定义爬虫程序">2.2 方案二：自定义爬虫程序</h2><h3 id="技术选择">2.1.1 技术选择：</h3><p>使用 Python 等编程语言结合相关的爬虫库，如 Requests 等。</p><h3 id="优点-1">2.1.2 优点：</h3><p>高度定制化，可以根据具体需求灵活调整爬虫的行为。</p><p>能够处理各种复杂的网页结构和动态加载的内容。</p><p>可以结合其他数据分析和处理工具，进行更深入的数据挖掘和分析。</p><h3 id="缺点-1">2.1.3 缺点：</h3><p>需要一定的编程基础和技术能力。</p><p>开发过程相对复杂，需要考虑网页反爬机制、数据存储等多个方面。</p><h2 id="方案选择">2.3 方案选择</h2><p>经过综合考虑，本实验选择了方案二，即自定义爬虫程序。虽然需要一定的编程基础，但可以更好地满足实验的需求，实现更高效、灵活的数据抓取和处理。</p><h1 id="实验过程">3 实验过程</h1><h2 id="实验方案">3.1实验方案</h2><h3 id="需求分析">3.1.1 需求分析：</h3><p>确定要爬取的 12306 网页页面，分析页面结构和数据来源。</p><p>明确需要提取的车票信息，如车次、出发地、目的地、出发时间、到达时间、剩余票数等。</p><h3 id="技术选择-1">3.1.2 技术选择：</h3><p>选择 Python作为编程语言，因其具有丰富的第三方库和强大的数据分析能力。</p><p>使用 Requests 库发送 HTTP 请求，获取网页内容。</p><p>使用 xlsxwriter 库将数据整理为 Excel 表格。</p><p>使用 pyinstaller 将程序封装为可执行文件。</p><h3 id="反爬机制处理">3.1.3 反爬机制处理：</h3><p>分析 12306网页的反爬机制，如设置请求头、模拟用户行为等，避免被网站识别为爬虫而被封禁。</p><p>控制请求频率，避免对网站服务器造成过大压力。</p><h2 id="流程图">3.2 流程图</h2><h2 id="程序">3.3程序</h2><h3 id="车票获取">3.3.1车票获取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取票信息  </span></span><br><span class="line">ba = station_name.get(begin_addr)  </span><br><span class="line">ea = station_name.get(end_addr)  </span><br><span class="line">info_url =<span class="string">f&#x27;https://kyfw.12306.cn/otn/leftTicket/queryO?leftTicketDTO.train_date=<span class="subst">&#123;start_time&#125;</span>&amp;leftTicketDTO.from_station=<span class="subst">&#123;ba&#125;</span>&amp;leftTicketDTO.to_station=<span class="subst">&#123;ea&#125;</span>&amp;purpose_codes=ADULT&#x27;</span>  </span><br><span class="line">headers = &#123;  </span><br><span class="line">    <span class="comment">#用户代理伪装  </span></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0&#x27;</span>,  </span><br><span class="line">    <span class="comment">#获取cookie  </span></span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_uab_collina=172405128457970660762947; JSESSIONID=4FB560B653EC2533260FEB98C3253979; _jc_save_wfdc_flag=dc; route=495c805987d0f5c8c84b14f60212447d; BIGipServerpassport=921174282.50215.0000; guidesStatus=off; highContrastMode=defaltMode; cursorStatus=off; _jc_save_fromStation=%u5317%u4EAC%2CBJP; _jc_save_toStation=%u4E0A%u6D77%2CSHH; _jc_save_toDate=2024-11-26; BIGipServerportal=3151233290.17695.0000; BIGipServerotn=66060810.50210.0000; _jc_save_fromDate=2024-11-27&#x27;</span>,  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">resp = requests.get(info_url,headers = headers)  </span><br><span class="line">resp_data = resp.json().get(<span class="string">&#x27;data&#x27;</span>).get(<span class="string">&#x27;result&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="城市获取">3.3.2城市获取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取城市信息  </span></span><br><span class="line">station_url =<span class="string">&#x27;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9142&#x27;</span>  </span><br><span class="line">headers =&#123;  </span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36&#x27;</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">resp = requests.get(station_url,headers=headers)  </span><br><span class="line">s_data = resp.text[resp.text.find(<span class="string">&#x27;=&#x27;</span>):-<span class="number">1</span>]  </span><br><span class="line">s_data = s_data.split(<span class="string">&#x27;|&#x27;</span>)  </span><br><span class="line">num = <span class="built_in">len</span>(s_data)//<span class="number">5</span>  </span><br><span class="line">station_name =&#123;&#125;  </span><br><span class="line">station_name2 =&#123;&#125;  </span><br><span class="line">k1 =<span class="number">1</span>  </span><br><span class="line">k2 =<span class="number">2</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):  </span><br><span class="line">    station_name[s_data[k1]]= s_data[k2]  </span><br><span class="line">    station_name2[s_data[k2]] = s_data[k1]  </span><br><span class="line">    k1 += <span class="number">5</span>  </span><br><span class="line">    k2 +=<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="数据处理">3.3.3 数据处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据生成EXCEL  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xw_toExcel</span>(<span class="params"> fileName</span>):  <span class="comment"># xlsxwriter库储存数据到excel  </span></span><br><span class="line">  </span><br><span class="line">    workbook = xw.Workbook(fileName)  <span class="comment"># 创建工作簿  </span></span><br><span class="line">    worksheet1 = workbook.add_worksheet(<span class="string">&quot;sheet1&quot;</span>)  <span class="comment"># 创建子表  </span></span><br><span class="line">    worksheet1.activate()  <span class="comment"># 激活表  </span></span><br><span class="line">  </span><br><span class="line">    bold = workbook.add_format(&#123;  </span><br><span class="line">        <span class="string">&#x27;bold&#x27;</span>: <span class="literal">True</span>,  <span class="comment"># 字体加粗  </span></span><br><span class="line">        <span class="string">&#x27;border&#x27;</span>: <span class="number">1</span>,  <span class="comment"># 单元格边框宽度  </span></span><br><span class="line">        <span class="string">&#x27;align&#x27;</span>: <span class="string">&#x27;left&#x27;</span>,  <span class="comment"># 水平对齐方式  </span></span><br><span class="line">        <span class="string">&#x27;valign&#x27;</span>: <span class="string">&#x27;vcenter&#x27;</span>,  <span class="comment"># 垂直对齐方式  </span></span><br><span class="line">        <span class="string">&#x27;fg_color&#x27;</span>: <span class="string">&#x27;#F4B084&#x27;</span>,  <span class="comment"># 单元格背景颜色  </span></span><br><span class="line">        <span class="string">&#x27;text_wrap&#x27;</span>: <span class="literal">True</span>,  <span class="comment"># 是否自动换行  </span></span><br><span class="line">    &#125;)  </span><br><span class="line">  </span><br><span class="line">    title = [<span class="string">&#x27;日期&#x27;</span>,<span class="string">&#x27;车号&#x27;</span>, <span class="string">&#x27;出发时间&#x27;</span>, <span class="string">&#x27;到达时间&#x27;</span>,<span class="string">&#x27;历时&#x27;</span>,<span class="string">&#x27;商务特等&#x27;</span>,<span class="string">&#x27;一等座&#x27;</span>,<span class="string">&#x27;二等座&#x27;</span>]  <span class="comment"># 设置表头  </span></span><br><span class="line">    worksheet1.write_row(<span class="string">&#x27;A1&#x27;</span>, title)  <span class="comment"># 从A1单元格开始写入表头  </span></span><br><span class="line">    i=<span class="number">2</span><span class="comment">#从第2行输入数据  </span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> resp_data:  </span><br><span class="line">        data = [a <span class="keyword">for</span> a <span class="keyword">in</span> r.split(<span class="string">&#x27;|&#x27;</span>)]  </span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">1</span>] != <span class="string">&#x27;列车停运&#x27;</span>:  </span><br><span class="line">            row=<span class="string">&#x27;A&#x27;</span>+<span class="built_in">str</span>(i)  </span><br><span class="line">            i+=<span class="number">1</span>  </span><br><span class="line">            insertData = [data[<span class="number">13</span>], data[<span class="number">3</span>],data[<span class="number">8</span>],data[<span class="number">9</span>],data[<span class="number">10</span>],data[<span class="number">32</span>],data[<span class="number">31</span>],data[<span class="number">30</span>]]<span class="comment">#插入数据  </span></span><br><span class="line">            worksheet1.write_row(row, insertData, bold)  </span><br><span class="line">    workbook.close()  <span class="comment"># 关闭表  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">fileName = <span class="string">f&#x27;<span class="subst">&#123;start_time&#125;</span>从<span class="subst">&#123;begin_addr&#125;</span>到<span class="subst">&#123;end_addr&#125;</span>.xlsx&#x27;</span>  </span><br><span class="line">xw_toExcel(fileName)</span><br></pre></td></tr></table></figure><h1 id="实验结果及结果分析">4 实验结果及结果分析</h1><h2 id="实验结果">4.1 实验结果</h2><p>成功爬取了 12306 网页上的各车次剩余车票数据，并将其整理为 Excel表格。表格中包含了车次、出发地、目的地、出发时间、到达时间和剩余票数等信息，数据清晰、直观，便于用户查看和分析。</p><h2 id="结果分析">4.2 结果分析</h2><p>效率提升：与传统的人工查询方式相比，爬虫程序大大提高了获取车票信息的效率。用户只需运行程序，即可快速获取大量车次的剩余票数信息，无需逐个车次进行手动查询。</p><h1 id="实验总结">5 实验总结</h1><p>本实验通过运用爬虫技术，成功实现了自动提取 12306网页上各车次剩余车票数据并整理为 Excel表格的目标。在实验过程中，我深入了解了网页爬虫的原理和技术，掌握了如何使用Python进行网页数据抓取、解析和存储。同时，也遇到了一些问题，如网页反爬机制的处理、数据整理、可执行文件生成等，通过不断地尝试和探索，我找到了有效的解决方案。</p><p>通过本次实验，我不仅提高了编程能力和数据分析能力，还为解决实际问题提供了一种有效的方法。在未来的学习和工作中，我会继续深入研究爬虫技术，探索更多的应用场景，为提高工作效率和数据分析能力做出更大的贡献。</p><h1 id="源代码">源代码</h1><div class="note warning flat"><p>需要提前安装第三方库：requests、xlsxwriter</p></div><p>win+R输入cmd，在命令框输入以下命令 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> requests</span><br><span class="line">pip <span class="keyword">install</span> xlsxwriter</span><br></pre></td></tr></table></figure></p><p>若安装速度较慢，请自行上网查找换清华园的下载源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> xlsxwriter <span class="keyword">as</span> xw  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#用户输入  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;请输入时间：格式XXXX-XX-XX&#x27;</span>)  </span><br><span class="line">start_time =<span class="built_in">input</span>()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;请输入出发站名&#x27;</span>)  </span><br><span class="line">begin_addr =<span class="built_in">input</span>()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;请输入到达站名&#x27;</span>)  </span><br><span class="line">end_addr=<span class="built_in">input</span>()  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">start_time =&#x27;2024-11-30&#x27;  </span></span><br><span class="line"><span class="string">end_addr=&#x27;杭州东&#x27;  </span></span><br><span class="line"><span class="string">begin_addr =&#x27;温州南&#x27;  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># 获取城市信息  </span></span><br><span class="line">station_url =<span class="string">&#x27;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9142&#x27;</span>  </span><br><span class="line">headers =&#123;  </span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36&#x27;</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">resp = requests.get(station_url,headers=headers)  </span><br><span class="line">s_data = resp.text[resp.text.find(<span class="string">&#x27;=&#x27;</span>):-<span class="number">1</span>]  </span><br><span class="line">s_data = s_data.split(<span class="string">&#x27;|&#x27;</span>)  </span><br><span class="line">num = <span class="built_in">len</span>(s_data)//<span class="number">5</span>  </span><br><span class="line">station_name =&#123;&#125;  </span><br><span class="line">station_name2 =&#123;&#125;  </span><br><span class="line">k1 =<span class="number">1</span>  </span><br><span class="line">k2 =<span class="number">2</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):  </span><br><span class="line">    station_name[s_data[k1]]= s_data[k2]  </span><br><span class="line">    station_name2[s_data[k2]] = s_data[k1]  </span><br><span class="line">    k1 += <span class="number">5</span>  </span><br><span class="line">    k2 +=<span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取票信息  </span></span><br><span class="line">ba = station_name.get(begin_addr)  </span><br><span class="line">ea = station_name.get(end_addr)  </span><br><span class="line">info_url =<span class="string">f&#x27;https://kyfw.12306.cn/otn/leftTicket/queryO?leftTicketDTO.train_date=<span class="subst">&#123;start_time&#125;</span>&amp;leftTicketDTO.from_station=<span class="subst">&#123;ba&#125;</span>&amp;leftTicketDTO.to_station=<span class="subst">&#123;ea&#125;</span>&amp;purpose_codes=ADULT&#x27;</span>  </span><br><span class="line">headers = &#123;  </span><br><span class="line">    <span class="comment">#用户代理伪装  </span></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0&#x27;</span>,  </span><br><span class="line">    <span class="comment">#获取cookie  </span></span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_uab_collina=172405128457970660762947; JSESSIONID=4FB560B653EC2533260FEB98C3253979; _jc_save_wfdc_flag=dc; route=495c805987d0f5c8c84b14f60212447d; BIGipServerpassport=921174282.50215.0000; guidesStatus=off; highContrastMode=defaltMode; cursorStatus=off; _jc_save_fromStation=%u5317%u4EAC%2CBJP; _jc_save_toStation=%u4E0A%u6D77%2CSHH; _jc_save_toDate=2024-11-26; BIGipServerportal=3151233290.17695.0000; BIGipServerotn=66060810.50210.0000; _jc_save_fromDate=2024-11-27&#x27;</span>,  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">resp = requests.get(info_url,headers = headers)  </span><br><span class="line">resp_data = resp.json().get(<span class="string">&#x27;data&#x27;</span>).get(<span class="string">&#x27;result&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#数据生成EXCEL  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xw_toExcel</span>(<span class="params"> fileName</span>):  <span class="comment"># xlsxwriter库储存数据到excel  </span></span><br><span class="line">  </span><br><span class="line">    workbook = xw.Workbook(fileName)  <span class="comment"># 创建工作簿  </span></span><br><span class="line">    worksheet1 = workbook.add_worksheet(<span class="string">&quot;sheet1&quot;</span>)  <span class="comment"># 创建子表  </span></span><br><span class="line">    worksheet1.activate()  <span class="comment"># 激活表  </span></span><br><span class="line">  </span><br><span class="line">    bold = workbook.add_format(&#123;  </span><br><span class="line">        <span class="string">&#x27;bold&#x27;</span>: <span class="literal">True</span>,  <span class="comment"># 字体加粗  </span></span><br><span class="line">        <span class="string">&#x27;border&#x27;</span>: <span class="number">1</span>,  <span class="comment"># 单元格边框宽度  </span></span><br><span class="line">        <span class="string">&#x27;align&#x27;</span>: <span class="string">&#x27;left&#x27;</span>,  <span class="comment"># 水平对齐方式  </span></span><br><span class="line">        <span class="string">&#x27;valign&#x27;</span>: <span class="string">&#x27;vcenter&#x27;</span>,  <span class="comment"># 垂直对齐方式  </span></span><br><span class="line">        <span class="string">&#x27;fg_color&#x27;</span>: <span class="string">&#x27;#F4B084&#x27;</span>,  <span class="comment"># 单元格背景颜色  </span></span><br><span class="line">        <span class="string">&#x27;text_wrap&#x27;</span>: <span class="literal">True</span>,  <span class="comment"># 是否自动换行  </span></span><br><span class="line">    &#125;)  </span><br><span class="line">  </span><br><span class="line">    title = [<span class="string">&#x27;日期&#x27;</span>,<span class="string">&#x27;车号&#x27;</span>, <span class="string">&#x27;出发时间&#x27;</span>, <span class="string">&#x27;到达时间&#x27;</span>,<span class="string">&#x27;历时&#x27;</span>,<span class="string">&#x27;商务特等&#x27;</span>,<span class="string">&#x27;一等座&#x27;</span>,<span class="string">&#x27;二等座&#x27;</span>]  <span class="comment"># 设置表头  </span></span><br><span class="line">    worksheet1.write_row(<span class="string">&#x27;A1&#x27;</span>, title)  <span class="comment"># 从A1单元格开始写入表头  </span></span><br><span class="line">    i=<span class="number">2</span><span class="comment">#从第2行输入数据  </span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> resp_data:  </span><br><span class="line">        data = [a <span class="keyword">for</span> a <span class="keyword">in</span> r.split(<span class="string">&#x27;|&#x27;</span>)]  </span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">1</span>] != <span class="string">&#x27;列车停运&#x27;</span>:  </span><br><span class="line">            row=<span class="string">&#x27;A&#x27;</span>+<span class="built_in">str</span>(i)  </span><br><span class="line">            i+=<span class="number">1</span>  </span><br><span class="line">            insertData = [data[<span class="number">13</span>], data[<span class="number">3</span>],data[<span class="number">8</span>],data[<span class="number">9</span>],data[<span class="number">10</span>],data[<span class="number">32</span>],data[<span class="number">31</span>],data[<span class="number">30</span>]]<span class="comment">#插入数据  </span></span><br><span class="line">            worksheet1.write_row(row, insertData, bold)  </span><br><span class="line">    workbook.close()  <span class="comment"># 关闭表  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">fileName = <span class="string">f&#x27;<span class="subst">&#123;start_time&#125;</span>从<span class="subst">&#123;begin_addr&#125;</span>到<span class="subst">&#123;end_addr&#125;</span>.xlsx&#x27;</span>  </span><br><span class="line">xw_toExcel(fileName)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 学科作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从“企业家”的变化看改革开放 ——读《激荡三十年》有感-改革开放史期末考核</title>
      <link href="/2024/12/03/%E4%BB%8E%E2%80%9C%E4%BC%81%E4%B8%9A%E5%AE%B6%E2%80%9D%E7%9A%84%E5%8F%98%E5%8C%96%E7%9C%8B%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%20%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4%E3%80%8B%E6%9C%89%E6%84%9F-%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E5%8F%B2%E6%9C%9F%E6%9C%AB%E8%80%83%E6%A0%B8/"/>
      <url>/2024/12/03/%E4%BB%8E%E2%80%9C%E4%BC%81%E4%B8%9A%E5%AE%B6%E2%80%9D%E7%9A%84%E5%8F%98%E5%8C%96%E7%9C%8B%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%20%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4%E3%80%8B%E6%9C%89%E6%84%9F-%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E5%8F%B2%E6%9C%9F%E6%9C%AB%E8%80%83%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><strong>摘要：</strong></h1><p>本文通过对改革开放历程中“企业家”这一群体的变化进行分析，结合马胜利和柳传志等企业家的例子，探讨了改革开放对中国经济体制和社会观念的深刻影响，以及企业家在其中所发挥的重要作用。同时，阐述了新时代企业家的特点和需求，并以一些新时代企业家为例进行说明。</p><h1id="一改革开放初期企业家的艰难起步"><strong>一、改革开放初期：“企业家”的艰难起步</strong></h1><pre><code>改革开放初期，中国刚刚从计划经济的桎梏中挣脱出来，迈向市场经济的探索之路。在这个阶段，“企业家”一词曾被视为带有贬义色彩。北京大学教授张维迎在 1984 年写的一篇题为《时代需要具有创新精神的企业家》的文章，当时的《读书》杂志编辑还曾与他商榷，是否要将“企业家”改成“实业家”，“冒险精神”改成“探险精神”或“创新精神”，因为在那时，这两个词在中国人的词典里都有着负面的意思。这种观念的形成并非偶然。长期的计划经济体制下，企业的生产经营活动主要是按照国家计划进行，企业管理者更多地是执行上级指令，缺乏自主决策和创新的空间。在这样的环境中，人们对“企业家”所代表的冒险、创新等特质感到陌生和不安。同时，受传统观念的影响，人们对市场经济中的商业行为存在一定的偏见，认为追求利润的行为是不道德的。然而，正是在这样的背景下，一些勇敢的开拓者开始崭露头角。马胜利以承包石家庄造纸厂而名震全国。他大胆地打破传统的经营管理模式，提出“层层承包、责任到人”等创新举措。在他的带领下，石家庄造纸厂迅速扭亏为盈，成为当时国有企业改革的一面旗帜。马胜利的成功并非偶然。他敏锐地察觉到了市场经济的萌芽，敢于挑战传统体制，勇于尝试新的经营方式。他的行动不仅为石家庄造纸厂带来了生机，也为其他企业树立了榜样。他的故事激励着更多的人勇敢地迈出改革的步伐，探索适合中国国情的企业发展道路。</code></pre><h1id="二改革开放进程中企业家的崛起与贡献"><strong>二、改革开放进程中：企业家的崛起与贡献</strong></h1><pre><code>在改革开放的进程中，柳传志也是一位具有标志性意义的企业家。柳传志带领联想从一个小型计算机贸易公司逐步发展成为全球知名的科技企业。他以卓越的战略眼光和领导才能，推动联想在技术创新、国际化发展等方面不断取得突破。柳传志注重科技创新，带领联想不断加大研发投入，推出了一系列具有竞争力的产品。同时，他积极推动联想的国际化战略，通过并购等方式拓展全球市场，使联想成为中国企业走向世界的典范。他的管理理念和企业家精神，为中国企业的发展提供了宝贵的经验。像马胜利和柳传志这样的企业家们，在改革开放初期面临着巨大的困难和阻力。一方面，他们要突破传统观念的束缚，面对来自社会各方的质疑和批评。另一方面，他们还要在不完善的市场环境中摸索前行，缺乏政策支持和法律保障。然而，正是这些困难和阻力，更加凸显了他们的勇气和创新精神。随着改革开放的不断深入，市场经济体制逐步完善，政府对企业的管理方式也发生了根本性的转变。从过去的直接干预到现在的宏观调控和服务引导，为企业家们创造了更加宽松和有利的发展环境。同时，社会观念也逐渐转变，人们开始认识到企业家在经济发展中的重要作用，对他们的创新和冒险精神给予了更多的理解和尊重。在这个过程中，企业家们的地位和作用日益凸显。他们不再是被人质疑的对象，而是成为了推动经济发展的重要力量。他们通过不断创新和开拓，创造了大量的财富和就业机会，为中国经济的腾飞做出了巨大贡献。</code></pre><h1id="三新时代企业家的特点与挑战"><strong>三、新时代企业家的特点与挑战</strong></h1><pre><code>在新时代，企业家面临着新的机遇和挑战。随着经济全球化的深入发展、科技革命的迅猛推进以及社会环境的变化，新时代企业家需要具备更加全面的素质和能力。新时代企业家需要有强烈的创新意识。在快速变化的市场环境中，只有不断创新才能保持企业的竞争力。例如，字节跳动的张一鸣，他带领团队开发出了今日头条、抖音等具有创新性的产品，改变了人们获取信息和娱乐的方式。张一鸣敢于突破传统思维，利用人工智能技术实现个性化推荐，为用户提供更加精准的内容服务。新时代企业家还需要有全球化的视野。随着经济全球化的加速，企业的市场不再局限于国内，而是拓展到了全球。像小米的雷军，他带领小米积极拓展海外市场，在印度、东南亚等地区取得了巨大成功。雷军注重产品的性价比和用户体验，通过线上线下相结合的销售模式，迅速打开了国际市场。此外，新时代企业家还需要具备社会责任感。在追求经济效益的同时，企业家们还应该关注环境保护、社会公益等问题，为实现经济、社会和环境的可持续发展做出贡献。例如，马云发起的乡村教师计划，致力于改善中国农村教育状况；腾讯的马化腾也积极推动互联网公益事业的发展。</code></pre><h1 id="四展望未来"><strong>四、展望未来</strong></h1><pre><code>回顾改革开放的历程，我们可以清晰地看到，企业家们的成长与中国经济的发展息息相关。他们是改革开放的实践者和推动者，他们的勇气、智慧和创新精神为中国经济的腾飞做出了不可磨灭的贡献。从“企业家”的变化看改革开放，我们可以深刻地感受到中国经济体制的深刻变革和社会观念的巨大进步。企业家们作为改革开放的实践者和推动者，他们的故事将继续激励着我们，为实现中华民族伟大复兴的中国梦而努力奋斗。在未来的发展中，我们相信，随着改革开放的不断深入，中国的企业家们将继续发挥重要作用，为中国经济的持续发展和社会的进步做出更大的贡献。同时，我们也期待着社会各界能够更加尊重和支持企业家们，为他们创造更加良好的发展环境，共同推动中国经济的繁荣和社会的进步。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学科作业 </tag>
            
            <tag> 改革开放史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《杭电及智能科学与技术专业之我见》</title>
      <link href="/2024/11/25/%E3%80%8A%E6%9D%AD%E7%94%B5%E5%8F%8A%E6%99%BA%E8%83%BD%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B8%93%E4%B8%9A%E4%B9%8B%E6%88%91%E8%A7%81%E3%80%8B/"/>
      <url>/2024/11/25/%E3%80%8A%E6%9D%AD%E7%94%B5%E5%8F%8A%E6%99%BA%E8%83%BD%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B8%93%E4%B8%9A%E4%B9%8B%E6%88%91%E8%A7%81%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p align="center">《形势与政策期末报告》</p><table><tbody><tr class="odd"><td>学院：</td><td>自动化学院</td></tr><tr class="even"><td>班级：</td><td>24063113</td></tr><tr class="odd"><td>姓名：</td><td>李文轩</td></tr><tr class="even"><td>学号：</td><td>24062022</td></tr><tr class="odd"><td>任课老师：</td><td>张卫洪 任蔚青</td></tr><tr class="even"><td>日期：</td><td>2024.12.25</td></tr></tbody></table><p align="center">杭电及智能科学与技术专业之我见</p><h1 id="一-杭电在大众认知中的现状">一、    杭电在大众认知中的现状</h1><p>当在百度搜索框中输入“杭电是”三个字时，出现的提示搜索内容如“杭电是什么档次的学校”“杭电是双一流大学吗”“杭电是985 还是 211大学”“杭电是一本还是二本”等问题，这充分反映了在大数据背景下，大部分人对杭电的认知还存在一定的模糊性。杭电既不是传统意义上的985、211高校，也不是双一流大学，这使得其在一些考生和家长的眼中，在高校选择的优先级上可能会有所降低。然而，这并不意味着杭电没有自身的优势和特色。</p><p>接着，在视频平台搜索“杭州电子科技大学”，首先弹出的是官号，其次是本校同学发布的一些视频，但并未找到对于杭电评价的相关视频。相比之下，在搜索其他一些省内院校时，关于“是什么样的学校”这个话题的视频讨论明显多于杭电。这不禁让人思考，是杭电的热度不高吗？其实，这可能与杭电的宣传力度、专业特色的传播方式等因素有关。杭电在某些领域具有很强的实力，但这些优势可能并没有得到充分的展示和传播，导致大众对其了解不够全面。</p><h1 id="二我眼中的杭电">二、我眼中的杭电</h1><p>基于几个月的学习和生活，我对杭电有了一定的认识。在杭电，学生可以接收到先进的思想和认识。学校在自动化、微电子与集成电路、计算机等领域表现强势。这些专业领域的发展不仅得益于学校的师资力量和教学资源，还与学校积极与企业合作、紧跟行业发展趋势密不可分。例如，在自动化领域，学校与众多知名企业合作开展项目，为学生提供了实践机会，使学生能够在实际项目中锻炼自己的能力。同时，学校还邀请行业专家来校讲学，让学生了解最新的技术动态和行业发展趋势。</p><p>然而，或许是被这些工科专业的强势笼罩了，其他学科的优势并没有这么明显地显现。这在一定程度上可能会影响学校的综合发展和整体声誉。学校应该在保持工科优势的同时，加大对其他学科的投入和支持，提高其他学科的教学质量和科研水平，以实现学科的均衡发展。</p><p>以一个假设结束对杭电的思考：如果让目前的我为一位今年的高三毕业学生推荐一所在杭电分数段内的一所学校，若是自动化、计算机等专业，我必然会选择杭电。这些专业在杭电拥有雄厚的师资力量、先进的教学设备和丰富的实践机会。学生在这些专业中能够学到扎实的专业知识和技能，为未来的职业发展打下坚实的基础。但若是相对难就业的一些专业，我的第一选择或许就并不是杭电了。这并不是说杭电的这些专业不好，而是在就业市场上，这些专业可能面临着更大的竞争压力，杭电在市场或许并没有这么的受欢迎。</p><h1id="三智能科学与技术专业的发展历程">三、智能科学与技术专业的发展历程</h1><p>智能科学与技术专业在全国范围首次出现是在 1998年，而在杭电，这个专业首次招生是在 2018年，也是我初一的那年。杭电的智能科学与技术专业在发展过程中取得了一定的成绩，其中2018年的这一届智科班级更是为学校带来了一次“出圈”的机会。正如当年杭电的推文中陈廷轩所言：“我们这个班太卷了！有人ACM 竞赛拿奖，有人发好几篇 sci论文，很多在其他班能拿一等奖学金的成绩，在我们班三等奖学金都拿不到。”这充分体现了该班级学生的优秀和努力。然而，我们不能仅仅以这个班的成就评价这个专业。一个专业的发展不仅仅取决于学生的个人努力，还与学校的教学质量、师资力量、学科建设等因素密切相关。</p><p>智能科学与技术在百度百科中是归于计算机大类的，并且在其他一些学校中也是属于计算学院。但是在杭电，这个专业属于自动化（人工智能）学院。在收到录取通知书时，这一点确实让我比较诧异。但随着来到杭电，我逐渐发现了其中的原因。杭电自动化学院拥有强大的实力，能够支撑起该学科的建设。学院有资源分配到专业中，这取决于学校实情与学校的发展史。杭电在自动化领域有着悠久的历史和丰富的经验，拥有一批优秀的教师和科研团队。将智能科学与技术专业设置在自动化学院，可以充分利用学院的资源和优势，促进该专业的发展。</p><h1id="四智能科学与技术专业的学习方向与实践">四、智能科学与技术专业的学习方向与实践</h1><p>在仔细查看了杭电的本科生培养方案后，我大致总结出了智能科学与技术专业的几大学习方向并了解了这些方向的具体内容。</p><p>首先是计算机视觉与医学相关的领域，这一点在导师制的讲座中也明显体现。计算机视觉是一门涉及计算机科学、数学、物理学等多个学科的交叉学科，其应用领域非常广泛，包括医学影像分析、智能交通、安防监控等。在医学领域，计算机视觉技术可以用于疾病诊断、手术辅助、医疗影像分析等方面，为医学的发展带来了新的机遇。杭电在这个方向上拥有一定的师资力量和科研实力，通过导师制的讲座和实践项目，让学生了解到这个领域的前沿技术和应用前景。</p><p>第二是人工智能与神经网络的相关领域。关于这一部分，我并没有形成相对完善的价值观念。人工智能是当今科技领域的热门话题，其应用涵盖了自然语言处理、机器学习、计算机视觉等多个领域。神经网络是人工智能的重要组成部分，它通过模拟人脑的神经元结构和工作原理，实现对数据的学习和预测。杭电在人工智能与神经网络领域也有一定的研究成果和教学资源，为学生提供了学习和实践的机会。</p><p>第三是嵌入式系统，这个方向在我看来是比较成熟的一条赛道。作为传统自动化的大方向，我也通过了科协的一些竞赛得到较多的了解，如智能车、机器人等竞赛都是与嵌入式系统相关的竞赛。我目前也接着学习单片机的机会参加相关的一些竞赛，如尝试与同学组团参加挑战杯的比赛，着手做一些单片机的小项目。我认为单片机的学习是我从开学以来到现在与课程学习并行的主旋律。嵌入式系统是一种将计算机技术与特定应用领域相结合的技术，它具有体积小、功耗低、可靠性高等特点，广泛应用于工业控制、智能家居、医疗设备等领域。杭电在嵌入式系统方向上拥有丰富的教学经验和实践资源，通过竞赛和项目实践，培养学生的动手能力和创新精神。</p><h1id="五智能科学与技术专业的就业方向与发展前景">五、智能科学与技术专业的就业方向与发展前景</h1><p>智能科学与技术专业的就业方向依旧是偏向传统的自动化领域，还是新鲜的人工智能，这是一个模棱两可的结论。目前，该专业的毕业生既可以在传统的自动化领域找到工作，如工业控制、智能制造等领域，也可以在新兴的人工智能领域发挥自己的才能，如机器学习、自然语言处理等领域。然而，无论是哪个领域，都需要毕业生具备扎实的专业知识和技能，以及较强的实践能力和创新精神。</p><p>对于“和你的兴趣是否相同”这个问题，我的答复是，这个提问还是太宽泛了。我只能说建立在这个专业的基础上去寻找一个与专业相关的并且是自己相对最感兴趣的方向，然后向这个方向钻研。让一个专业来匹配人的兴趣一定没有让人的兴趣向专业靠拢来得容易实现。目前的我只是在各个方向做出尝试，同时先找到一个比较稳妥的方向学习。</p><p>对于该专业的发展前景，我或许是比较迷茫的，有可能是有比较清晰认知的。学着自动化相关的理论，又抓着人工智能的潮头，我们的知识覆盖面太广了，缺乏了作为一个专业应有的厚度。若要我做出一个猜测，难道这就是学院推行导师制和竞赛的原因？学院通过推行导师制，让学生在导师的指导下，深入了解专业知识和前沿技术，培养学生的科研能力和创新精神。同时，通过参加竞赛，让学生将理论知识与实践相结合，提高学生的动手能力和解决问题的能力。所以对于目前的我而言，我参加了智能车竞赛的实验室，同时加入导师组和几位大二的同学准备科技立项，尽可能提高自己的技术和素养，为以后做好铺垫。</p><p>智能科学与技术专业在目前看来本科就业，就“好”业是比较困难的，既需要实力又不能缺乏机遇。而准备考研或许成了越来越多人的首选。随着科技的不断发展，对智能科学与技术专业人才的需求也在不断增加。然而，本科毕业生在就业市场上可能面临着较大的竞争压力。一方面，本科阶段的学习可能无法满足企业对高端人才的需求；另一方面，就业市场上的竞争也非常激烈。因此，很多学生选择考研，进一步深造，提高自己的专业水平和竞争力。</p><h1 id="六形式与政策课程的启示">六、《形式与政策》课程的启示</h1><p>《形式与政策》这门课在我看来是大到在分析国家大事，世界局势的一门课，同时也是在分析自己所处的局势的形式，然后找到对应的政策做出改变。借着这次写报告的过程，我对于自己的局势有了更加深刻的认识。在当今快速发展的时代，我们不仅要关注国家大事和世界局势，还要关注自己所处的环境和局势。只有了解自己所处的局势，才能找到适合自己的发展方向和政策。</p><h1 id="报告格式">报告格式</h1><p><strong>报告要求：</strong></p><p>本次作业的目标是帮助大家更好地认识杭电在浙江省的地位、了解杭电的历史，并对杭电有清晰的认识。通过撰写杭电和专业报告，大家可以系统地了解对自己专业的兴趣，和这门专业的历史、现状和前景，以及对本专业的看法，更好地把握专业动态。</p><p><strong>报告格式：</strong></p><ul><li>字数要求：2000字左右。</li><li>报告应结构清晰，内容完整，每个部分应有明确的小标题。</li></ul><p><strong>评分标准：</strong></p><ul><li><strong>内容完整性（40%）：</strong>各部分是否完整，是否深入分析杭电的状况和自己的专业前景中的各个方面。</li><li><strong>逻辑清晰度（30%）：</strong>报告结构是否清晰，思路是否连贯。</li><li><strong>自我评估的准确性与真实性（20%）：</strong>自我评估部分是否真实反映了个人情况，对杭电和专业的看法是否真实。</li><li><strong>报告格式与语言表达（10%）：</strong>报告的格式是否符合要求，语言是否简洁流畅。</li></ul><p><strong>报告内容：</strong></p><p>请大家围绕以下几个方面撰写一份完整的有关杭电和自身专业的报告，要求内容详实、结构清晰，每个部分都应体现出你对杭电现状和专业前景的深入思考和分析：</p><p>1.<strong>杭电的状况</strong></p><ul><li>进行对杭电的历史的调查，可以通过查阅杭电的官网和杭电自动化的官网来了解杭电。</li><li>对杭电现状的分析，明确杭电在浙江省的地位，杭电的优势和特色。</li><li>结合自我认知，谈谈自己对杭电的认识。</li></ul><ol start="2" type="1"><li><strong>专业探索</strong></li></ol><ul><li>了解自动化学院在杭电的发展历史，和自己的专业在杭电的历史。</li><li>充分掌握自己专业的培养方案，明确自己将来能在专业中学到的知识和技能，以及毕业需要的学分。</li><li>调查自己专业的前景和地位，以及目前这个专业的就业形势。</li></ul><ol start="4" type="1"><li><strong>对专业的态度</strong></li></ol><ul><li>在这一部分，通过对以上两部分的了解，判断自己是否对自己的专业感兴趣，和对这个专业的看法。</li></ul><ol start="6" type="1"><li><strong>行动计划</strong></li></ol><ul><li>根据对杭电和专业的状况，制定具体的行动计划，涵盖学术学习、实践经验积累、技能提升等方面的内容。</li><li>详细列出未来在校期间的学习规划、社会实践、实习安排等。</li><li>描述你想要找到的工作岗位，并在大学期间要掌握的技术。</li></ul><ol start="8" type="1"><li><strong>结论</strong></li></ol><ul><li>总结报告中的关键点，展望未来学业生涯，并反思你在对杭电和自己专业探索过程中的收获。</li><li>提出未来需要改进或继续发展的方面。</li></ul><hr /><p>通过完成这份有关杭电和专业的报告，希望大家能对杭电和自己的专业有更清晰的认识，并通过规划和行动为学业成功打下坚实的基础！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学科作业 </tag>
            
            <tag> 杭电 </tag>
            
            <tag> 形势与政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的《微电子技术和集成电路产业》学习感悟</title>
      <link href="/2024/10/03/%E6%88%91%E7%9A%84%E3%80%8A%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E4%BA%A7%E4%B8%9A%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
      <url>/2024/10/03/%E6%88%91%E7%9A%84%E3%80%8A%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E4%BA%A7%E4%B8%9A%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="声明">声明</h1><p>本人原创，杜绝抄袭，违者后果自负。如文章内容涉密或侵权，请联系作者邮箱 1191228412@qq.com 修改。</p><p>本文为李文轩创作，作为课程记录，请勿抄袭！！！</p><h1 id="lesson-1">lesson 1</h1><p>第一节课见到了12寸硅片，深深震撼于其厚度（非常薄）</p><p>近距离观察了固态硬盘。（中国第一块固态硬盘出自杭电，非常骄傲）</p><p>有些内容不敢拍照,不确定是否合法，而且我坐第一排。</p><h1 id="lesson2">lesson2</h1><p>今天是楼老师上的课讲了集成电路的一些专业知识，如电子管的结构。</p><p>后面1个小时去了4教的微电子研究院参观，了解的我国集成电路的发展历史。<a href="https://img.z4a.net/image/2.Alq1R"><imgsrc="https://img.z4a.net/images/2024/09/14/2.md.jpeg" alt="2" /></a></p><p>历史变革 <a href="https://img.z4a.net/image/1.AlzcK"><imgsrc="https://img.z4a.net/images/2024/09/14/1bae8057428a3e36f.md.jpeg"alt="历史变革" /></a></p><p>磁盘阵列 <a href="https://img.z4a.net/image/3.AlbTZ"><imgsrc="https://img.z4a.net/images/2024/09/14/3bb7dec30c607e882.md.jpeg"alt="磁盘阵列" /></a></p><h1 id="lesson3">lesson3</h1><p>今天的课是在教室上的，在补充完第一节课的内容后，老师主要讲了培养人才的重要性<figure class="highlight plaintext"><figcaption><span>word</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补充完第一节课的内容后，老师将重点转向了培养人才的重要性这一主题。老师以其渊博的知识和丰富的经验，生动地阐述着培养人才对于个人、社会乃至整个国家的重大意义。老师强调，对于个人而言，培养人才意味着为自己的未来奠定坚实的基础，拥有更多的发展机会和选择空间。一个经过良好培养的人，不仅具备扎实的专业知识和技能，还拥有良好的品德修养和创新思维能力，能够在激烈的竞争中脱颖而出，实现自己的人生价值。在社会层面，培养人才是推动社会进步的关键力量。只有不断培养出高素质的人才，才能满足社会发展对于各个领域专业人才的需求。这些人才将在科技、文化、教育、医疗等各个领域发挥重要作用，推动社会不断向前发展。而从国家的角度来看，培养人才更是关系到国家的繁荣昌盛和民族的伟大复兴。一个国家只有拥有大量的优秀人才，才能在国际竞争中立于不败之地，实现国家的长治久安和可持续发展。</span><br></pre></td></tr></table></figure></p><h1 id="lesson4">lesson4</h1><p>今天是楼老师上课，讲了一些芯片的制作工艺。</p><p>分享了一些英语学习的小技巧</p><h1 id="lesson5">lesson5</h1><p>这次课比较硬核。</p><p>讲了pmos管nmos管，非门的电路原理。</p><p>课后还拓展了时序电路，自锁电路（存储器的基本单元）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杭电 </tag>
            
            <tag> 新生研讨课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用自定义函数+算法</title>
      <link href="/2024/09/23/%E5%B8%B8%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0+%E7%AE%97%E6%B3%95/"/>
      <url>/2024/09/23/%E5%B8%B8%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0+%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文提供的函数是作者在学习过程中使用频率较高的一些自定义函数</p><span id="more"></span><h1 id="数学相关">数学相关</h1><h2 id="最大公因数">最大公因数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大公因数的函数</span></span><br><span class="line"><span class="comment">//使用欧几里得算法（辗转相除法）求两个数最大公因数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (b!= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第一个数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第二个数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = gcd(num1, num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大公因数是: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数">最小公倍数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大公约数的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// 当 b 不为 0 时，执行循环</span></span><br><span class="line">    <span class="keyword">while</span> (b!= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 交换 a 和 b 的值</span></span><br><span class="line">        <span class="type">int</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最终的最大公约数</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小公倍数的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过两数之积除以它们的最大公约数得到最小公倍数</span></span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第一个数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num1);  <span class="comment">// 输入第一个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第二个数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num2);  <span class="comment">// 输入第二个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = lcm(num1, num2);  <span class="comment">// 计算并获取最小公倍数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小公倍数是: %d\n&quot;</span>, result);  <span class="comment">// 输出最小公倍数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断质数">判断质数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否为质数的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 0 和 1 不是质数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 是质数</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数（除了 2）不是质数</span></span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 3 开始，以步长为 2 遍历到 num 的平方根</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= num; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果能被整除，不是质数</span></span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都不能整除，是质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入起始数字: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入结束数字: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 %d 到 %d 之间的质数有: &quot;</span>, start, end);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = start; num &lt;= end; num++) &#123;</span><br><span class="line">        <span class="comment">// 如果是质数，输出</span></span><br><span class="line">        <span class="keyword">if</span> (isPrime(num)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数函数">组合数函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合数函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        result *= (n - (r - i));</span><br><span class="line">        result /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对称数">对称数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_Symmetric</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result=num*num;</span><br><span class="line">    <span class="type">int</span> temp=result;</span><br><span class="line">    <span class="type">int</span> new_result= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        new_result=new_result*<span class="number">10</span>+temp%<span class="number">10</span>;</span><br><span class="line">        temp/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_result==result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序算法">排序算法</h1><h2 id="冒泡排序">冒泡排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序">插入排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, key, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序">选择排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx])</span><br><span class="line">                min_idx = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_idx!= i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[min_idx];</span><br><span class="line">            arr[min_idx] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭电24级智科三班第一学期各课程评分标准和作业安排</title>
      <link href="/2024/09/17/%E6%9D%AD%E7%94%B524%E7%BA%A7%E6%99%BA%E7%A7%91%E4%B8%89%E7%8F%AD%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E5%90%84%E8%AF%BE%E7%A8%8B%E8%AF%84%E5%88%86%E6%A0%87%E5%87%86%E5%92%8C%E4%BD%9C%E4%B8%9A%E5%AE%89%E6%8E%92/"/>
      <url>/2024/09/17/%E6%9D%AD%E7%94%B524%E7%BA%A7%E6%99%BA%E7%A7%91%E4%B8%89%E7%8F%AD%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E5%90%84%E8%AF%BE%E7%A8%8B%E8%AF%84%E5%88%86%E6%A0%87%E5%87%86%E5%92%8C%E4%BD%9C%E4%B8%9A%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数">线性代数</h1><h2 id="作业">作业</h2><p>老师发的图片框起来的，每次上课线下交</p><h1 id="微电子技术和集成电路产业">微电子技术和集成电路产业</h1><h2 id="作业-1">作业</h2><p>无</p><h2 id="期末考核">期末考核</h2><p>原创个人课程感想</p><h1 id="中国近现代史纲要">中国近现代史纲要</h1><h2 id="期中考核">期中考核</h2><p>实践/找出课本一处错误并写成论文</p><h1 id="python算法设计实验">python算法设计实验</h1><h2 id="作业-2">作业</h2><p>学习通</p><h1 id="高等数学a1">高等数学A1</h1><h2 id="作业-3">作业</h2><p>1.学习通评论区 2.学习通作业（周二晚上截止）3.学习通考试（一单元一次） 4.课程预习</p><h1 id="基础英语读写">基础英语读写</h1><h2 id="作业-4">作业</h2><p>第一次是看视频写总结</p><h2 id="学期任务">学期任务</h2><p>完成几份4级试卷（要交）</p><h1 id="体育">体育</h1><h2 id="期末考核-1">期末考核</h2><p>1.太极拳 2.体测 3.阳光长跑</p><h1 id="基础英语视听说">基础英语视听说</h1><h2 id="作业-5">作业</h2><p>第一次是课本听力</p><h2 id="学期任务-1">学期任务</h2><p>1.课堂发言 2.小组展示</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杭电 </tag>
            
            <tag> 课程安排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32单片机学习</title>
      <link href="/2024/09/13/stm32%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/09/13/stm32%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文所需的材料软件等均在下方链接。</p><p>stm32单片机的PC端配置需要keil5MDK，并且需要手动配置编译环境。具体看B站UP主的教程（讲的非常好 ! !!）</p><p>学习教程：<ahref="https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.337.search-card.all.click">STM32入门教程-2023版细致讲解 中文字幕_哔哩哔哩_bilibili</a></p><p><a href="https://jiangxiekeji.com/download.html">资料下载</a></p><h1 id="day-1-240913">DAY 1 (240913)</h1><p>这段代码主要是对 STM32F10x 系列芯片的 GPIOC 端口的 13号引脚进行配置和操作。首先初始化引脚为推挽输出模式，然后先将该引脚设置为高电平，接着又设置为低电平，之后进入死循环。在实际应用中，可能会在循环中添加其他的逻辑来实现特定的功能，比如控制LED 闪烁等相关操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// 包含 STM32F10x 系列相关的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">// 主函数，程序的入口点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使能 GPIOC 外设的时钟，这是对 GPIOC 进行操作的前提</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 GPIO 初始化结构体变量</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 GPIO 引脚的工作模式为推挽输出（Push-Pull Output）</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 GPIOC 的 13 号引脚进行配置</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输出引脚的速度为 50MHz</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上述设置的参数初始化 GPIOC 的相关引脚</span></span><br><span class="line">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GPIOC 的 13 号引脚置为高电平</span></span><br><span class="line">    GPIO_SetBits(GPIOC, GPIO_Pin_13);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GPIOC 的 13 号引脚置为低电平</span></span><br><span class="line">    GPIO_ResetBits(GPIOC, GPIO_Pin_13);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入一个无限循环，使程序保持运行状态</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>效果图 <ahref="https://img.z4a.net/image/%E5%8D%95%E7%89%87%E6%9C%BA%E7%82%B9%E7%81%AF.AlDAR"><imgsrc="https://img.z4a.net/images/2024/09/14/9ea687ae627548c010abe19dee3780da.md.jpeg"alt="单片机点灯" /></a></p><h1 id="day-2-240914-led-闪烁">DAY 2 (240914) LED 闪烁</h1><h2 id="led-闪烁">LED 闪烁</h2><p>成果</p><p><a href="https://thumbsnap.com/AbVWuJp6" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/AbVWuJp6.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/AbVWuJp6.mp4" type="video/mp4"></video></a></p><p>接线图 <ahref="https://img.z4a.net/image/3-1-LED%E9%97%AA%E7%83%81.ADHhf"><imgsrc="https://img.z4a.net/images/2024/09/14/3-1-LED.md.jpeg"alt="3 1 LED闪烁" /></a></p><p>源码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="comment">//开启GPIOA的时钟</span></span><br><span class="line"><span class="comment">//使用各个外设前必须开启时钟，否则对外设的操作无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//GPIO模式，赋值为推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//GPIO引脚，赋值为第0号引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//GPIO速度，赋值为50MHz</span></span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//将赋值后的构体变量传递给GPIO_Init函数</span></span><br><span class="line"><span class="comment">//函数内部会自动根据结构体的参数配置相应寄存器</span></span><br><span class="line"><span class="comment">//实现GPIOA的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*主循环，循环体内的代码会一直循环执行*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*设置PA0引脚的高低电平，实现LED闪烁，下面展示3种方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法1：GPIO_ResetBits设置低电平，GPIO_SetBits设置高电平*/</span></span><br><span class="line">GPIO_ResetBits(GPIOA, GPIO_Pin_0);<span class="comment">//将PA0引脚设置为低电平</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">GPIO_SetBits(GPIOA, GPIO_Pin_0);<span class="comment">//将PA0引脚设置为高电平</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法2：GPIO_WriteBit设置低/高电平，由Bit_RESET/Bit_SET指定*/</span></span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);<span class="comment">//将PA0引脚设置为低电平</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);<span class="comment">//将PA0引脚设置为高电平</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法3：GPIO_WriteBit设置低/高电平，由数据0/1指定，数据需要强转为BitAction类型*/</span></span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">0</span>);<span class="comment">//将PA0引脚设置为低电平</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">1</span>);<span class="comment">//将PA0引脚设置为高电平</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);<span class="comment">//延时500ms</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="day-3-240915-led流水灯oled屏显示">DAY 3 (240915)LED流水灯+OLED屏显示</h1><h2 id="led流水灯">LED流水灯</h2><p>成果<a href="https://thumbsnap.com/PfsjbSQD" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/PfsjbSQD.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/PfsjbSQD.mp4" type="video/mp4"></video></a>接线图 <ahref="https://img.z4a.net/image/3-2-LED%E6%B5%81%E6%B0%B4%E7%81%AF.AkKlf"><imgsrc="https://img.z4a.net/images/2024/09/15/3-2-LED.md.jpeg"alt="3 2 LED流水灯" /></a> 源码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*开启时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  <span class="comment">// 开启 GPIOA 的时钟。</span></span><br><span class="line">    <span class="comment">// 使用各个外设前必须开启时钟，否则对外设的操作无效。这一步确保了对 GPIOA 的操作能够正常进行。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*GPIO 初始化*/</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;  <span class="comment">// 定义结构体变量，用于存储 GPIO 的初始化参数。</span></span><br><span class="line"></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">// GPIO 模式，设置为推挽输出模式。推挽输出模式可以输出较强的电流，适合驱动外部设备。</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;  <span class="comment">// GPIO 引脚，设置为所有引脚。这意味着将对 GPIOA 的所有引脚进行配置。</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="comment">// GPIO 速度，设置为 50MHz。不同的速度适用于不同的应用场景。</span></span><br><span class="line"></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  <span class="comment">// 将结构体变量传递给 GPIO_Init 函数，函数会根据结构体中的参数配置相应的寄存器，实现对 GPIOA 的初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*主循环，循环体内的代码会一直循环执行*/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*使用 GPIO_Write，同时设置 GPIOA 所有引脚的高低电平，实现 LED 流水灯*/</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0001</span>);  <span class="comment">// 0000 0000 0000 0001，PA0 引脚为低电平，其他引脚均为高电平，注意数据有按位取反。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。这个延时函数可能来自于引入的 &quot;Delay.h&quot; 头文件，用于控制流水灯的速度。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0002</span>);  <span class="comment">// 0000 0000 0000 0010，PA1 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0004</span>);  <span class="comment">// 0000 0000 0000 0100，PA2 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0008</span>);  <span class="comment">// 0000 0000 0000 1000，PA3 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0010</span>);  <span class="comment">// 0000 0000 0001 0000，PA4 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0020</span>);  <span class="comment">// 0000 0000 0010 0000，PA5 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0040</span>);  <span class="comment">// 0000 0000 0100 0000，PA6 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">        GPIO_Write(GPIOA, ~<span class="number">0x0080</span>);  <span class="comment">// 0000 0000 1000 0000，PA7 引脚为低电平，其他引脚均为高电平。</span></span><br><span class="line">        Delay_ms(<span class="number">100</span>);  <span class="comment">// 延时 100ms。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="oled屏显示">OLED屏显示</h2><div class="note warning flat"><p>使用OLED屏需要配置新的环境（导入新的库函数、头文件）</p></div><p>OLED屏可以实时显示设备参数，可作为监视器使用。</p><p>接线图 <ahref="https://img.z4a.net/image/4-1-OLED%E6%98%BE%E7%A4%BA%E5%B1%8F.A9aDZ"><imgsrc="https://img.z4a.net/images/2024/09/15/4-1-OLED.md.jpeg"alt="4 1 OLED显示屏" /></a></p><p>源码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*OLED显示*/</span></span><br><span class="line">OLED_ShowChar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);<span class="comment">//1行1列显示字符A</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;HelloWorld!&quot;</span>);<span class="comment">//1行3列显示字符串HelloWorld!</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">1</span>, <span class="number">12345</span>, <span class="number">5</span>);<span class="comment">//2行1列显示十进制数字12345，长度为5</span></span><br><span class="line"></span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">7</span>, <span class="number">-66</span>, <span class="number">2</span>);<span class="comment">//2行7列显示有符号十进制数字-66，长度为2</span></span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0xAA55</span>, <span class="number">4</span>);<span class="comment">//3行1列显示十六进制数字0xA5A5，长度为4</span></span><br><span class="line"></span><br><span class="line">OLED_ShowBinNum(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0xAA55</span>, <span class="number">16</span>);<span class="comment">//4行1列显示二进制数字0xA5A5，长度为16</span></span><br><span class="line"><span class="comment">//C语言无法直接写出二进制数字，故需要用十六进制表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="关于中文显示的补充-1">关于中文显示的补充-1</h3><p>成果 <a href="https://img.z4a.net/image/Oled.A9tGK"><imgsrc="https://img.z4a.net/images/2024/09/15/Oled.md.jpeg"alt="Oled" /></a></p><p>中文的显示需要手动配置头文件</p><p>在OLED.h文件中进行如下配置(仅作为示例) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_CHINESE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_CHINESE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中文字符字节宽度*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CHN_CHAR_WIDTH3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字模基本单元*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> Index[OLED_CHN_CHAR_WIDTH + <span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> Data[<span class="number">32</span>];</span><br><span class="line">&#125; ChineseCell_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字模数据*/</span></span><br><span class="line"><span class="type">const</span> ChineseCell_t OLED_CF16x16[] = &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;你&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0xF8</span>,<span class="number">0x07</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x0F</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="comment">/*0*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;好&quot;</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x1F</span>,<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0xE2</span>,<span class="number">0x92</span>,<span class="number">0x8A</span>,<span class="number">0x86</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x40</span>,<span class="number">0x22</span>,<span class="number">0x15</span>,<span class="number">0x08</span>,<span class="number">0x16</span>,<span class="number">0x61</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*1*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;，&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x58</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*2*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;世&quot;</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFE</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x47</span>,<span class="number">0x44</span>,<span class="number">0x44</span>,<span class="number">0x44</span>,<span class="number">0x47</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*3*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;界&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0xFE</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x84</span>,<span class="number">0x62</span>,<span class="number">0x1E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="comment">/*4*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;。&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*5*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;这&quot;</span>,</span><br><span class="line"><span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x42</span>,<span class="number">0xCC</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x28</span>,<span class="number">0x48</span>,<span class="number">0x89</span>,<span class="number">0x0E</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x50</span>,<span class="number">0x48</span>,<span class="number">0x44</span>,<span class="number">0x42</span>,<span class="number">0x41</span>,<span class="number">0x42</span>,<span class="number">0x44</span>,<span class="number">0x58</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="comment">/*6*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;是&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x41</span>,<span class="number">0x21</span>,<span class="number">0x1D</span>,<span class="number">0x21</span>,<span class="number">0x41</span>,<span class="number">0x81</span>,<span class="number">0xFF</span>,<span class="number">0x89</span>,<span class="number">0x89</span>,<span class="number">0x89</span>,<span class="number">0x89</span>,<span class="number">0x89</span>,<span class="number">0x81</span>,<span class="number">0x81</span>,<span class="number">0x00</span>,<span class="comment">/*7*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;汉&quot;</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x60</span>,<span class="number">0x02</span>,<span class="number">0x0C</span>,<span class="number">0xC0</span>,<span class="number">0x02</span>,<span class="number">0x1E</span>,<span class="number">0xE2</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xE2</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x7C</span>,<span class="number">0x03</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x13</span>,<span class="number">0x0C</span>,<span class="number">0x13</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="comment">/*8*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;字&quot;</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x25</span>,<span class="number">0x26</span>,<span class="number">0xA4</span>,<span class="number">0x64</span>,<span class="number">0x24</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x14</span>,<span class="number">0x0C</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x42</span>,<span class="number">0x82</span>,<span class="number">0x7F</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="comment">/*9*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;测&quot;</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x60</span>,<span class="number">0x02</span>,<span class="number">0x8C</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0xF2</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x7E</span>,<span class="number">0x01</span>,<span class="number">0x80</span>,<span class="number">0x47</span>,<span class="number">0x30</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x27</span>,<span class="number">0x00</span>,<span class="number">0x47</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*10*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;试&quot;</span>,</span><br><span class="line"><span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x42</span>,<span class="number">0xCC</span>,<span class="number">0x00</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0xFF</span>,<span class="number">0x10</span>,<span class="number">0x11</span>,<span class="number">0x16</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x10</span>,<span class="number">0x28</span>,<span class="number">0x60</span>,<span class="number">0x3F</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0x01</span>,<span class="number">0x0E</span>,<span class="number">0x30</span>,<span class="number">0x40</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="comment">/*11*/</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;程&quot;</span>,</span><br><span class="line"><span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0xA4</span>,<span class="number">0xFE</span>,<span class="number">0x23</span>,<span class="number">0x22</span>,<span class="number">0x00</span>,<span class="number">0x3E</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x3E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x08</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0xFF</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x40</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x7F</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="comment">/*12*/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*按照上面的格式，在这个位置加入新的数据*/</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;中&quot;</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x0F</span>,<span class="number">0xEF</span>,<span class="number">0xEF</span>,<span class="number">0xEF</span>,<span class="number">0xEF</span>,<span class="number">0x00</span>,<span class="number">0xEF</span>,<span class="number">0xEF</span>,<span class="number">0xEF</span>,<span class="number">0xEF</span>,<span class="number">0x0F</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xF0</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0x00</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0xF0</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;秋&quot;</span>,</span><br><span class="line"><span class="number">0xDB</span>,<span class="number">0xDB</span>,<span class="number">0x5B</span>,<span class="number">0x01</span>,<span class="number">0xDC</span>,<span class="number">0xDD</span>,<span class="number">0x7F</span>,<span class="number">0x8F</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x7F</span>,<span class="number">0xBF</span>,<span class="number">0xCF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xF7</span>,<span class="number">0xF9</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x79</span>,<span class="number">0xBF</span>,<span class="number">0xCF</span>,<span class="number">0xF1</span>,<span class="number">0xFE</span>,<span class="number">0xF9</span>,<span class="number">0xE7</span>,<span class="number">0xDF</span>,<span class="number">0xBF</span>,<span class="number">0x7F</span>,<span class="number">0xFF</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;节&quot;</span>,</span><br><span class="line"><span class="number">0xFB</span>,<span class="number">0xBB</span>,<span class="number">0xBB</span>,<span class="number">0xBB</span>,<span class="number">0xA0</span>,<span class="number">0xBB</span>,<span class="number">0x3B</span>,<span class="number">0xBB</span>,<span class="number">0xBB</span>,<span class="number">0xBB</span>,<span class="number">0xA0</span>,<span class="number">0xBB</span>,<span class="number">0x3B</span>,<span class="number">0xFB</span>,<span class="number">0xFB</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xF7</span>,<span class="number">0xEF</span>,<span class="number">0xF7</span>,<span class="number">0xF8</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;快&quot;</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0x1F</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0xEF</span>,<span class="number">0xDF</span>,<span class="number">0xF7</span>,<span class="number">0xF7</span>,<span class="number">0xF7</span>,<span class="number">0x00</span>,<span class="number">0xF7</span>,<span class="number">0xF7</span>,<span class="number">0x07</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFE</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x7E</span>,<span class="number">0xBE</span>,<span class="number">0xCE</span>,<span class="number">0xF2</span>,<span class="number">0xFC</span>,<span class="number">0xF2</span>,<span class="number">0xCE</span>,<span class="number">0xBE</span>,<span class="number">0x7E</span>,<span class="number">0x7E</span>,<span class="number">0xFF</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;乐&quot;</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x1F</span>,<span class="number">0x63</span>,<span class="number">0x7B</span>,<span class="number">0x7B</span>,<span class="number">0x7B</span>,<span class="number">0x0B</span>,<span class="number">0x7D</span>,<span class="number">0x7D</span>,<span class="number">0x7C</span>,<span class="number">0x7D</span>,<span class="number">0x7F</span>,<span class="number">0x7F</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xDF</span>,<span class="number">0xEF</span>,<span class="number">0xF7</span>,<span class="number">0xF9</span>,<span class="number">0xBF</span>,<span class="number">0x7F</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFD</span>,<span class="number">0xFB</span>,<span class="number">0xF7</span>,<span class="number">0xCF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*未定义的默认样式，请确保其位于数组最末尾*/</span></span><br><span class="line"><span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0x03</span>,<span class="number">0x05</span>,<span class="number">0x09</span>,<span class="number">0x11</span>,<span class="number">0x21</span>,<span class="number">0x41</span>,<span class="number">0x81</span>,<span class="number">0x81</span>,<span class="number">0x41</span>,<span class="number">0x21</span>,<span class="number">0x11</span>,<span class="number">0x09</span>,<span class="number">0x05</span>,<span class="number">0x03</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xC0</span>,<span class="number">0xA0</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x84</span>,<span class="number">0x82</span>,<span class="number">0x81</span>,<span class="number">0x81</span>,<span class="number">0x82</span>,<span class="number">0x84</span>,<span class="number">0x88</span>,<span class="number">0x90</span>,<span class="number">0xA0</span>,<span class="number">0xC0</span>,<span class="number">0xFF</span>,<span class="comment">/*默认*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>在OLED.c文件中定义如下函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(<span class="type">uint8_t</span> Line, <span class="type">uint8_t</span> Column, <span class="type">char</span> *Chinese)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="type">char</span> single[OLED_CHN_CHAR_WIDTH + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> ps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*依次提取每个汉字并调用显示单个汉字的函数进行显示*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; Chinese[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">single[ps] = Chinese[i];</span><br><span class="line">ps ++;</span><br><span class="line"><span class="keyword">if</span> (ps &gt;= OLED_CHN_CHAR_WIDTH)</span><br><span class="line">&#123;</span><br><span class="line">ps = <span class="number">0</span>;</span><br><span class="line">OLED_ShowSingleChinese(Line, Column + i / <span class="number">3</span> * <span class="number">2</span>, single);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;hanshu</span><br></pre></td></tr></table></figure></p><p><strong>代码解释：</strong></p><p>我重新定义了一个函数：</p><p><code>OLED_ShowChinese</code>函数的作用是在 OLED显示屏上显示中文字符串。它接受行号（<code>Line</code>）、列号（<code>Column</code>）以及一个中文字符串指针（<code>Chinese</code>）作为参数，将中文字符串逐个显示在指定位置。</p><h3 id="关于中文显示的补充-2">关于中文显示的补充-2</h3><p>上述代码中的 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;你&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0xF8</span>,<span class="number">0x07</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x0F</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="comment">/*0*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 这表示“你”显示的像素位置</p><p>获取汉字/图像的像素位置需要<code>PCtoLCD2002</code>软件。</p><p>具体使用方法见下：<ahref="https://www.bilibili.com/video/BV1EN41177Pc?p=2&amp;vd_source=da905aeb41d3bbab09f2abf41b856272">02-快速上手（下集）_哔哩哔哩_bilibili</a></p><h1 id="day-4-240916-蜂鸣器使用">DAY 4 (240916) 蜂鸣器使用</h1><h2 id="蜂鸣器使用">蜂鸣器使用</h2><p>成果<a href="https://thumbsnap.com/YR8vTJzs" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/YR8vTJzs.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/YR8vTJzs.mp4" type="video/mp4"></video></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIOB的时钟</span></span><br><span class="line"><span class="comment">//使用各个外设前必须开启时钟，否则对外设的操作无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIO初始化*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//GPIO模式，赋值为推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;<span class="comment">//GPIO引脚，赋值为第12号引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//GPIO速度，赋值为50MHz</span></span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//将赋值后的构体变量传递给GPIO_Init函数</span></span><br><span class="line"><span class="comment">//函数内部会自动根据结构体的参数配置相应寄存器</span></span><br><span class="line"><span class="comment">//实现GPIOB的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*主循环，循环体内的代码会一直循环执行*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12);<span class="comment">//将PB12引脚设置为低电平，蜂鸣器鸣叫</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);<span class="comment">//延时100ms</span></span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12);<span class="comment">//将PB12引脚设置为高电平，蜂鸣器停止</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);<span class="comment">//延时100ms</span></span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12);<span class="comment">//将PB12引脚设置为低电平，蜂鸣器鸣叫</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);<span class="comment">//延时100ms</span></span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12);<span class="comment">//将PB12引脚设置为高电平，蜂鸣器停止</span></span><br><span class="line">Delay_ms(<span class="number">700</span>);<span class="comment">//延时700ms</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">‘</span><br></pre></td></tr></table></figure><h1 id="day-5240920-gpio数字接口结构原理gpio输入按键控制led">DAY5(240920) GPIO数字接口结构原理+GPIO输入+按键控制LED</h1><h2 id="gpio数字接口结构原理">GPIO数字接口结构原理</h2><div class="note warning flat"><p>这部分内容应该在LED闪烁之前学习</p></div><p><ahref="https://blog.csdn.net/weixin_46711336/article/details/132941831">STM32基础学习——GPIO位结构（江科大老师教程）_江科大stm32教程-CSDN博客</a></p><h3 id="gpio是什么">GPIO是什么</h3><p>GPIO是一种常见的数字接口，用于连接微控制器和其他数字信号的设备。GPIO允许微控制器读取和写入数字信号，从而控制外部设备的状态和读取外部设备的输入信号。</p><p>GPIO具有多种引脚配置，可以配置为输入模式或输出模式。在输入模式下，GPIO可以读取外部设备的状态，通常通过高电平（1）或低电平（0）来表示。在输出模式下，GPIO可以控制外部设备的状态，通过输出高电平或低电平来控制设备的开关状态。</p><p>GPIO允许我们的单片机与外部世界进行通信，它是我们控制外部设备和接收外部信号的接口。</p><h3 id="gpio工作模式主要有8种">GPIO工作模式主要有8种：</h3><table><tbody><tr class="odd"><td>模式名称</td><td>性质</td><td>特征</td></tr><tr class="even"><td>浮空输入</td><td>数字输入</td><td>可读取引脚电平，若引脚悬空，则电平不确定</td></tr><tr class="odd"><td>上拉输入</td><td>数字输入</td><td>可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td></tr><tr class="even"><td>下拉输入</td><td>数字输入</td><td>可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td></tr><tr class="odd"><td>模拟输入</td><td>模拟输入</td><td>GPIO无效，引脚直接接入内部ADC</td></tr><tr class="even"><td>开漏输出</td><td>数字输出</td><td>可输出引脚电平，高电平为高阻态，低电平接VSS</td></tr><tr class="odd"><td>推挽输出</td><td>数字输出</td><td>可输出引脚电平，高电平接VDD，低电平接VSS</td></tr><tr class="even"><td>复用开漏输出</td><td>数字输出</td><td>由片上外设控制，高电平为高阻态，低电平接VSS</td></tr><tr class="odd"><td>复用推挽输出</td><td>数字输出</td><td>由片上外设控制，高电平接VDD，低电平接VSS</td></tr></tbody></table><h3 id="关于三极管原理的补充">关于三极管原理的补充</h3><p>三极管是由两个 PN 结组成的一种半导体器件。</p><p>PN 结是半导体中最重要的基本结构之一，它是由 P 型半导体和 N型半导体接触形成的。在 PN结中，由于扩散运动和漂移运动的相互作用，形成了内建电场，使得 PN结具有单向导电性。</p><p>三极管通常由三个区域组成：发射区、基区和集电区。发射区和基区之间形成的PN 结称为发射结，基区和集电区之间形成的 PN 结称为集电结。</p><p><ahref="https://blog.csdn.net/lvturancao/article/details/91365448">三极管的介绍及工作原理_三极管的作用和工作原理-CSDN博客</a><ahref="https://www.bilibili.com/video/BV1kv411574Y/?spm_id_from=333.337.search-card.all.click&amp;vd_source=da905aeb41d3bbab09f2abf41b856272">三极管是如何导电？超形象动画让你一看就懂！_哔哩哔哩_bilibili</a></p><h2 id="gpio输入">GPIO输入</h2><p><a href="https://img.z4a.net/image/GPIO%E8%BE%93%E5%85%A5.MfXnr"><imgsrc="https://img.z4a.net/images/2024/09/20/GPIO.md.png"alt="GPIO输入" /></a></p><h2 id="按键控制led">按键控制LED</h2><div class="note warning flat"><p>后续部分内容不再提供代码，因为涉及到代码封装，讲解起来较为麻烦。</p></div><p>成果<a href="https://thumbsnap.com/e1hWHKzG" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/e1hWHKzG.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/e1hWHKzG.mp4" type="video/mp4"></video></a></p><h1 id="day-6-240921-自创-光线传感器控制led灯">DAY 6 (240921)自创-光线传感器控制LED灯</h1><p><strong>这是我的第一个自己写的程序（脱离教程）</strong></p><p>光线传感器控制LED灯</p><p>成果</p><p><a href="https://thumbsnap.com/BCFkhBtj" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/BCFkhBtj.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/BCFkhBtj.mp4" type="video/mp4"></video></a></p><p><strong>main函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LIGHT-SENSOR.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LIGHT_SENSOR_Init();</span><br><span class="line">LED_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(LIGHT_SENSOR_Get()==<span class="number">1</span>)</span><br><span class="line">LED_ON();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LED_off();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LED控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef InitStructure;</span><br><span class="line"></span><br><span class="line">InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">InitStructure.GPIO_Pin=GPIO_Pin_1;</span><br><span class="line">InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA,&amp;InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>光感控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LIGHT_SENSOR_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef InitStructure;</span><br><span class="line">InitStructure.GPIO_Mode=GPIO_Mode_IPU;</span><br><span class="line">InitStructure.GPIO_Pin=GPIO_Pin_13;</span><br><span class="line">InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LIGHT_SENSOR_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIGHT_SENSOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIGHT_SENSOR_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LIGHT_SENSOR_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LIGHT_SENSOR_Get</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="day-7-240923-外部中断入门">DAY 7 (240923) 外部中断入门</h1><h2id="外部中断exti入门包括nvic介绍">外部中断(exti）入门（包括NVIC介绍）</h2><p>前面硬件部分的内容真的看不懂，感觉要数电基础。</p><p>首先先捋一下各个设备的联系 ### NVIC简介NVIC（嵌套向量中断控制器）是用于管理微控制器中断的模块，可实现中断优先级设置、中断嵌套等功能，以高效地处理各种外部和内部中断事件。<ahref="https://img.z4a.net/image/NVIC%E6%98%AFCPU%E7%9A%84%E5%B0%8F%E5%8A%A9%E6%89%8B.MzQ3j"><imgsrc="https://img.z4a.net/images/2024/09/23/NVICCPU.png"alt="NVIC是CPU的小助手" /></a> 所以exti是只是实现中断的一种手段</p><h3 id="exti">EXTI</h3><p><a href="https://img.z4a.net/image/EXTI%E7%AE%80%E4%BB%8B.MzHjk"><imgsrc="https://img.z4a.net/images/2024/09/23/EXTIf544aa51e86abc1c.png"alt="EXTI简介" /></a> <ahref="https://img.z4a.net/image/EXTI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.Mzwtz"><imgsrc="https://img.z4a.net/images/2024/09/23/EXTI.png"alt="EXTI基本结构" /></a> <ahref="https://blog.csdn.net/k666499436/article/details/124181471">中断-NVIC与EXTI外设详解(超全面)-CSDN博客</a>所以我们配置的顺序是从GPIO开始，到AFIO选择线路（总共16条从AFIO中出去），进入EXTI再到NVIC。</p><p>其中GPIOAFIO是需要开启时钟的，而NVIC是CPU直接供电的，不需要另外设置。</p><h1 id="day-8-240928-自创-旋转编码器控制led亮度">DAY 8 (240928)自创-旋转编码器控制led亮度</h1><p>成果</p><p><a href="https://thumbsnap.com/pWhfFCw3" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/pWhfFCw3.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/pWhfFCw3.mp4" type="video/mp4"></video></a></p><p>运用知识点：</p><p>1.EXTI外部中断</p><p>2.PWM输出</p><h1 id="day-9-241003-自创蓝牙控制led">DAY 9 (241003)自创—蓝牙控制LED</h1><p>成果</p><p><a href="https://thumbsnap.com/uKDTVkQs" title="Image Hosted by ThumbSnap"><video poster="https://thumbsnap.com/i/uKDTVkQs.jpg" loop muted autoplay playsinline><source src="https://thumbsnap.com/i/uKDTVkQs.mp4" type="video/mp4"></video></a></p><h1 id="补充stm32介绍这是cv过来的">补充：stm32介绍（这是CV过来的）</h1><ul><li><p><strong>一、架构与内核</strong></p></li><li><p><strong>内核类型</strong></p><ul><li>STM32 单片机采用了 ARM Cortex - M 系列内核，常见的有 Cortex -M0、Cortex - M3、Cortex - M4等。这些内核在性能、功耗和功能上有所不同，可以满足不同应用场景的需求。</li><li>例如，Cortex - M0内核具有低功耗、低成本的特点，适用于简单的控制和低功耗应用；Cortex - M3内核在性能上有了进一步提升，具备更高的处理能力和更丰富的指令集；Cortex -M4 内核则在 Cortex - M3的基础上增加了浮点运算单元，适合于需要进行复杂数学运算的场合，如数字信号处理等。</li></ul></li><li><p><strong>架构特点</strong></p><ul><li>STM32的架构采用了哈佛结构，即数据总线和指令总线分开，这样可以实现并行的数据访问和指令执行，提高了运行效率。</li><li>它还具备嵌套向量中断控制器（NVIC），可以实现快速的中断响应和灵活的中断优先级设置。这对于实时性要求较高的应用非常关键，例如在电机控制中，能够及时响应电机的过流、过压等异常情况，保证系统的安全运行。</li></ul></li></ul><p><strong>二、硬件资源</strong></p><ul><li><p><strong>时钟系统</strong></p><ul><li>STM32 单片机拥有复杂而灵活的时钟系统。它可以使用内部时钟源（如内部RC 振荡器）或外部时钟源（如外部晶振）来提供系统时钟。</li><li>通过时钟配置寄存器，可以对时钟进行分频、倍频等操作，以满足不同外设和系统运行的时钟需求。例如，在低功耗模式下，可以降低系统时钟频率以降低功耗；在需要高速数据处理时，可以提高时钟频率来提升系统性能。</li></ul></li><li><p><strong>GPIO（通用输入 / 输出）</strong></p><ul><li>STM32 具有丰富的 GPIO引脚，这些引脚可以配置为输入或输出模式，并且具有多种输入输出模式可供选择，如推挽输出、开漏输出、浮空输入、上拉输入、下拉输入等。</li><li>GPIO 的复用功能使得一个引脚可以用于多种不同的外设功能，例如，一个GPIO引脚既可以作为普通的数字输入输出引脚，也可以复用为定时器的输入捕获引脚、串口的发送或接收引脚等，大大提高了引脚的使用效率。</li></ul></li><li><p><strong>定时器</strong></p><ul><li>STM32单片机内置了多个定时器，包括基本定时器、通用定时器和高级定时器。</li><li>基本定时器主要用于产生定时中断，可用于简单的定时任务，如定时采样传感器数据等。通用定时器除了具备基本定时器的功能外，还可以实现输入捕获和输出比较功能。例如，在电机控制中，可以利用输入捕获功能测量电机的转速，通过输出比较功能生成PWM（脉冲宽度调制）信号来控制电机的转速和转向。高级定时器则在通用定时器的基础上增加了更多的功能，如死区时间插入等，适用于三相电机控制等复杂应用。</li></ul></li><li><p><strong>串口通信</strong></p><ul><li>STM32 支持多种串口通信协议，如 USART（通用同步 /异步收发器）、UART（通用异步收发器）、SPI（串行外设接口）和I2C（内部集成电路总线）等。</li><li>USART 和 UART 常用于与其他设备进行异步串行通信，如与 PC机进行数据传输、与其他单片机或微控制器进行通信等。SPI是一种高速同步串行通信协议，常用于与外部的高速外设进行通信，如与 Flash存储器、显示屏等进行数据传输。I2C则是一种多主从的同步串行通信协议，适用于连接多个低速外设，如温度传感器、EEPROM等。</li></ul></li><li><p><strong>ADC（模数转换器）和 DAC（数模转换器）</strong></p><ul><li>许多 STM32 型号都集成了 ADC 和 DAC 模块。ADC用于将模拟信号（如传感器输出的电压、电流等模拟信号）转换为数字信号，以便单片机进行处理。</li><li>STM32 的 ADC通常具有多通道，可以同时对多个模拟信号进行采样，并且采样精度可以达到 12位甚至更高。DAC则是将数字信号转换为模拟信号，例如在音频播放系统中，可以将数字音频信号通过DAC 转换为模拟音频信号输出到扬声器。</li></ul></li><li><p><strong>其他外设</strong></p><ul><li>除了上述主要的硬件资源外，STM32 单片机还可能配备其他外设，如CAN（控制器局域网络）控制器，用于汽车电子等领域的通信；USB 接口，方便与USB 设备进行连接和通信；外部中断 /事件控制器，用于响应外部事件的触发等。</li></ul></li></ul><p><strong>三、开发环境与编程</strong></p><ul><li><p><strong>开发环境</strong></p><ul><li>STM32 的开发通常使用 Keil MDK、IAR Embedded Workbench等集成开发环境（IDE）。</li><li>这些 IDE 提供了代码编辑、编译、调试等一站式开发服务。例如，Keil MDK集成了编译器、调试器和仿真器等工具，并且支持 C、C++等编程语言。在开发过程中，开发者可以在 IDE中方便地编写代码、设置编译选项、进行在线调试等操作。</li></ul></li><li><p><strong>编程语言</strong></p><ul><li>主要使用 C 语言和 C++语言进行编程，也可以使用汇编语言进行底层的优化和特殊功能的实现。</li><li>C语言是最常用的编程语言，它具有高效、灵活、可移植性好等优点。对于一些对性能要求较高的场合，可以使用汇编语言来编写部分关键代码，以进一步提高程序的运行效率。</li></ul></li></ul><p><strong>四、应用领域</strong></p><ul><li><p><strong>工业控制</strong></p><ul><li>在工业自动化领域，STM32 单片机可用于控制各种工业设备，如PLC（可编程逻辑控制器）、工业机器人、数控机床等。</li><li>例如，在工业机器人中，STM32可以实现对机器人关节电机的精确控制，包括电机的转速、位置和转矩控制等。通过采集机器人关节的位置传感器数据，利用STM32 的定时器和 ADC 等外设进行处理，并根据控制算法输出 PWM信号来驱动电机，实现机器人的精确运动控制。</li></ul></li><li><p><strong>消费电子</strong></p><ul><li>广泛应用于消费电子产品中，如智能手机、平板电脑、智能手环、智能家居设备等。</li><li>在智能手环中，STM32单片机负责采集各种传感器（如加速度计、心率传感器等）的数据，进行数据处理和分析，然后将处理后的结果（如运动步数、心率等）通过蓝牙等无线通信方式传输到手机等设备上进行显示和进一步分析。</li></ul></li><li><p><strong>汽车电子</strong></p><ul><li>在汽车电子系统中，STM32可用于发动机控制、车身电子稳定系统（ESP）、车载娱乐系统等方面。</li><li>例如，在发动机控制系统中，STM32单片机通过采集发动机的各种传感器（如曲轴位置传感器、氧传感器等）的数据，实时计算和调整燃油喷射量、点火提前角等参数，以保证发动机的高效运行和低排放。</li></ul></li><li><p><strong>物联网（IoT）</strong></p><ul><li>作为物联网设备的核心控制器，STM32单片机可以连接各种传感器和执行器，实现设备之间的互联互通。</li><li>在智能农业物联网系统中，STM32单片机可以采集土壤湿度、温度、光照强度等环境参数，通过无线通信模块（如LoRa、NB - IoT等）将数据传输到云端进行分析和处理，同时根据云端的指令控制灌溉设备、遮阳设备等执行器的动作，实现农业生产的智能化管理。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python语言程序设计基础</title>
      <link href="/2024/09/10/python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/09/10/python%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周基础语法">【第一周】基础语法</h1><h3id="简答题-输出1到100之间的所有质数">1. (简答题) 输出1到100之间的所有质数。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">100</span>):  </span><br><span class="line">    flag=<span class="literal">True</span>  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num):  </span><br><span class="line">        <span class="keyword">if</span> num%i==<span class="number">0</span>:  </span><br><span class="line">            flag=<span class="literal">False</span>  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> flag:  </span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="简答题-判断回文数">2. (简答题) 判断回文数</h3><p>判断一个字符串是否是回文字符串（正着读和倒着读都一样），如果是则输出"是回文字符串"，否则输出"不是回文字符串"。</p><p>程序字符串通过input输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="built_in">input</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>)  </span><br><span class="line">length=<span class="built_in">len</span>(string)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):  </span><br><span class="line">    flag=<span class="literal">True</span>  </span><br><span class="line">    <span class="keyword">if</span> string[<span class="number">0</span>+i]!=string[-<span class="number">1</span>-i]:  </span><br><span class="line">        flag=<span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> flag:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;是回文字符串&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不是回文字符串&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="简答题-计算斐波那契数列的前10个数并输出">3. (简答题)计算斐波那契数列的前10个数并输出。</h3><p>计算斐波那契数列的前10个数并输出。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a,b=<span class="number">0</span>,<span class="number">1</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  </span><br><span class="line">    <span class="built_in">print</span>(a)  </span><br><span class="line">    a,b=b,a+b</span><br></pre></td></tr></table></figure></p><h3 id="简答题-检查数字">4. (简答题) 检查数字</h3><p>判断一个字符串中是否包含数字，如果包含则输出"包含数字"，否则输出"不包含数字"。使用input输入字符串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="built_in">input</span>(<span class="string">&quot;输入字符串：&quot;</span>)  </span><br><span class="line">length=<span class="built_in">len</span>(<span class="built_in">str</span>)  </span><br><span class="line">  </span><br><span class="line">flag=<span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i]&gt;=<span class="string">&quot;0&quot;</span> <span class="keyword">and</span> <span class="built_in">str</span>[i]&lt;=<span class="string">&quot;9&quot;</span>:  </span><br><span class="line">        flag=<span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> flag:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;包含数字&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不包含数字&quot;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="简答题-有效手机号码">5. (简答题) 有效手机号码</h3><p>检查一个字符串是否是有效的手机号码（11位数字，以1开头），如果是则输出"有效手机号码"，否则输出"无效手机号码"。使用input输入手机号码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="built_in">input</span>(<span class="string">&quot;输入手机号码：&quot;</span>)  </span><br><span class="line">length=<span class="built_in">len</span>(num)  </span><br><span class="line">flag=<span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> num[<span class="number">0</span>]!=<span class="number">1</span> <span class="keyword">or</span> length!=<span class="number">11</span>:  </span><br><span class="line">    flag=<span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> flag:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有效手机号码&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无效手机号码&quot;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="第二周">【第二周】</h1>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 杭电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团体程序设计天梯赛-练习集</title>
      <link href="/2024/09/08/%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86/"/>
      <url>/2024/09/08/%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>pta的c语言练习（自己找的，仅供学习）</p><p>本文不会提供所有的题目与代码</p><p>网址 <ahref="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805147132084224&amp;page=0">L1-001Hello World - 团体程序设计天梯赛-练习集 (pintia.cn)</a></p><h1 id="l1-005-考试座位号">L1-005 考试座位号</h1><p>每个 PAT考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p><h3 id="输入格式">输入格式：</h3><p>输入第一行给出一个正整数 N（≤1000），随后 N行，每行给出一个考生的信息：<code>准考证号 试机座位号 考试座位号</code>。其中<code>准考证号</code>由16 位数字组成，座位从 1 到 N编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p><p>考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M个待查询的试机座位号码，以空格分隔。</p><h3 id="输出格式">输出格式：</h3><p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用1 个空格分隔。</p><h3 id="输入样例">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3310120150912233 2 4</span><br><span class="line">3310120150912119 4 1</span><br><span class="line">3310120150912126 1 3</span><br><span class="line">3310120150912002 3 2</span><br><span class="line">2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3310120150912002 2</span><br><span class="line">3310120150912119 1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> id[<span class="number">17</span>];  <span class="comment">//数字过大不能用int型</span></span><br><span class="line"><span class="type">int</span> tryseat;</span><br><span class="line"><span class="type">int</span> examseat;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">students</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>,students[i].id,&amp;students[i].tryseat,&amp;students[i].examseat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[m];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(students[j].tryseat==arr[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,students[j].id,students[j].examseat);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="l1-006-连续因子">L1-006 连续因子</h1><p>一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p><h3 id="输入格式-1">输入格式：</h3><p>输入在一行中给出一个正整数 N（1&lt;N&lt;231）。</p><h3 id="输出格式-1">输出格式：</h3><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按<code>因子1*因子2*……*因子k</code>的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p><h3 id="输入样例-1">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">630</span><br></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5*6*7</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个代码拿不了满分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;  <span class="comment">//此处用int型也没有问题</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i, j, len = <span class="number">0</span>, start = <span class="number">0</span>, tempLen, tempStart;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sqrtN = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= sqrtN; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= sqrtN; j++) &#123;</span><br><span class="line">            temp *= j;</span><br><span class="line">            <span class="keyword">if</span> (n % temp!= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n%lld&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, len);</span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; start + len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld*&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, start + len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="l1-010-比较大小">L1-010 比较大小</h1><p>本题要求将输入的任意3个整数从小到大输出。</p><h3 id="输入格式-2">输入格式:</h3><p>输入在一行中给出3个整数，其间以空格分隔。</p><h3 id="输出格式-2">输出格式:</h3><p>在一行中将3个整数从小到大输出，其间以“-&gt;”相连。</p><h3 id="输入样例-2">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2 8</span><br></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2-&gt;4-&gt;8</span><br></pre></td></tr></table></figure><p>我的代码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleSort(arr,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AI的代码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AI</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取用户输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d-&gt;%d&quot;</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="l1-023-输出gplt">L1-023 输出GPLT</h1><p>给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按<code>GPLTGPLT....</code>这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按<code>GPLT</code>的顺序打印，直到所有字符都被输出。</p><h3 id="输入格式-3">输入格式：</h3><p>输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。</p><h3 id="输出格式-3">输出格式：</h3><p>在一行中按题目要求输出排序后的字符串。题目保证输出非空。</p><h3 id="输入样例-3">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcTclnGloRgLrtLhgljkLhGFauPewSKgt</span><br></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPLTGPLTGLTGLGLL</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10001</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="comment">// 定义一个整数数组，分别存储 G、P、L、T 的个数，初始值为 0</span></span><br><span class="line">    <span class="type">int</span> counts[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="built_in">tolower</span>(str[i]);</span><br><span class="line">        <span class="comment">// 根据字符判断并更新相应的计数</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;g&#x27;</span>) counts[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;p&#x27;</span>) counts[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;l&#x27;</span>) counts[<span class="number">2</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;t&#x27;</span>) counts[<span class="number">3</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环输出字符，直到所有计数都为 0</span></span><br><span class="line">    <span class="keyword">while</span> (counts[<span class="number">0</span>] &gt; <span class="number">0</span> || counts[<span class="number">1</span>] &gt; <span class="number">0</span> || counts[<span class="number">2</span>] &gt; <span class="number">0</span> || counts[<span class="number">3</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 G 的计数大于 0，输出 G 并减少 G 的计数</span></span><br><span class="line">        <span class="keyword">if</span> (counts[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;G&#x27;</span>); counts[<span class="number">0</span>]--; &#125;</span><br><span class="line">        <span class="comment">// 如果 P 的计数大于 0，输出 P 并减少 P 的计数</span></span><br><span class="line">        <span class="keyword">if</span> (counts[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;P&#x27;</span>); counts[<span class="number">1</span>]--; &#125;</span><br><span class="line">        <span class="comment">// 如果 L 的计数大于 0，输出 L 并减少 L 的计数</span></span><br><span class="line">        <span class="keyword">if</span> (counts[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;L&#x27;</span>); counts[<span class="number">2</span>]--; &#125;</span><br><span class="line">        <span class="comment">// 如果 T 的计数大于 0，输出 T 并减少 T 的计数</span></span><br><span class="line">        <span class="keyword">if</span> (counts[<span class="number">3</span>] &gt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;T&#x27;</span>); counts[<span class="number">3</span>]--; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24级杭电先修课PTA作业</title>
      <link href="/2024/08/24/24%E7%BA%A7%E6%9D%AD%E7%94%B5%E5%85%88%E4%BF%AE%E8%AF%BEPTA%E4%BD%9C%E4%B8%9A/"/>
      <url>/2024/08/24/24%E7%BA%A7%E6%9D%AD%E7%94%B5%E5%85%88%E4%BF%AE%E8%AF%BEPTA%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>这是pta的c语言练习</p><p>由于本人能力有限，后面个别题目未提供代码。可参考<ahref="https://zyzblog.com/post/42283b9e.html">张跃哲同学的代码</a><span id="more"></span></p><h1 id="section">2024-1</h1><h2 id="最好的文档">最好的文档</h2><p>有一位软件工程师说过一句很有道理的话：“Good code is its own bestdocumentation.”（好代码本身就是最好的文档）。本题就请你直接在屏幕上输出这句话。</p><h3 id="输入格式">输入格式：</h3><p>本题没有输入。</p><h3 id="输出格式">输出格式：</h3><p>在一行中输出<code>Good code is its own best documentation.</code>。</p><h3 id="输入样例">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Good code is its own best documentation.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good code is its own best documentation.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动编程">自动编程</h2><p>输出语句是每个程序员首先要掌握的语句。Python的输出语句很简单，只要写一个 <code>print(X)</code> 即可，其中<code>X</code> 是需要输出的内容。</p><p>本题就请你写一个自动编程机，对任何一个要输出的整数N，给出输出这个整数的 Python 语句。</p><h3 id="输入格式-1">输入格式：</h3><p>输入给出一个不超过 105 的正整数。</p><h3 id="输出格式-1">输出格式：</h3><p>在一行中打印输出这个整数的 Python 语句，其中不包含任何空格。</p><h3 id="输入样例-1">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">520</span><br></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(520)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;print(%d)&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是机器学习">什么是机器学习</h2><p>什么是机器学习？上图展示了一段面试官与“机器学习程序”的对话：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">面试官：9 +<span class="number"> 10 </span>等于多少？</span><br><span class="line">答：3</span><br><span class="line">面试官：差远了，是19。</span><br><span class="line">答：16</span><br><span class="line">面试官：错了，是19。</span><br><span class="line">答：18</span><br><span class="line">面试官：不，是19。</span><br><span class="line">答：19</span><br></pre></td></tr></table></figure><p>本题就请你模仿这个“机器学习程序”的行为。</p><h3 id="输入格式-2">输入格式：</h3><p>输入在一行中给出两个整数，绝对值都不超过100，中间用一个空格分开，分别表示面试官给出的两个数字 A 和 B。</p><h3 id="输出格式-2">输出格式：</h3><p>要求你输出 4 行，每行一个数字。第 1 行比正确结果少 16，第 2 行少3，第 3 行少 1，最后一行才输出 A+B 的正确结果。</p><h3 id="输入样例-2">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">16</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b<span class="number">-16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b<span class="number">-3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="section-1">2024-2</h1><h2 id="是不是太胖了">是不是太胖了</h2><p>据说一个人的标准体重应该是其身高（单位：厘米）减去100、再乘以0.9所得到的公斤数。已知市斤的数值是公斤数值的两倍。现给定某人身高，请你计算其标准体重应该是多少？（顺便也悄悄给自己算一下吧……）</p><h3 id="输入格式-3">输入格式：</h3><p>输入第一行给出一个正整数<code>H</code>（100 &lt; H ≤300），为某人身高。</p><h3 id="输出格式-3">输出格式：</h3><p>在一行中输出对应的标准体重，单位为市斤，保留小数点后1位。</p><h3 id="输入样例-3">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169</span><br></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">124.2</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="type">double</span> w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h);</span><br><span class="line">w=(h<span class="number">-100</span>)*<span class="number">0.9</span>*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算存款利息">计算存款利息</h2><p>本题目要求计算存款利息，计算公式为interest=money×(1+rate)year−money，其中interest为存款到期时的利息（税前），money是存款金额，year是存期，rate是年利率。</p><h3 id="输入格式-4">输入格式：</h3><p>输入在一行中顺序给出三个正实数money、year和rate，以空格分隔。</p><h3 id="输出格式-4">输出格式：</h3><p>在一行中按“interest = 利息”的格式输出，其中利息保留两位小数。</p><h3 id="输入样例-4">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 3 0.025</span><br></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interest = 76.89</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> m,y,r,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>,&amp;m,&amp;y,&amp;r);</span><br><span class="line">i=m*<span class="built_in">pow</span>((<span class="number">1</span>+r),y)-m;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;interest = %.2lf&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算摄氏温度">计算摄氏温度</h2><p>给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C=5×(F−32)/9。题目保证输入与输出均在整型范围内。</p><h3 id="输入格式-5">输入格式:</h3><p>输入在一行中给出一个华氏温度。</p><h3 id="输出格式-5">输出格式:</h3><p>在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。</p><h3 id="输入样例-5">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">150</span><br></pre></td></tr></table></figure><h3 id="输出样例-5">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Celsius = 65</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c,f;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f);</span><br><span class="line">c=<span class="number">5</span>*(f<span class="number">-32</span>)/<span class="number">9</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Celsius = %d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="section-2">2024-3</h1><h2 id="程序员买包子">程序员买包子</h2><figure><imgsrc="https://images.ptausercontent.com/a35ac075-7709-4ff7-b7ce-6d2208afc6af.jpg"alt="bao.jpg" /><figcaption aria-hidden="true">bao.jpg</figcaption></figure><p>这是一条检测真正程序员的段子：假如你被家人要求下班顺路买十只包子，如果看到卖西瓜的，买一只。那么你会在什么情况下只买一只包子回家？<br />本题要求你考虑这个段子的通用版：假如你被要求下班顺路买 N只包子，如果看到卖 X 的，买 M 只。那么如果你最后买了 K只包子回家，说明你看到卖 X 的没有呢？</p><h3 id="输入格式-6">输入格式：</h3><p>输入在一行中顺序给出题面中的 N、X、M、K，以空格分隔。其中 N、M 和 K为不超过 1000 的正整数，X 是一个长度不超过 10的、仅由小写英文字母组成的字符串。题目保证 N=M。</p><h3 id="输出格式-6">输出格式：</h3><p>在一行中输出结论，格式为：</p><ul><li>如果 K=N，输出 <code>mei you mai X de</code>；</li><li>如果 K=M，输出 <code>kan dao le mai X de</code>；</li><li>否则输出 <code>wang le zhao mai X de</code>.<br />其中 <code>X</code> 是输入中给定的字符串 X。</li></ul><h3 id="输入样例-1-1">输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 xigua 1 10</span><br></pre></td></tr></table></figure><h3 id="输出样例-1-1">输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mei you mai xigua de</span><br></pre></td></tr></table></figure><h3 id="输入样例-2-1">输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 huanggua 1 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-2-1">输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kan dao le mai huanggua de</span><br></pre></td></tr></table></figure><h3 id="输入样例-3-1">输入样例 3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 shagua 1 250</span><br></pre></td></tr></table></figure><h3 id="输出样例-3-1">输出样例 3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wang le zhao mai shagua de</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N,M,K;</span><br><span class="line">    <span class="type">char</span> X[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d %d&quot;</span>,&amp;N,&amp;X,&amp;M,&amp;K);</span><br><span class="line">    <span class="keyword">if</span>(K==N)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mei you mai %s de&quot;</span>,X);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(K==M)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kan dao le mai %s de&quot;</span>,X);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wang le zhao mai %s de&quot;</span>,X);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新胖子公式">新胖子公式</h2><p>根据钱江晚报官方微博的报导，最新的肥胖计算方法为：体重(kg) / 身高(m)的平方。如果超过25，你就是胖子。于是本题就请你编写程序自动判断一个人到底算不算胖子。</p><h3 id="输入格式-7">输入格式：</h3><p>输入在一行中给出两个正数，依次为一个人的体重（以 kg为单位）和身高（以 m 为单位），其间以空格分隔。其中体重不超过 1000kg，身高不超过 3.0 m。</p><h3 id="输出格式-7">输出格式：</h3><p>首先输出将该人的体重和身高代入肥胖公式的计算结果，保留小数点后 1位。如果这个数值大于 25，就在第二行输出 <code>PANG</code>，否则输出<code>Hai Xing</code>。</p><h3 id="输入样例-1-2">输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100.1 1.74</span><br></pre></td></tr></table></figure><h3 id="输出样例-1-2">输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.1</span><br><span class="line">PANG</span><br></pre></td></tr></table></figure><h3 id="输入样例-2-2">输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65 1.70</span><br></pre></td></tr></table></figure><h3 id="输出样例-2-2">输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22.5</span><br><span class="line">Hai Xing</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> l,w,r;</span><br><span class="line"><span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>,&amp;w,&amp;l);</span><br><span class="line">r=w/<span class="built_in">pow</span>(l,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s,r&gt;<span class="number">25</span>?<span class="string">&quot;PANG&quot;</span>:<span class="string">&quot;Hai Xing&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n%s&quot;</span>,r,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="真的恭喜你">真的恭喜你</h2><p>当别人告诉你自己考了 x 分的时候，你要回答说：“恭喜你考了 x分！”比如小明告诉你他考了90分，你就用汉语拼音打出来<code>gong xi ni kao le 90 fen!</code>。</p><p>但是如果小明没考好，比如只考了 20分，你也“恭喜”人家就不对了。这时候你应该安慰他说：“考了 20分别泄气！”用汉语拼音写出来就是<code>kao le 20 fen bie xie qi!</code>。</p><h3 id="输入格式-8">输入格式：</h3><p>输入在一行里给出一位小朋友的分数。这个分数是一个 0 到 100之间的整数。</p><h3 id="输出格式-8">输出格式：</h3><p>在一行中输出你对这位小朋友说的话。如果人家考到不低于 90 分，就说<code>gong xi ni kao le X fen!</code>；如果不到 90 分，就说<code>kao le X fen bie xie qi!</code>。其中 <code>X</code>是小朋友输入的分数。</p><h3 id="输入样例-1-3">输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95</span><br></pre></td></tr></table></figure><h3 id="输出样例-1-3">输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gong xi ni kao le 95 fen!</span><br></pre></td></tr></table></figure><h3 id="输入样例-2-3">输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89</span><br></pre></td></tr></table></figure><h3 id="输出样例-2-3">输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kao le 89 fen bie xie qi</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">if</span> (a&lt;<span class="number">90</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;kao le %d fen bie xie qi!&quot;</span>,a);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gong xi ni kao le %d fen!&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个三位数是否为水仙花数">判断一个三位数是否为水仙花数</h2><p>本题要求编写程序，判断一个给定的三位数是否为水仙花数。三位水仙花数，即其个位、十位、百位数字的立方和等于该数本身。</p><h3 id="输入格式-9">输入格式:</h3><p>输入在一行中给出一个需要判断的整数 N（100≤N≤999）。</p><h3 id="输出格式-9">输出格式:</h3><p>如果N是水仙花数，则在一行中输出<code>Yes</code>，否则输出<code>No</code>。如果N不是三位数，则输出<code>Invalid Value.</code>。</p><h3 id="输入样例1">输入样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">153</span><br></pre></td></tr></table></figure><h3 id="输出样例1">输出样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例2">输入样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500</span><br></pre></td></tr></table></figure><h3 id="输出样例2">输出样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="输入样例3">输入样例3:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2</span><br></pre></td></tr></table></figure><h3 id="输出样例3">输出样例3:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid Value.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,a1,a2,a3;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">a1=a/<span class="number">100</span>;</span><br><span class="line">a2=(a/<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">a3=a%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (a&gt;=<span class="number">100</span>&amp;&amp;a&lt;<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">if</span> (a==<span class="built_in">pow</span>(a1,<span class="number">3</span>)+<span class="built_in">pow</span>(a2,<span class="number">3</span>)+<span class="built_in">pow</span>(a3,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Invalid Value.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="成绩转换">成绩转换</h2><p>本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则：</p><ul><li>大于等于90分为A；</li><li>小于90且大于等于80为B；</li><li>小于80且大于等于70为C；</li><li>小于70且大于等于60为D；</li><li>小于60为E。</li></ul><h3 id="输入格式-10">输入格式:</h3><p>输入在一行中给出一个整数的百分制成绩。</p><h3 id="输出格式-10">输出格式:</h3><p>在一行中输出对应的五分制成绩。</p><h3 id="输入样例-6">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><h3 id="输出样例-6">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">90</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">80</span>&amp;&amp;a&lt;<span class="number">90</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">70</span>&amp;&amp;a&lt;<span class="number">80</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">60</span>&amp;&amp;a&lt;<span class="number">70</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a&lt;<span class="number">60</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五级制成绩">五级制成绩</h2><h3 id="任务描述">任务描述</h3><p>五级制成绩表示法可以这样来理解，A代表[90-100]、B代表[80-90)、C代表[70-80)、D代表[60-70)、E代表[0-60)。<br />给出五级制成绩(一个字符)，请输出这个字符所代表的分数范围。</p><h3 id="输入格式-11">输入格式:</h3><p>一个大写的英文字符，代表五级制成绩。</p><h3 id="输出格式-11">输出格式:</h3><p>在一行中输出该成绩所表示的整数成绩范围区间，如果该字符不在五级制定义范围之内，输出：ERROR。</p><h3 id="输入样例1-1">输入样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h3 id="输出样例1-1">输出样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[90-100]</span><br></pre></td></tr></table></figure><h3 id="输入样例2-1">输入样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D</span><br></pre></td></tr></table></figure><h3 id="输出样例2-1">输出样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[60-70)</span><br></pre></td></tr></table></figure><h3 id="输入样例3-1">输入样例3:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X</span><br></pre></td></tr></table></figure><h3 id="输出样例3-1">输出样例3:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[90-100]&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[80-90)&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[70-80)&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[60-70)&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[0-60)&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出星期名">输出星期名</h2><p>请编写程序，输入星期数，输出对应的英文星期名。</p><table><tbody><tr class="odd"><td><strong>星期数</strong></td><td><strong>星期名</strong></td></tr><tr class="even"><td>0</td><td>Sunday</td></tr><tr class="odd"><td>1</td><td>Monday</td></tr><tr class="even"><td>2</td><td>Tuesday</td></tr><tr class="odd"><td>3</td><td>Wednesday</td></tr><tr class="even"><td>4</td><td>Thursday</td></tr><tr class="odd"><td>5</td><td>Friday</td></tr><tr class="even"><td>6</td><td>Saturday</td></tr></tbody></table><h4 id="输入格式-12">输入格式</h4><blockquote><p>w</p></blockquote><h4 id="输出格式-12">输出格式</h4><blockquote><p>若 w 在 0 ~ 6 范围内，则输出星期名 若 w 在 0 ~ 6范围外，则输出None</p></blockquote><h4 id="输入样例1-2">输入样例1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例1-2">输出样例1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wednesday</span><br></pre></td></tr></table></figure><h4 id="输入样例2-2">输入样例2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h4 id="输出样例2-2">输出样例2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">None</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> s[<span class="number">8</span>][<span class="number">1000</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">7</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s[a]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="section-3">2024-4</h1><h2 id="电子汪">电子汪</h2><p>据说汪星人的智商能达到人类 4岁儿童的水平，更有些聪明汪会做加法计算。比如你在地上放两堆小球，分别有 1只球和 2 只球，聪明汪就会用“汪！汪！汪！”表示 1 加 2 的结果是 3。</p><p>本题要求你为电子宠物汪做一个模拟程序，根据电子眼识别出的两堆小球的个数，计算出和，并且用汪星人的叫声给出答案。</p><h3 id="输入格式-13">输入格式：</h3><p>输入在一行中给出两个 [1, 9] 区间内的正整数 A 和 B，用空格分隔。</p><h3 id="输出格式-13">输出格式：</h3><p>在一行中输出 A + B 个<code>Wang!</code>。</p><h3 id="输入样例-7">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-7">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wang!Wang!Wang!</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a+b;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wang!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬动的蠕虫">爬动的蠕虫</h2><p>一条蠕虫长1寸，在一口深为N寸的井的底部。已知蠕虫每1分钟可以向上爬U寸，但必须休息1分钟才能接着往上爬。在休息的过程中，蠕虫又下滑了D寸。就这样，上爬和下滑重复进行。请问，蠕虫需要多长时间才能爬出井？</p><p>这里要求不足1分钟按1分钟计，并且假定只要在某次上爬过程中蠕虫的头部到达了井的顶部，那么蠕虫就完成任务了。初始时，蠕虫是趴在井底的（即高度为0）。</p><h3 id="输入格式-14">输入格式：</h3><p>输入在一行中顺序给出3个正整数N、U、D，其中D&lt;U，N不超过100。</p><h3 id="输出格式-14">输出格式：</h3><p>在一行中输出蠕虫爬出井的时间，以分钟为单位。</p><h3 id="输入样例-8">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-8">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> N, U, D;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;N, &amp;U, &amp;D);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (position &lt; N) &#123;</span><br><span class="line">        position += U;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= N) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        position -= D;</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约分最简分式">约分最简分式</h2><p>分数可以表示为<code>分子/分母</code>的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。</p><h3 id="输入格式-15">输入格式：</h3><p>输入在一行中给出一个分数，分子和分母中间以斜杠<code>/</code>分隔，如：<code>12/34</code>表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。</p><p><strong>提示：</strong></p><ul><li>对于C语言，在<code>scanf</code>的格式字符串中加入<code>/</code>，让<code>scanf</code>来处理这个斜杠。</li><li>对于Python语言，用<code>a,b=map(int, input().split('/'))</code>这样的代码来处理这个斜杠。</li></ul><h3 id="输出格式-15">输出格式：</h3><p>在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用<code>分子/分母</code>的形式表示分数。如<br /><code>5/6</code>表示6分之5。</p><h3 id="输入样例-9">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">66/120</span><br></pre></td></tr></table></figure><h3 id="输出样例-9">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11/20</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> temp=b;</span><br><span class="line">        b=a%b;</span><br><span class="line">        a=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> y=calculate(a,b);</span><br><span class="line"></span><br><span class="line">    a/=y;</span><br><span class="line">    b/=y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>,a,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找250">寻找250</h2><p><img src="https://images.ptausercontent.com/365" /></p><p>对方不想和你说话，并向你扔了一串数……而你必须从这一串数字中找到“250”这个高大上的感人数字。</p><h3 id="输入格式-16">输入格式：</h3><p>输入在一行中给出不知道多少个绝对值不超过1000的整数，其中保证至少存在一个“250”。</p><h3 id="输出格式-16">输出格式：</h3><p>在一行中输出第一次出现的“250”是对方扔过来的第几个数字（计数从1开始）。题目保证输出的数字在整型范围内。</p><h3 id="输入样例-10">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">888 666 123 -233 250 13 250 -222</span><br></pre></td></tr></table></figure><h3 id="输出样例-10">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,a[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">if</span> (a[i]==<span class="number">250</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="降价提醒机器人">降价提醒机器人</h2><p>小 T想买一个玩具很久了，但价格有些高，他打算等便宜些再买。但天天盯着购物网站很麻烦，请你帮小T写一个降价提醒机器人，当玩具的当前价格比他设定的价格便宜时发出提醒。</p><h3 id="输入格式-17">输入格式：</h3><p>输入第一行是两个正整数 N 和 M (1≤N≤100,0≤M≤1000)，表示有 N条价格记录，小 T 设置的价格为 M。</p><p>接下来 N 行，每行有一个实数Pi​（−1000.0&lt;Pi​&lt;1000.0），表示一条价格记录。</p><h3 id="输出格式-17">输出格式：</h3><p>对每一条比设定价格 M 便宜的价格记录 <code>P</code>，在一行中输出<code>On Sale! P</code>，其中 <code>P</code> 输出到小数点后 1 位。</p><h3 id="输入样例-11">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 99</span><br><span class="line">98.0</span><br><span class="line">97.0</span><br><span class="line">100.2</span><br><span class="line">98.9</span><br></pre></td></tr></table></figure><h3 id="输出样例-11">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On Sale! 98.0</span><br><span class="line">On Sale! 97.0</span><br><span class="line">On Sale! 98.9</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,i;</span><br><span class="line"><span class="type">double</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;m)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;On Sale! %.1lf\n&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求特殊方程的正整数解">求特殊方程的正整数解</h2><p>本题要求对任意给定的正整数N，求方程X2+Y2=N的全部正整数解。</p><h3 id="输入格式-18">输入格式：</h3><p>输入在一行中给出正整数N（≤10000）。</p><h3 id="输出格式-18">输出格式：</h3><p>输出方程X2+Y2=N的全部正整数解，其中X≤Y。每组解占1行，两数字间以1空格分隔，按X的递增顺序输出。如果没有解，则输出<code>No Solution</code>。</p><h3 id="输入样例1-3">输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">884</span><br></pre></td></tr></table></figure><h3 id="输出样例1-3">输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 28</span><br><span class="line">20 22</span><br></pre></td></tr></table></figure><h3 id="输入样例2-3">输入样例2：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="输出样例2-3">输出样例2：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">No Solution</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">1</span>;x&lt;=<span class="built_in">sqrt</span>(n);x++) &#123;</span><br><span class="line">        <span class="type">int</span> y = (<span class="type">int</span>)<span class="built_in">sqrt</span>(n-x*x);</span><br><span class="line">        <span class="keyword">if</span> (x*x+y*y==n&amp;&amp;x&lt;=y) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算阶乘和">计算阶乘和</h2><p>对于给定的正整数N，需要你计算 S=1!+2!+3!+...+N!。</p><h3 id="输入格式-19">输入格式：</h3><p>输入在一行中给出一个不超过10的正整数N。</p><h3 id="输出格式-19">输出格式：</h3><p>在一行中输出S的值。</p><h3 id="输入样例-12">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出样例-12">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">result*=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> num,i,sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;num+<span class="number">1</span>;i++)&#123;</span><br><span class="line">sum+=jc(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="section-4">2024-5</h1><h2 id="大笨钟的心情">大笨钟的心情</h2><figure><imgsrc="https://images.ptausercontent.com/8c3b8713-1703-4e56-addb-492f738c3a7c.jpg"alt="心情.jpg" /><figcaption aria-hidden="true">心情.jpg</figcaption></figure><p>有网友问：未来还会有更多大笨钟题吗？笨钟回复说：看心情……</p><p>本题就请你替大笨钟写一个程序，根据心情自动输出回答。</p><h3 id="输入格式-20">输入格式：</h3><p>输入在一行中给出 24 个 [0, 100] 区间内的整数，依次代表大笨钟在一天 24小时中，每个小时的心情指数。</p><p>随后若干行，每行给出一个 [0, 23]之间的整数，代表网友询问笨钟这个问题的时间点。当出现非法的时间点时，表示输入结束，这个非法输入不要处理。题目保证至少有1 次询问。</p><h3 id="输出格式-20">输出格式：</h3><p>对每一次提问，如果当时笨钟的心情指数大于 50，就在一行中输出<code>心情指数 Yes</code>，否则输出 <code>心情指数 No</code>。</p><h3 id="输入样例-13">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">80 75 60 50 20 20 20 20 55 62 66 51 42 33 47 58 67 52 41 20 35 49 50 63</span><br><span class="line">17</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">15</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="输出样例-13">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">52 Yes</span><br><span class="line">20 No</span><br><span class="line">50 No</span><br><span class="line">58 Yes</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> moodIndices[<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;moodIndices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;time);</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span> || time &gt; <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> moodIndex = moodIndices[time];</span><br><span class="line">        <span class="keyword">if</span> (moodIndex &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d Yes\n&quot;</span>, moodIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d No\n&quot;</span>, moodIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求最大值及其下标">求最大值及其下标</h2><p>本题要求编写程序，找出给定的n个数中的最大值及其对应的最小下标（下标从0开始）。</p><h3 id="输入格式-21">输入格式:</h3><p>输入在第一行中给出一个正整数n（1&lt;n≤10）。第二行输入n个整数，用空格分开。</p><h3 id="输出格式-21">输出格式:</h3><p>在一行中输出最大值及最大值的最小下标，中间用一个空格分开。</p><h3 id="输入样例-14">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2 8 10 1 9 10</span><br></pre></td></tr></table></figure><h3 id="输出样例-14">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 2</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r=a[<span class="number">0</span>],index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;r)&#123;</span><br><span class="line">r=a[i];</span><br><span class="line">index=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,r,index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计分数段人数">统计分数段人数</h2><p>请对某次考试的分数，统计各分数段人数,统计原则:分别对10分以下、10-19分、20-29分、30-39分、40-49分、50-59分、60-69分、70-79,80-89分,90到99分，100分为一段,共11段。<br />注意：如果输入分数不在[0,100]之间，不参与统计。</p><h3 id="输入格式-22">输入格式:</h3><p>先输入一个整数n,表示将输入n个分数。<br />再输入n个分数,范围在[0~100].<br />每个数用空格间隔。</p><h3 id="输出格式-22">输出格式:</h3><p>每一行输出一个分数段的人数统计结果。分数段用0~10表示。</p><h3 id="输入样例-15">输入样例:</h3><p>在这里给出一组输入。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">50 60 98 100 0 1000</span><br></pre></td></tr></table></figure><h3 id="输出样例-15">输出样例:</h3><p>在这里给出相应的输出。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: 1</span><br><span class="line">1: 0</span><br><span class="line">2: 0</span><br><span class="line">3: 0</span><br><span class="line">4: 0</span><br><span class="line">5: 1</span><br><span class="line">6: 1</span><br><span class="line">7: 0</span><br><span class="line">8: 0</span><br><span class="line">9: 1</span><br><span class="line">10: 1</span><br></pre></td></tr></table></figure><p>我的版本（比较繁琐） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b0=<span class="number">0</span>,b1=<span class="number">0</span>,b2=<span class="number">0</span>,b3=<span class="number">0</span>,b4=<span class="number">0</span>,b5=<span class="number">0</span>,b6=<span class="number">0</span>,b7=<span class="number">0</span>,b8=<span class="number">0</span>,b9=<span class="number">0</span>,b10=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">switch</span> ((<span class="type">int</span>)(a[i]/<span class="number">10</span>))&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:b0++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:b1++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:b2++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:b3++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:b4++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:b5++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:b6++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:b7++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:b8++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:b9++;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:b10++;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0: %d\n1: %d\n2: %d\n3: %d\n4: %d\n5: %d\n6: %d\n7: %d\n8: %d\n9: %d\n10: %d&quot;</span>,b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2id="c程序设计教程与实训-数组-查找k出现次数">C程序设计教程与实训-数组-查找k出现次数</h2><p>从键盘输入10个整数，将其存入数组中，输入一个整数k，在数组中查找k出现的次数。</p><h3 id="输入格式-23">输入格式:</h3><p>在第一行输入10个整数（在int类型的范围内），在第二行输入要查找的整数k。</p><h3 id="输出格式-23">输出格式:</h3><p>k出现的次数。如果未出现，输出0。</p><h3 id="输入样例-16">输入样例:</h3><p>在这里给出一组输入。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 13 45 13 45 34 67 12 12 78</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="输出样例-16">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k,count=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==k)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求矩阵的局部极大值">求矩阵的局部极大值</h2><p>给定M行N列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。</p><h3 id="输入格式-24">输入格式：</h3><p>输入在第一行中给出矩阵A的行数M和列数N（3≤M,N≤20）；最后M行，每行给出A在该行的N个元素的值。数字间以空格分隔。</p><h3 id="输出格式-24">输出格式：</h3><p>每行按照“元素值 行号列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None总行数 总列数”。</p><h3 id="输入样例1-4">输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 3 9 3 1</span><br><span class="line">1 5 3 5 1</span><br><span class="line">1 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="输出样例1-4">输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9 2 3</span><br><span class="line">5 3 2</span><br><span class="line">5 3 4</span><br></pre></td></tr></table></figure><h3 id="输入样例2-4">输入样例2：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">3</span> <span class="number">9</span> <span class="number">9</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-4">输出样例2：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">None</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> m=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line"><span class="type">int</span> a[m][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]&gt;a[i<span class="number">-1</span>][j]&amp;&amp;a[i][j]&gt;a[i+<span class="number">1</span>][j]&amp;&amp;a[i][j]&gt;a[i][j<span class="number">-1</span>]&amp;&amp;a[i][j]&gt;a[i][j+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a[i][j], i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;None %d %d&quot;</span>,m,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印杨辉三角">打印杨辉三角</h2><p>本题要求按照规定格式打印前N行杨辉三角。</p><h3 id="输入格式-25">输入格式：</h3><p>输入在一行中给出N（1≤N≤10）。</p><h3 id="输出格式-25">输出格式：</h3><p>以正三角形的格式输出前N行杨辉三角。每个数字占固定4位。</p><h3 id="输入样例-17">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="输出样例-17">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">    1   1</span><br><span class="line">   1   2   1</span><br><span class="line">  1   3   3   1</span><br><span class="line"> 1   4   6   4   1</span><br><span class="line">1   5  10  10   5   1</span><br></pre></td></tr></table></figure><p>目前我的版本存在格式问题 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure> 张跃哲同学的版本<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> N;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);  </span><br><span class="line">    <span class="type">int</span> triangle[N][N];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;  </span><br><span class="line">                triangle[i][j] = <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                triangle[i][j] = triangle[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i<span class="number">-1</span>][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 打印杨辉三角  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (N - i - <span class="number">1</span>); j++) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 打印每一行的数字  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, triangle[i][j]); <span class="comment">// 每个数字占4个字符宽度  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="section-5">2024-6</h1><h2id="使用函数输出一个整数的逆序数函数题">使用函数输出一个整数的逆序数（函数题）</h2><p>本题要求实现一个求整数的逆序数的简单函数。</p><h3 id="函数接口定义">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">( <span class="type">int</span> number )</span></span>;</span><br></pre></td></tr></table></figure><p>其中函数<code>reverse</code>须返回用户传入的整型<code>number</code>的逆序数。</p><h3 id="裁判测试程序样例">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">( <span class="type">int</span> number )</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">reverse</span>(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-18">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-12340</span><br></pre></td></tr></table></figure><h3 id="输出样例-18">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-4321</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">( <span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num!= <span class="number">0</span>) &#123;</span><br><span class="line">        r=r*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用函数求最大公约数函数题">使用函数求最大公约数（函数题）</h2><p>本题要求实现一个计算两个数的最大公约数的简单函数。</p><h3 id="函数接口定义-1">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>x</code>和<code>y</code>是两个正整数，函数<code>gcd</code>应返回这两个数的最大公约数。</p><h3 id="裁判测试程序样例-1">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">gcd</span>(x, y));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-19">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32 72</span><br></pre></td></tr></table></figure><h3 id="输出样例-19">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y )</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (y!= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp=y;</span><br><span class="line">        y=x%y;</span><br><span class="line">        x=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用函数的选择法排序函数题">使用函数的选择法排序（函数题）</h2><p>本题要求实现一个用选择法对整数数组进行简单排序的函数。</p><h3 id="函数接口定义-2">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> n )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>a</code>是待排序的数组，<code>n</code>是数组<code>a</code>中元素的个数。该函数用选择法将数组<code>a</code>中的元素按升序排列，结果仍然在数组<code>a</code>中。</p><h3 id="裁判测试程序样例-2">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">int</span> a[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n; i++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After sorted the array is:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-20">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5 1 7 6</span><br></pre></td></tr></table></figure><h3 id="输出样例-20">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">After sorted the array is: 1 5 6 7</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> n )</span>&#123;</span><br><span class="line"><span class="type">int</span> i, j, min_idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min_idx])</span><br><span class="line">                min_idx = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_idx!= i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[min_idx];</span><br><span class="line">            a[min_idx] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求排列数函数题">求排列数（函数题）</h2><p>本题要求实现一个计算阶乘的简单函数，使得可以利用该函数，根据公式Pnm​=(n−m)!n!​算出从n个不同元素中取出m个元素（0&lt;m≤n）的排列数。</p><h3 id="函数接口定义-3">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">fact</span><span class="params">( <span class="type">int</span> n )</span></span>;</span><br></pre></td></tr></table></figure><p>其中n是用户传入的参数，函数返回n的阶乘。</p><h3 id="裁判测试程序样例-3">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fact</span><span class="params">( <span class="type">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">double</span> result; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; m &lt;= n)&#123;</span><br><span class="line">        result = <span class="built_in">fact</span>(n)/<span class="built_in">fact</span>(n-m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;result = %.0f\n&quot;</span>, result);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里填写答案 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-21">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 14</span><br></pre></td></tr></table></figure><h3 id="输出样例-21">输出样例：</h3><p>在这里给出相应的输出。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = 182</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fact</span><span class="params">( <span class="type">int</span> n )</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">result*=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="section-6">2024-7</h1><h2 id="一元二次方程求根程序填空题">一元二次方程求根（程序填空题）</h2><p>输入三个整数a，b，c（a不为0），输出一元二次方程ax^2+bx+c=0的根。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">double</span> *p1,<span class="type">double</span> *p2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> d=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=<span class="number">0</span>)&#123;       </span><br><span class="line">        </span><br><span class="line">*p1=(-b+<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a);            </span><br><span class="line">        </span><br><span class="line">*p2=(-b-<span class="built_in">sqrt</span>(d))/(<span class="number">2</span>*a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                     </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">double</span>  x1,x2; </span><br><span class="line">    <span class="type">int</span> a,b,c;   </span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line">    flag=root(a,b,c,&amp;x1,&amp;x2);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f %.2f\n&quot;</span>,x1,x2); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找最高分程序填空题">查找最高分（程序填空题）</h2><p>输入10个成绩，查找最高分并输出。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">GetMax</span><span class="params">(<span class="type">int</span> score[ ], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, score[<span class="number">10</span>], *p;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    p = GetMax(score, <span class="number">10</span>);</span><br><span class="line"> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">GetMax</span><span class="params">(<span class="type">int</span> score[ ], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, max, pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    max = score[<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(score[i] &gt; max)&#123;</span><br><span class="line">            max = score[i];</span><br><span class="line">            pos = i ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &amp;score[pos];</span><br><span class="line"> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2id="求二维数组中偶数元素之和程序填空题">求二维数组中偶数元素之和（程序填空题）</h2><p>下面这段程序是计算并打印一个二维数组（数组的数组）中值为偶数的元素之和。题目保证输入的元素均为绝对值不超过10000的整数。请填写空缺的代码。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumEven</span><span class="params">(<span class="type">int</span> (*<span class="built_in">array</span>)[<span class="number">5</span>], <span class="type">int</span> row)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> ((*<span class="built_in">array</span>)[i * <span class="number">5</span> + j] % <span class="number">2</span> == <span class="number">0</span>) sum += (*<span class="built_in">array</span>)[i * <span class="number">5</span> + j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sumEven(<span class="built_in">array</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计算两数的和与差函数题">计算两数的和与差（函数题）</h2><p>本题要求实现一个计算输入的两数的和与差的简单函数。</p><h3 id="函数接口定义-4">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_diff</span><span class="params">( <span class="type">float</span> op1, <span class="type">float</span> op2, <span class="type">float</span> *psum, <span class="type">float</span> *pdiff )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>op1</code>和<code>op2</code>是输入的两个实数，<code>*psum</code>和<code>*pdiff</code>是计算得出的和与差。</p><h3 id="裁判测试程序样例-4">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_diff</span><span class="params">( <span class="type">float</span> op1, <span class="type">float</span> op2, <span class="type">float</span> *psum, <span class="type">float</span> *pdiff )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a, b, sum, diff;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">sum_diff</span>(a, b, &amp;sum, &amp;diff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum is %.2f\nThe diff is %.2f\n&quot;</span>, sum, diff);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-22">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="输出样例-22">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The sum is 10.00</span><br><span class="line">The diff is -2.00</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum_diff</span><span class="params">( <span class="type">float</span> op1, <span class="type">float</span> op2, <span class="type">float</span> *psum, <span class="type">float</span> *pdiff )</span>&#123;</span><br><span class="line">*psum=op1+op2;</span><br><span class="line">*pdiff=op1-op2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="拆分实数的整数与小数部分函数题">拆分实数的整数与小数部分（函数题）</h2><p>本题要求实现一个拆分实数的整数与小数部分的简单函数。</p><h3 id="函数接口定义-5">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splitfloat</span><span class="params">( <span class="type">float</span> x, <span class="type">int</span> *intpart, <span class="type">float</span> *fracpart )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>x</code>是被拆分的实数（0≤<code>x</code>&lt;10000），<code>*intpart</code>和<code>*fracpart</code>分别是将实数x拆分出来的整数部分与小数部分。</p><h3 id="裁判测试程序样例-5">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splitfloat</span><span class="params">( <span class="type">float</span> x, <span class="type">int</span> *intpart, <span class="type">float</span> *fracpart )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x, fracpart;</span><br><span class="line">    <span class="type">int</span> intpart;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">splitfloat</span>(x, &amp;intpart, &amp;fracpart);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The integer part is %d\n&quot;</span>, intpart);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The fractional part is %g\n&quot;</span>, fracpart);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-23">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.718</span><br></pre></td></tr></table></figure><h3 id="输出样例-23">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The integer part is 2</span><br><span class="line">The fractional part is 0.718</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">splitfloat</span><span class="params">( <span class="type">float</span> x, <span class="type">int</span> *intpart, <span class="type">float</span> *fracpart )</span>&#123;</span><br><span class="line">*intpart=(<span class="type">int</span>)x;</span><br><span class="line">*fracpart=x-*intpart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="使用函数找出数组中的最大值函数题">使用函数找出数组中的最大值（函数题）</h2><p>本题要求实现一个找出整型数组中最大值的函数。</p><h3 id="函数接口定义-6">函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindArrayMax</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> n )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>a</code>是用户传入的数组，<code>n</code>是数组<code>a</code>中元素的个数。函数返回数组<code>a</code>中的最大值。</p><h3 id="裁判测试程序样例-6">裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindArrayMax</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">int</span> a[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">FindArrayMax</span>(a, n));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里填写答案 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-24">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">20 78 99 -14</span><br></pre></td></tr></table></figure><h3 id="输出样例-24">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindArrayMax</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> n )</span>&#123;</span><br><span class="line"><span class="type">int</span> max=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">max=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态内存中数据排序">动态内存中数据排序</h2><h4 id="任务描述-1">任务描述:</h4><p>读入整数N，再读入N个整数，将这N个整数从小到大排序后输出。（不能定义整型数组，用动态内存技术实现）</p><h4 id="输入样例-25">输入样例:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 4 2</span><br></pre></td></tr></table></figure><h4 id="输出样例-25">输出样例:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##动态数组（需要多大内存申请多大内存） #### 任务描述：</p><p>输入整数N，再输入N个整数，将这N个整数倒序输出。（不用定义数组，用动态内存实现）</p><h4 id="输入样例-26">输入样例:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><h4 id="输出样例-26">输出样例:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure><h4 id="输入样例-27">输入样例:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15</span><br><span class="line">708 417 427 843 610 838 932 978 189 981 208 618 178 872 576</span><br></pre></td></tr></table></figure><h4 id="输出样例-27">输出样例:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">576 872 178 618 208 981 189 978 932 838 610 843 427 417 708</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, i, num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        arr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(arr, (i + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        arr[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i!=n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="section-7">2024-8</h1><h2 id="时间计算程序填空题">时间计算（程序填空题）</h2><p>下列程序读入时间数值，将其加1秒后输出，时间格式为：hh: mm:ss，即“小时:分钟:秒”，当小时等于24小时，置为0。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> hour, minute, second;</span><br><span class="line">&#125; time;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>, &amp;time.hour, &amp;time.minute, &amp;time.second);</span><br><span class="line">    time.second++;</span><br><span class="line">    <span class="keyword">if</span>(time.second == <span class="number">60</span>)&#123;</span><br><span class="line">        time.second = <span class="number">0</span>;</span><br><span class="line">        time.minute++;</span><br><span class="line">        <span class="keyword">if</span>(time.minute == <span class="number">60</span>)&#123;</span><br><span class="line">            time.minute = <span class="number">0</span>;</span><br><span class="line">            time.hour++;</span><br><span class="line">            <span class="keyword">if</span>(time.hour == <span class="number">24</span>)</span><br><span class="line">                time.hour = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, time.hour, time.minute, time.second);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分段统计学生成绩程序填空题">分段统计学生成绩（程序填空题）</h2><p>输入n个学生的姓名和百分制成绩，分段统计学生的成绩。</p><h3 id="输入格式-26">输入格式：</h3><p>输入在第一行中给出正整数N（1≤n≤100）。随后N行，每行给出一位学生的姓名和成绩，中间以空格分隔。</p><h3 id="输出格式-26">输出格式：</h3><p>在一行中顺序输出成绩为80－100分、60－79分、0－59分的学生人数，中间以空格分隔。</p><h3 id="输入样例-28">输入样例：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">5</span></span><br><span class="line"><span class="attribute">huanglan</span> <span class="number">83</span></span><br><span class="line"><span class="attribute">wanghai</span> <span class="number">76</span></span><br><span class="line"><span class="attribute">shenqiang</span> <span class="number">50</span></span><br><span class="line"><span class="attribute">zhangfeng</span> <span class="number">95</span></span><br><span class="line"><span class="attribute">zhangmeng</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-28">输出样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cnt_score</span><span class="params">(<span class="keyword">struct</span> student *p, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[<span class="title">MAXN</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, stu[i].name, &amp;stu[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt_score(stu, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cnt_score</span><span class="params">(<span class="keyword">struct</span> student *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt_a = <span class="number">0</span>, cnt_p = <span class="number">0</span>, cnt_f = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">q</span> =</span> p + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt;= q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;score &gt;= <span class="number">80</span> &amp;&amp; p-&gt;score &lt;= <span class="number">100</span>) cnt_a++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;score &gt;= <span class="number">60</span> &amp;&amp; p-&gt;score &lt;= <span class="number">79</span>) cnt_p++;</span><br><span class="line">        <span class="keyword">else</span> cnt_f++;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, cnt_a, cnt_p, cnt_f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有理数均值">有理数均值</h2><h3 id="输入格式-27">输入格式：</h3><p>输入第一行给出正整数N（≤100）；第二行中按照<code>a1/b1 a2/b2 …</code>的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。</p><h3 id="输出格式-27">输出格式：</h3><p>在一行中按照<code>a/b</code>的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。</p><h3 id="输入样例1-5">输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1/2 1/6 3/6 -5/10</span><br></pre></td></tr></table></figure><h3 id="输出样例1-5">输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1/6</span><br></pre></td></tr></table></figure><h3 id="输入样例2-5">输入样例2：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span></span><br><span class="line"><span class="attribute">4</span>/<span class="number">3</span> <span class="number">2</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-5">输出样例2：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="找出总分最高的学生">找出总分最高的学生</h2><p>给定N个学生的基本信息，包括学号（由5个数字组成的字符串）、姓名（长度小于10的不包含空白字符的非空字符串）和3门课程的成绩（[0,100]区间内的整数），要求输出总分最高学生的姓名、学号和总分。</p><h3 id="输入格式-28">输入格式：</h3><p>输入在一行中给出正整数N（≤10）。随后N行，每行给出一位学生的信息，格式为“学号姓名 成绩1 成绩2 成绩3”，中间以空格分隔。</p><h3 id="输出格式-28">输出格式：</h3><p>在一行中输出总分最高学生的姓名、学号和总分，间隔一个空格。题目保证这样的学生是唯一的。</p><h3 id="输入样例-29">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">00001 huanglan 78 83 75</span><br><span class="line">00002 wanghai 76 80 77</span><br><span class="line">00003 shenqiang 87 83 76</span><br><span class="line">10001 zhangfeng 92 88 78</span><br><span class="line">21987 zhangmeng 80 82 75</span><br></pre></td></tr></table></figure><h3 id="输出样例-29">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangfeng 10001 258</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">6</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">11</span>];</span><br><span class="line">    <span class="type">int</span> score1;</span><br><span class="line">    <span class="type">int</span> score2;</span><br><span class="line">    <span class="type">int</span> score3;</span><br><span class="line">    <span class="type">int</span> totalScore;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[<span class="title">n</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %d %d %d&quot;</span>, students[i].id, students[i].name, &amp;students[i].score1, &amp;students[i].score2, &amp;students[i].score3);</span><br><span class="line">        students[i].totalScore = students[i].score1 + students[i].score2 + students[i].score3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (students[i].totalScore &gt; students[maxIndex].totalScore) &#123;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s %d\n&quot;</span>, students[maxIndex].name, students[maxIndex].id, students[maxIndex].totalScore);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通讯录排序">通讯录排序</h2><p>输入n个朋友的信息，包括姓名、生日、电话号码，本题要求编写程序，按照年龄从大到小的顺序依次输出通讯录。题目保证所有人的生日均不相同。</p><h3 id="输入格式-29">输入格式:</h3><p>输入第一行给出正整数n（&lt;10）。随后n行，每行按照“姓名 生日电话号码”的格式给出一位朋友的信息，其中“姓名”是长度不超过10的英文字母组成的字符串，“生日”是<code>yyyymmdd</code>格式的日期，“电话号码”是不超过17位的数字及<code>+</code>、<code>-</code>组成的字符串。</p><h3 id="输出格式-29">输出格式:</h3><p>按照年龄从大到小输出朋友的信息，格式同输出。</p><h3 id="输入样例-30">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">zhang 19850403 13912345678</span><br><span class="line">wang 19821020 +86-0571-88018448</span><br><span class="line">qian 19840619 13609876543</span><br></pre></td></tr></table></figure><h3 id="输出样例-30">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wang 19821020 +86-0571-88018448</span><br><span class="line">qian 19840619 13609876543</span><br><span class="line">zhang 19850403 13912345678</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Friend</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">11</span>];</span><br><span class="line">    <span class="type">int</span> birthday;</span><br><span class="line">    <span class="type">char</span> phoneNumber[<span class="number">18</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于按照 yyyymmdd 格式的生日进行从大到小排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Friend</span>* <span class="title">f1</span> =</span> (<span class="keyword">struct</span> Friend*)a;  <span class="comment">// 将 void 指针转换为 Friend 结构体指针 f1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Friend</span>* <span class="title">f2</span> =</span> (<span class="keyword">struct</span> Friend*)b;  <span class="comment">// 将 void 指针转换为 Friend 结构体指针 f2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year1 = f1-&gt;birthday / <span class="number">10000</span>;  <span class="comment">// 提取 f1 生日中的年份</span></span><br><span class="line">    <span class="type">int</span> month1 = (f1-&gt;birthday % <span class="number">10000</span>) / <span class="number">100</span>;  <span class="comment">// 提取 f1 生日中的月份</span></span><br><span class="line">    <span class="type">int</span> day1 = f1-&gt;birthday % <span class="number">100</span>;  <span class="comment">// 提取 f1 生日中的日期</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year2 = f2-&gt;birthday / <span class="number">10000</span>;  <span class="comment">// 提取 f2 生日中的年份</span></span><br><span class="line">    <span class="type">int</span> month2 = (f2-&gt;birthday % <span class="number">10000</span>) / <span class="number">100</span>;  <span class="comment">// 提取 f2 生日中的月份</span></span><br><span class="line">    <span class="type">int</span> day2 = f2-&gt;birthday % <span class="number">100</span>;  <span class="comment">// 提取 f2 生日中的日期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先比较年份</span></span><br><span class="line">    <span class="keyword">if</span> (year2 &gt; year1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (year2 &lt; year1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 年份相同，比较月份</span></span><br><span class="line">        <span class="keyword">if</span> (month2 &gt; month1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month2 &lt; month1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 月份相同，比较日期</span></span><br><span class="line">            <span class="keyword">if</span> (day2 &gt; day1) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (day2 &lt; day1) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 日期也相同，返回 0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);  <span class="comment">// 输入朋友的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Friend</span> <span class="title">friends</span>[<span class="title">n</span>];</span>  <span class="comment">// 创建结构体数组来存储朋友的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 循环输入每个朋友的信息</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %s&quot;</span>, friends[i].name, &amp;friends[i].birthday, friends[i].phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(friends, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Friend), compare);  <span class="comment">// 对朋友结构体数组进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 循环输出排序后的朋友信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s\n&quot;</span>, friends[i].name, friends[i].birthday, friends[i].phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一帮一">一帮一</h2><p>“一帮一学习小组”是中小学中常见的学习组织方式，老师把学习成绩靠前的学生跟学习成绩靠后的学生排在一组。本题就请你编写程序帮助老师自动完成这个分配工作，即在得到全班学生的排名后，在当前尚未分组的学生中，将名次最靠前的学生与名次最靠后的<strong>异性</strong>学生分为一组。</p><h3 id="输入格式-30">输入格式：</h3><p>输入第一行给出正偶数<code>N</code>（≤50），即全班学生的人数。此后<code>N</code>行，按照名次从高到低的顺序给出每个学生的性别（0代表女生，1代表男生）和姓名（不超过8个英文字母的非空字符串），其间以1个空格分隔。这里保证本班男女比例是1:1，并且没有并列名次。</p><h3 id="输出格式-30">输出格式：</h3><p>每行输出一组两个学生的姓名，其间以1个空格分隔。名次高的学生在前，名次低的学生在后。小组的输出顺序按照前面学生的名次从高到低排列。</p><h3 id="输入样例-31">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0 Amy</span><br><span class="line">1 Tom</span><br><span class="line">1 Bill</span><br><span class="line">0 Cindy</span><br><span class="line">0 Maya</span><br><span class="line">1 John</span><br><span class="line">1 Jack</span><br><span class="line">0 Linda</span><br></pre></td></tr></table></figure><h3 id="输出样例-31">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Amy Jack</span><br><span class="line">Tom Linda</span><br><span class="line">Bill Maya</span><br><span class="line">Cindy John</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="section-8">2024-9</h1><h2 id="删除重复字符">删除重复字符</h2><p>本题要求编写程序，将给定字符串去掉重复的字符后，按照字符ASCII码顺序从小到大排序后输出。</p><h3 id="输入格式-31">输入格式：</h3><p>输入是一个以回车结束的非空字符串（少于80个字符）。</p><h3 id="输出格式-31">输出格式：</h3><p>输出去重排序后的结果字符串。</p><h3 id="输入样例-32">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad2f3adjfeainzzzv</span><br></pre></td></tr></table></figure><h3 id="输出样例-32">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23adefijnvz</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输出gplt"> 输出GPLT</h2><p>给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按<code>GPLTGPLT....</code>这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按<code>GPLT</code>的顺序打印，直到所有字符都被输出。</p><h3 id="输入格式-32">输入格式：</h3><p>输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。</p><h3 id="输出格式-32">输出格式：</h3><p>在一行中按题目要求输出排序后的字符串。题目保证输出非空。</p><h3 id="输入样例-33">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcTclnGloRgLrtLhgljkLhGFauPewSKgt</span><br></pre></td></tr></table></figure><h3 id="输出样例-33">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPLTGPLTGLTGLGLL</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count_g = <span class="number">0</span>, count_p = <span class="number">0</span>, count_l = <span class="number">0</span>, <span class="type">count_t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="built_in">tolower</span>(str[i]);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;g&#x27;</span>) count_g++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;p&#x27;</span>) count_p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;l&#x27;</span>) count_l++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;t&#x27;</span>) <span class="type">count_t</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count_g &gt; <span class="number">0</span> || count_p &gt; <span class="number">0</span> || count_l &gt; <span class="number">0</span> || <span class="type">count_t</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count_g &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str[index++] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            count_g--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count_p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str[index++] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">            count_p--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count_l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str[index++] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            count_l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">count_t</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str[index++] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">            <span class="type">count_t</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str[index] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="a-b">A-B</h2><p>本题要求你计算A−B。不过麻烦的是，A和B都是字符串 ——即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。</p><h3 id="输入格式-33">输入格式：</h3><p>输入在2行中先后给出字符串A和B。两字符串的长度都不超过104，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。</p><h3 id="输出格式-33">输出格式：</h3><p>在一行中打印出A−B的结果字符串。</p><h3 id="输入样例-34">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love GPLT!  It&#x27;s a fun game!</span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure><h3 id="输出样例-34">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I lv GPLT!  It&#x27;s  fn gm!</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 检查密码</span><br><span class="line"></span><br><span class="line">本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于<span class="number">6</span>个字符组成，并且只能有英文字母、数字和小数点 `.`，还必须既有字母也有数字。</span><br><span class="line"></span><br><span class="line">### 输入格式：</span><br><span class="line"></span><br><span class="line">输入第一行给出一个正整数 N（≤ <span class="number">100</span>），随后 N 行，每行给出一个用户设置的密码，为不超过 <span class="number">80</span> 个字符的非空字符串，以回车结束。</span><br><span class="line"></span><br><span class="line">**注意：** 题目保证不存在只有小数点的输入。</span><br><span class="line"></span><br><span class="line">### 输出格式：</span><br><span class="line"></span><br><span class="line">对每个用户的密码，在一行中输出系统反馈信息，分以下<span class="number">5</span>种：</span><br><span class="line"></span><br><span class="line">- 如果密码合法，输出`Your password is wan mei.`；</span><br><span class="line">- 如果密码太短，不论合法与否，都输出`Your password is tai duan le.`；</span><br><span class="line">- 如果密码长度合法，但存在不合法字符，则输出`Your password is tai luan le.`；</span><br><span class="line">- 如果密码长度合法，但只有字母没有数字，则输出`Your password needs shu zi.`；</span><br><span class="line">- 如果密码长度合法，但只有数字没有字母，则输出`Your password needs zi mu.`。</span><br><span class="line"></span><br><span class="line">### 输入样例：</span><br><span class="line"></span><br><span class="line">```in</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">123</span>s</span><br><span class="line">zheshi.wodepw</span><br><span class="line"><span class="number">1234.5678</span></span><br><span class="line">WanMei23333</span><br><span class="line">pass*word<span class="number">.6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-35">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Your password is tai duan le.</span><br><span class="line">Your password needs shu zi.</span><br><span class="line">Your password needs zi mu.</span><br><span class="line">Your password is wan mei.</span><br><span class="line">Your password is tai luan le.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 杭电 </tag>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24级杭电《C语言程序设计》先修课-mooc作业</title>
      <link href="/2024/08/24/24%E7%BA%A7%E6%9D%AD%E7%94%B5%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%85%88%E4%BF%AE%E8%AF%BE-mooc%E4%BD%9C%E4%B8%9A/"/>
      <url>/2024/08/24/24%E7%BA%A7%E6%9D%AD%E7%94%B5%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%85%88%E4%BF%AE%E8%AF%BE-mooc%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>这是笔者的c语言学习记录 内容覆盖c语言入门的基础知识已完结，后续会补充代码的注释</p><p><strong>声明</strong></p><p>本文章内容请未完成的同学谨慎查看。以下代码的发布时间均在考试截止时间之后，未构成作弊。 <span id="more"></span></p><h1 id="第一章-c语言概述">第一章 C语言概述</h1><h2 id="welcome-to-hdu">“Welcome to HDU!”</h2><p><strong>题目要求：</strong><br />本题要求编写程序，输出一个短句 “Welcome to HDU!”。</p><p><strong>输入格式:</strong> 本题目没有输入。</p><p><strong>输出格式：</strong><br />在一行中输出短句 “Welcome to HDU!”（引号无需输出） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to HDU!&quot;</span>);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="加法运算">加法运算</h2><p><strong>题目内容：</strong><br />输入两个整数，计算、输出两数之和</p><p><strong>输入格式:</strong><br />输入一行，包含用空格分隔的两个整数（32 位 int 整数）</p><p><strong>输出格式：</strong><br />输出一个整数，表示两数之和（32 位 int 整数） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">int</span> a, b;   </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="标准体重">标准体重</h2><p><strong>题目内容：</strong><br />据说一个人的标准体重应该是其身高（单位：厘米）减去 100、再乘以 0.9所得到的公斤数。现给定某人身高，请你计算其标准体重应该是多少？</p><p><strong>输入格式:</strong><br />输入第一行给出一个正整数 H（100 &lt; H ≤ 300），为某人身高。</p><p><strong>输出格式:</strong><br />在一行中输出对应的标准体重，单位为公斤，保留小数点后 1 位。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> height; <span class="comment">// 定义一个整型变量，用于存储身高  </span></span><br><span class="line">    <span class="type">float</span> standard_weight; <span class="comment">// 定义一个浮点型变量，用于存储标准体重  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 读取身高值  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;height);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算标准体重  </span></span><br><span class="line">    standard_weight = (height - <span class="number">100</span>) * <span class="number">0.9</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 输出标准体重，保留小数点后一位  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>, standard_weight);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 表示程序成功执行  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第二章-基本数据类型和输入输出">第二章基本数据类型和输入输出</h1><h2 id="面积公式">面积公式</h2><p><strong>题目内容:</strong><br />请编写程序，输入三角形的底 和高，计算并输出三角形的面积。</p><p><strong>输入格式</strong><br />一行包含两个正实数，空格分隔，表示底和高</p><p><strong>输出格式</strong><br />一个实数，2 位小数</p><p><strong>输入样例</strong><br />1.5 2.4</p><p><strong>输出样例:</strong><br />1.80 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">double</span> base, height;  </span><br><span class="line">    <span class="comment">// 读取底边和高度  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;base, &amp;height);  </span><br><span class="line">    <span class="comment">// 计算三角形的面积  </span></span><br><span class="line">    <span class="type">double</span> area = (base * height) / <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">// 输出面积，保留两位小数  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, area);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="加减乘除">加减乘除</h2><p><strong>题目内容:</strong><br />本题要求编写程序，计算并输出 2个正整数的和、差、积。题目保证输入和输出全部在整型范围内。输入格式:<br />输入在一行中给出 2 个正整数 A 和 B。</p><p><strong>输出格式:</strong><br />分行按照格式 “A 运算符 B = 结果” 顺序输出和、差、积。</p><p><strong>输入样例:</strong><br />7 8</p><p><strong>输出样例:</strong><br />7+8=15<br />7-8=-1<br />7*8=56 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> a, b;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>, a, b, a + b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>, a, b, a - b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\n&quot;</span>, a, b, a * b);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="欠债还钱">欠债还钱</h2><p><strong>题目内容：</strong><br />阿福打算向朋友借钱，请输入一个浮点数 m 和一个整数n，分别表示他想借的钱数和借期，程序输出他的意图。</p><p><strong>输入格式:</strong><br />输入在一行中给出 1 个浮点数和 1 个整数，二者均大于 0。</p><p><strong>输出格式:</strong><br />输出的钱数保留两位小数，格式如下所示：<br />你好，可以借我 XX.XX 元钱吗？<br />X 天后一定还！</p><p><strong>输入样例:</strong><br />166.66 7</p><p><strong>输出样例:</strong> 你好，可以借我 166.66 元钱吗？<br />7 天后一定还！ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">double</span> m;  </span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>,&amp;m,&amp;n);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好，可以借我%.2lf元钱吗？\n&quot;</span>,m);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d天后一定还！&quot;</span>,n);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第三章-运算符和表达式">第三章 运算符和表达式</h1><h2 id="判断闰年">判断闰年</h2><p><strong>题目内容:</strong><br />输入年份判断该年份是否是闰年。闰年的判定条件是能被 400 整除或能被 4整除但不能被 100 整除的年份</p><p><strong>输入格式:</strong><br />输入年份，判断其是否闰年。</p><p><strong>输出格式:</strong><br />YES 或 NO</p><p><strong>输入样例:</strong><br />2000</p><p><strong>输出样例:</strong><br />YES <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> year;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);  </span><br><span class="line">    <span class="keyword">if</span> ((year % <span class="number">400</span> == <span class="number">0</span>) || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="移花接木">移花接木</h2><p><strong>题目内容:</strong><br />输入两个浮点数，将第二个数的小数部分拼接到第一个数的整数部分将第一个数的小数部分拼接到第二个数的整数部分。然后输出新生成的浮点数。</p><p><strong>输入格式:</strong><br />输入两个浮点数。(注意可能有负数)</p><p><strong>输出格式:</strong><br />输出新生成的两个浮点数。(输出保留 6 位小数)</p><p><strong>输入样例 1:</strong><br />135.79 24.068</p><p><strong>输出样例 1:</strong><br />135.068000 24.790000</p><p><strong>输入样例 2:</strong><br />-1.23 4.56</p><p><strong>输出样例 2:</strong><br />-1.560000 4.230000</p><h3 id="我的版本">我的版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="type">double</span> n1,n2,i1,i2,f1,f2,r1,r2;  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>,&amp;n1,&amp;n2);  </span><br><span class="line">i1=(<span class="type">int</span>)n1;  </span><br><span class="line">i2=(<span class="type">int</span>)n2;  </span><br><span class="line">f1 = (n2 &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>) * (<span class="built_in">fabs</span>(n1) - (<span class="type">int</span>)<span class="built_in">fabs</span>(n1));  </span><br><span class="line">f2 = (n1 &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>) * (<span class="built_in">fabs</span>(n2) - (<span class="type">int</span>)<span class="built_in">fabs</span>(n2));  </span><br><span class="line">r1=i1+f2;  </span><br><span class="line">r2=i2+f1;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf %lf&quot;</span>,r1,r2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="张跃哲同学的版本">张跃哲同学的版本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">double</span> n1, n2;  <span class="comment">//原数  </span></span><br><span class="line"><span class="type">int</span> i1 , i2;    <span class="comment">//取整数  </span></span><br><span class="line"><span class="type">double</span> f1, f2;  <span class="comment">//取小数  </span></span><br><span class="line">scanf_s(<span class="string">&quot;%lf%lf&quot;</span>, &amp;n1, &amp;n2);  </span><br><span class="line">i1 = (<span class="type">int</span>)n1;<span class="comment">//注意，强制转换成int，向零取整  </span></span><br><span class="line">i2 = (<span class="type">int</span>)n2;  </span><br><span class="line">f1 = n1 - i1;<span class="comment">//正数情况即直接就是小数  </span></span><br><span class="line">f2 = n2 - i2;<span class="comment">//负数情况即为带符号的小数 即-1.23转化为0.23  </span></span><br><span class="line"><span class="comment">//注意第一个数加上第二个数的小数部分，小数部分看第一个数的符号  </span></span><br><span class="line">n1 = i1+((n1 == <span class="built_in">fabs</span>(n1)) * <span class="number">2</span> - <span class="number">1</span>) * <span class="built_in">fabs</span>(f2);  </span><br><span class="line">n2 = i2 + ((n2 == <span class="built_in">fabs</span>(n2)) * <span class="number">2</span> - <span class="number">1</span>) * <span class="built_in">fabs</span>(f1);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf %lf\n&quot;</span>, n1, n2);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="陈怀宇同学的版本">陈怀宇同学的版本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">double</span> a,b;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;a, &amp;b);  </span><br><span class="line">    <span class="keyword">if</span> (a*b &gt;= <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6lf %.6lf&quot;</span>, (<span class="type">int</span>)a+b-(<span class="type">int</span>)b, (<span class="type">int</span>)b+a-(<span class="type">int</span>)a);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6lf %.6lf&quot;</span>, (<span class="type">int</span>) a - b + (<span class="type">int</span>) b, (<span class="type">int</span>) b - a + (<span class="type">int</span>) a);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="陈冠亨同学的版本">陈冠亨同学的版本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 100  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">swap_integer_and_decimal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *num1, <span class="type">const</span> <span class="type">char</span> *num2, <span class="type">char</span> *result)</span> &#123;  </span><br><span class="line">    <span class="type">char</span> int_part1[MAX_LENGTH], decimal_part1[MAX_LENGTH];  </span><br><span class="line">    <span class="type">char</span> int_part2[MAX_LENGTH], decimal_part2[MAX_LENGTH];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 找到第一个数字的小数点  </span></span><br><span class="line">    <span class="type">char</span> *decimal1 = <span class="built_in">strchr</span>(num1, <span class="string">&#x27;.&#x27;</span>);  </span><br><span class="line">    <span class="type">char</span> *decimal2 = <span class="built_in">strchr</span>(num2, <span class="string">&#x27;.&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果找到小数点  </span></span><br><span class="line">    <span class="keyword">if</span> (decimal1 != <span class="literal">NULL</span> &amp;&amp; decimal2 != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="comment">// 提取整数部分和小数部分  </span></span><br><span class="line">        <span class="built_in">strncpy</span>(int_part1, num1, decimal1 - num1);  </span><br><span class="line">        int_part1[decimal1 - num1] = <span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">        <span class="built_in">strcpy</span>(decimal_part1, decimal1 + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">strncpy</span>(int_part2, num2, decimal2 - num2);  </span><br><span class="line">        int_part2[decimal2 - num2] = <span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">        <span class="built_in">strcpy</span>(decimal_part2, decimal2 + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 生成结果字符串  </span></span><br><span class="line">        <span class="built_in">snprintf</span>(result, MAX_LENGTH, <span class="string">&quot;%s.%s %s.%s&quot;</span>, int_part2, decimal_part1, int_part1, decimal_part2);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">strcpy</span>(result, <span class="string">&quot;Invalid input format&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">char</span> input1[MAX_LENGTH];  </span><br><span class="line">    <span class="type">char</span> input2[MAX_LENGTH];  </span><br><span class="line">    <span class="type">char</span> result[MAX_LENGTH];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从标准输入读取数据  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter two decimal numbers separated by space: &quot;</span>);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, input1, input2);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 进行整数部分和小数部分的互换  </span></span><br><span class="line">    swap_integer_and_decimal(input1, input2, result);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 输出结果  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Swapped result: %s\n&quot;</span>, result);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三目运算">三目运算</h2><p><strong>题目内容:</strong> 输入四个浮点数，只用三目运算符 (不能用 if等条件语句或循环语句) 找出其中的最大值和最小值。</p><p><strong>输入格式：</strong> 第一行输入四个数值；</p><p><strong>输出格式:</strong> 最大值 最小值 (结果保留两位小数)</p><p><strong>输入样例:</strong> 5 9 3 7.0</p><p><strong>输出样例:</strong> 9.00 3.00 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">double</span> a, b, c, d;  </span><br><span class="line"><span class="type">double</span> max, min;  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);  </span><br><span class="line">max = a &gt; b ? a : b;  </span><br><span class="line">max = max &gt; c ? max : c;  </span><br><span class="line">max = max &gt; d ? max : d;  </span><br><span class="line">min = a &gt; b ? b : a;  </span><br><span class="line">min = min &gt; c ? c : min;  </span><br><span class="line">min = min &gt; d ? d : min;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f %.2f&quot;</span>, max, min);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第四章-程序流程控制">第四章 程序流程控制</h1><h2 id="阿福家的电费">阿福家的电费</h2><p><strong>题目内容：</strong><br />入秋了，家里的用电量也减少了许多。阿福收到了新一期的电费通知单，却发现本期电费与高温天的电费不相上下。杭州现行的阶梯电价是按照年用电量来划分的，这说明阿福家的低价电额度已用完，接下来可得节约用电咯。阿福想自己验证一下，今年以来代扣的总电费到底是否正确。请编写一个程序，已知今年1月份以来的各月用电量，根据电价规定，计算出今年应缴的总电费是多少。<br />杭州现行的阶梯电价标准分三档：<br />第一档：电量为年用电量 2760 度及以下部分，电价不作调整，标准电价为 0.538元 / 度；<br />第二档：电量为年用电量 2761 至 4800 度的部分，电价在第一档基础上加价0.05 元，为 0.588 元 / 度；<br />第三档：电量超过 4800 的部分，电价在第一档基础上加价 0.3 元，为 0.838 元/ 度。<br /><strong>输入格式:</strong><br />输入占一行，给出若干个整数（以输入 - 1 表示结束），分别表示从 1月开始各个月份的用电量（单位是度），注意：-1 不算用电量。</p><p><strong>输出格式：</strong><br />输出总电费（单位是元），结果保留 1 位小数。</p><p><strong>输入样例：</strong><br />468 489 370 363 397 380 712 679 484 453 462 -1</p><p><strong>输出样例：</strong><br />3067.4 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,sum,a[<span class="number">13</span>];</span><br><span class="line"><span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i+=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">if</span> (a[i]==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum+=a[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum&lt;=<span class="number">2760</span>)&#123;</span><br><span class="line">r=sum*<span class="number">0.538</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">2760</span>&amp;&amp;sum&lt;=<span class="number">4800</span>)&#123;</span><br><span class="line">r=<span class="number">2760</span>*<span class="number">0.538</span>+(sum<span class="number">-2760</span>)*<span class="number">0.588</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">r=<span class="number">0.838</span>*(sum<span class="number">-4800</span>)+<span class="number">2760</span>*<span class="number">0.538</span>+(<span class="number">4800</span><span class="number">-2760</span>)*<span class="number">0.588</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="幂级数求近似值">幂级数求近似值</h2><p><strong>题目内容：</strong> 已知函数 的幂级数展开式为。现给定一个实数 和一个整数 ，利用此幂级数展开式的前 n+1 项之和，求的近似值。</p><p><strong>输入格式:</strong> 输入在一行中给出一个实数 x 和一个整数n。</p><p><strong>输出格式：</strong><br />输出展开式的前 n+1 项之和，保留 4 位小数。</p><p><strong>输入样例：</strong><br />1.2 10</p><p><strong>输出样例：</strong> 3.3201 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x,r=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i,n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %d&quot;</span>,&amp;x,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i+=<span class="number">1</span>)&#123;</span><br><span class="line">r+=<span class="built_in">pow</span>(x,i)/factorial(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="素数口袋">素数口袋</h2><p><strong>题目内容：</strong><br />阿福有一个口袋，可以用来装各个素数。他从 2开始，依次判断各个自然数是不是素数，如果是素数就把这个数字装入口袋。口袋的承载量就是包里所有数字之和，但口袋的承载量有限。假设口袋的承载量是L，表示只能装得下总和不超过 L 的素数。现给出一个正整数L，请问口袋里能装下几个素数？将这些素数从小到大输出，再输出最多能装下的素数个数。</p><p><strong>输入格式:</strong><br />输入一个正整数 L（2&lt;=L&lt;=10000），表示最大承载量。</p><p><strong>输出格式：</strong><br />输出包括两行，第一行从小到大输出能装下的所有素数，数与数之间用空格隔开（注意：行末无空格）<br />第二行输出”count = 素数个数”</p><p><strong>输入样例：</strong><br />100</p><p><strong>输出样例：</strong><br />2 3 5 7 11 13 17 19 23<br />count = 9 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (sum + num &lt;= L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(num)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="comment">//通过循环处理空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">            sum += num;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ncount = %d&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第五章-数组">第五章 数组</h1><h2 id="支撑数">支撑数</h2><p><strong>题目内容：</strong> 找出一个数列中全部的“支撑数”。“支撑数”有这样的特征：它们不在第一个，也不在最后一个，而且比左边和右边相邻的数都大。</p><p><strong>输入格式:</strong><br />第一行输入一个整数n，表示数列中有n个整数。（3&lt;=n&lt;=100） 第二行输入n个整数。</p><p><strong>输出格式：</strong><br />分行输出所有的支撑数，每行输出一个支撑数（保证至少有一个）。</p><p><strong>输入样例：</strong><br />6 1 3 2 4 1 5</p><p><strong>输出样例：</strong><br />3 4 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i<span class="number">-1</span>]&lt;a[i]&amp;&amp;a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="上三角矩阵">上三角矩阵</h2><p><strong>题目内容：</strong>上三角矩阵指主对角线以下的元素都为0的矩阵（不包括主对角线）；主对角线为从矩阵的左上角至右下角的连线。本题要求编写程序，判断一个给定的方阵是否上三角矩阵。</p><p><strong>输入格式:</strong><br />输入第一行给出一个正整数N（2≤N≤10)。随后N行，每行给出N个整数，其间以空格分隔。</p><p><strong>输出格式：</strong><br />如果输入的矩阵是上三角矩阵，输出YES，否则输出NO。</p><p><strong>输入样例：</strong></p><p>5</p><p>1 2 3 4 5</p><p>0 1 2 3 4</p><p>0 0 1 2 3</p><p>0 0 0 1 2</p><p>0 0 0 0 1</p><p><strong>输出样例：</strong></p><p>YES <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> matrix[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> isUpperTriangular = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]!= <span class="number">0</span>) &#123;</span><br><span class="line">                isUpperTriangular = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isUpperTriangular) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isUpperTriangular) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="按绝对值排序">按绝对值排序</h2><p><strong>题目内容：</strong>输入n(n&lt;=100)个整数，按照绝对值从大到小排序后输出</p><p><strong>输入格式：</strong><br />输入数据的第一个数字为n，接着是n个整数。</p><p><strong>输出格式：</strong><br />按照绝对值从大到小排序后输出n个整数，两数之间空格隔开，最后一个数后面无空格。</p><p><strong>输入样例：</strong><br />3 3 -4 2</p><p><strong>输出样例：</strong><br />-4 3 2 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(arr[j]) &lt; <span class="built_in">fabs</span>(arr[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[n - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第六章-函数">第六章 函数</h1><h2 id="判断是否为完数">判断是否为完数</h2><p><strong>题目内容：</strong>编写函数，判断一个正整数a是否为完数，如果是完数，函数返回值为1；否则为0.（完数：一个数的所有因子之和等于该本身，如6、28都是完数；6=1+2+3；28=1+2+4+7+14）</p><p><strong>输入格式:</strong><br />输入一个正整数。</p><p><strong>输出格式：</strong><br />如果是，输出“是完数”，否则输出“不是完数”</p><p><strong>输入样例1：</strong><br />6</p><p><strong>输出样例1：</strong><br />是完数</p><p><strong>输入样例2：</strong><br />25</p><p><strong>输出样例2：</strong><br />不是完数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ws</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">if</span> (ws(num)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是完数\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不是完数\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="递归求-fabonacci-数列">递归求 Fabonacci 数列</h2><p><strong>题目内容：</strong><br />本题要求实现求 Fabonacci 数列项的函数。Fabonacci 数列的定义如下：<br />f (n)=f (n−2)+f (n−1) (n≥2)，其中 f (0)=0，f (1)=1。<br />题目保证输入输出在长整型范围内。建议用递归实现.</p><p><strong>输入格式:</strong><br />输入一个正整数 n</p><p><strong>输出格式：</strong><br />输出 f (n) 的值。</p><p><strong>输入样例：</strong><br />6</p><p><strong>输出样例：</strong><br />8 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输出一个整数的逆序数10分">输出一个整数的逆序数（10分）</h2><p><strong>题目内容：</strong> 实现一个求整数的逆序数的简单函数。</p><p><strong>输入格式:</strong><br />输入一个整数（可正可负）。</p><p><strong>输出格式：</strong><br />输出它的逆序，注意考虑正负。</p><p><strong>输入样例1：</strong><br />1234</p><p><strong>输出样例1：</strong><br />4321</p><p><strong>输入样例2：</strong><br />-12340</p><p><strong>输出样例2：</strong><br />-4321 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">( <span class="type">int</span> number )</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, reverse(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">( <span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num!= <span class="number">0</span>) &#123;</span><br><span class="line">        r=r*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第七章-指针">第七章 指针</h1><h2 id="删除数列中的指定数">删除数列中的指定数</h2><p><strong>题目内容：</strong>请使用指针的方法编写程序，程序的功能是先输入10个整数存储到数组a中，再输入一个指定的数x，把数组中的x数据删除掉，并保证数组中剩余的数还是连续存储的。</p><p>比如输入10个整数：3 2 8 6 5 8 7 9 85，存入数组，然后输入一个数8，把数组中的8全部删除。最后数组中剩下的数：32 6 5 7 9 5，在数组a中还是连续存储的。</p><p>要求定义函数实现删除功能：int del_num(int *p, int n, intx)；其中函数的返回值为删除指定数后数组中剩余数据的个数。</p><p><strong>输入格式:</strong><br />输入10个整数，和1个指定数。</p><p><strong>输出格式：</strong><br />输出剩余数，以空格隔开，最后一个数后面没有空格。</p><p><strong>输入样例：</strong><br />3 2 8 6 5 8 7 9 8 5 8</p><p><strong>输出样例：</strong><br />3 2 6 5 7 9 5 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_num</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n, <span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="type">int</span> newLength = del_num(a, <span class="number">10</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newLength; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; newLength - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_num</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i]!= x) &#123;</span><br><span class="line">            p[j++] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2id="求一组数中的最大值最小值及总和">求一组数中的最大值、最小值及总和</h2><p><strong>题目内容：</strong>求一组数中的最大值、最小值及总和。要求定义函数 int f(int a[],int n,int<em>pmax,int </em>pmin) 函数返回总和，并分别通过指针pmax 和pmin将最大值、最小值赋值给主函数中的对应变量。</p><p><strong>输入格式:</strong><br />第1行为正整数n（n&gt;2）,表示一组数的个数第2行包含n个整数，用空格分隔。</p><p><strong>输出格式：</strong><br />一行包含3个整数，分别为最大值、最小值及总和</p><p><strong>输入样例：</strong><br />10 2 5 4 8 6 9 1 3 7 0</p><p><strong>输出样例：</strong><br />9 0 45 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> *pmax, <span class="type">int</span> *pmin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max, min;</span><br><span class="line">    <span class="type">int</span> sum = f(a, n, &amp;max, &amp;min);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, max, min, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> *pmax, <span class="type">int</span> *pmin)</span> &#123;</span><br><span class="line">    *pmax = a[<span class="number">0</span>];</span><br><span class="line">    *pmin = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> sum = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; *pmax) &#123;</span><br><span class="line">            *pmax = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; *pmin) &#123;</span><br><span class="line">            *pmin = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第八章-字符串">第八章 字符串</h1><h2 id="查找字符串">查找字符串</h2><p><strong>题目内容：</strong>给定一个字符串，在字符串中找到第一个连续出现至少k次的字符。</p><p><strong>输入格式:</strong><br />第一行包含一个正整数k，表示至少需要连续出现的次数。1 &lt;= k &lt;= 100。第二行包含需要查找的字符串。字符串长度在1到100之间，且不包含任何空白符。</p><p><strong>输出格式：</strong><br />若存在连续出现至少k次的字符，输出该字符；否则输出NO。</p><p><strong>输入样例1：</strong><br />3 abcccaaab</p><p><strong>输出样例1：</strong><br />c</p><p><strong>输入样例2：</strong><br />3 abccaab</p><p><strong>输出样例2：</strong><br />NO <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="type">char</span> s[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == s[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, s[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="求最大字符串">求最大字符串</h2><p><strong>题目内容：</strong>本题要求编写程序，针对输入的N个字符串，输出其中最大的字符串。</p><p><strong>输入格式：</strong><br />输入第一行给出正整数N；随后N行，每行给出一个长度小于80的非空字符串，其中不会出现换行符，空格，制表符。</p><p><strong>输出格式：</strong><br />输出最大的字符串。</p><p><strong>输入样例：</strong><br />6<br />best cat east a free day</p><p><strong>输出样例：</strong><br />free <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> maxStr[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, maxStr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">80</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str, maxStr) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(maxStr, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, maxStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第九章-结构体">第九章 结构体</h1><h2 id="最高分的学生">最高分的学生</h2><p><strong>题目内容：</strong>输入学生的人数，然后再输入每位学生的分数和姓名，求获得最高分数的学生的姓名。</p><p><strong>输入格式:</strong><br />第一行输入一个正整数N（N &lt;=100），表示学生人数。接着输入N行，每行格式如下： 分数 姓名分数是一个非负整数，且小于等于100；姓名为一个连续的字符串，中间没有空格，长度不超过20。</p><p><strong>输出格式：</strong><br />输出最高分数的学生姓名。每行包含一个姓名</p><p><strong>输入样例：</strong><br />5 87 lilei 99 hanmeimei 97 lily 99 lucy 77 jim</p><p><strong>输出样例：</strong><br />hanmeimei lucy <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">students</span>[<span class="title">n</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>, &amp;students[i].score, students[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxScore = students[<span class="number">0</span>].score;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (students[i].score &gt; maxScore) &#123;</span><br><span class="line">            maxScore = students[i].score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (students[i].score == maxScore) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, students[i].name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计算平均成绩">计算平均成绩</h2><p><strong>题目内容：</strong>给定N个学生的基本信息，包括学号（由5个数字组成的字符串）、姓名（长度小于10的不包含空白字符的非空字符串）和成绩（[0,100]区间内的整数），要求计算他们的平均成绩，并顺序输出平均线以下的学生名单。</p><p><strong>输入格式:</strong><br />输入在一行中给出正整数N（≤10）。随后N行，每行给出一位学生的信息，格式为“学号姓名 成绩”，中间以空格分隔。</p><p><strong>输出格式：</strong><br />首先在一行中输出平均成绩，保留2位小数。然后按照输入顺序，每行输出一位平均线以下的学生的姓名和学号，间隔一个空格。</p><p><strong>输入样例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">5</span></span><br><span class="line"><span class="attribute">00001</span> zhang <span class="number">70</span></span><br><span class="line"><span class="attribute">00002</span> wang <span class="number">80</span></span><br><span class="line"><span class="attribute">00003</span> qian <span class="number">90</span></span><br><span class="line"><span class="attribute">10001</span> li <span class="number">100</span></span><br><span class="line"><span class="attribute">21987</span> chen <span class="number">60</span></span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong><br /><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">80</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">zhang</span> <span class="number">00001</span></span><br><span class="line"><span class="attribute">chen</span> <span class="number">21987</span></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">6</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[<span class="title">n</span>];</span></span><br><span class="line">    <span class="type">int</span> total_score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %d&quot;</span>, students[i].id, students[i].name, &amp;students[i].score);</span><br><span class="line">        total_score += students[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> average_score = (<span class="type">double</span>)total_score / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, average_score);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (students[i].score &lt; average_score) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, students[i].name, students[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第十章-文件">第十章 文件</h1><p>无练习</p><h1 id="线上期末考试">线上期末考试</h1><h2 id="计算行李费">计算行李费</h2><p><strong>题目内容：</strong>乘坐飞机时，当乘客行李重量不超过10公斤时，可随身携带行李免费。当行李重量超过10公斤时，必须办理托运。行李费这样计算量大于10公斤且小于等于20公斤时，每公斤2元。如果行李重量大于20公斤时，每公斤3元。请编程计算行李费。</p><p><strong>输入格式:</strong>一个正整数（&lt;100），乘客携带行李重量，单位公斤</p><p><strong>输出格式:</strong> 一个整数，表示行李费用</p><p><strong>输入样例：</strong> 11</p><p><strong>输出样例：</strong> 22</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;weight);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fee;</span><br><span class="line"><span class="keyword">if</span>(weight&lt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">fee=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(weight&gt;<span class="number">10</span>&amp;&amp;weight&lt;=<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">fee=weight*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(weight&gt;<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">fee=weight*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,fee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行程长度压缩">行程长度压缩</h2><p><strong>题目内容：</strong>在数据压缩中，一个常用的途径是行程长度压缩。对于一个待压缩的字符串（只包含大写字母）而言，我们可以依次记录每个字符及重复的次数。这种压缩，对于相邻数据重复较多的情况比较有效。例如，如果待压缩串为"AAABBBBCBB"，则压缩的结果是(A,3)(B,4)(C,1)(B,2)。当然，如果相邻字符重复情况较少，则压缩效率就较低。现要求根据输入的字符串，得到压缩结果。</p><p><strong>输入格式:</strong>一个字符串，全部由大写字母组成。长度大于1，小于10000</p><p><strong>输出格式：</strong> 输出为一行，表示压缩结果，形式为：(A,3)(B,4)(C,1)(B,2)即每对括号内部分别为字符及重复出现的次数，不含任何空格。</p><p><strong>输入样例：</strong> AAABBBBCCCAAAAA</p><p><strong>输出样例：</strong> (A,3)(B,4)(C,3)(A,5)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == str[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%c,%d)&quot;</span>, str[i], count);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 杭电 </tag>
            
            <tag> Mooc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的markdown学习</title>
      <link href="/2024/08/23/%E6%88%91%E7%9A%84markdown%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/23/%E6%88%91%E7%9A%84markdown%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>这是笔者的markdown学习笔记 <span id="more"></span></p><hr /><h1 id="文本">文本</h1><p><strong>加粗文本1</strong> <strong>加粗文本2</strong> <em>斜体1</em><em>斜体2</em> <strong><em>加粗+斜体</em></strong> <del>中划线</del>分割线</p><hr /><h1 id="列表">列表</h1><ul><li>无序列表1</li><li>无序列表2</li></ul><ol type="1"><li>有序列表1<ul><li>二级列表<ul><li>三级列表</li></ul></li></ul></li><li>有序列表2（只能按顺序，第一项可自定义)</li></ol><p>退出列表 * [ ] 任务打勾1（未完成） * [x] 任务打勾2（已完成）</p><hr /><h1 id="代码">代码</h1><p>代码块 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 代码语句<code>printf()</code></p><hr /><h1 id="引用">引用</h1><blockquote><p>引用<br />引用中换行</p></blockquote><hr /><h1 id="链接">链接</h1><p><a href="https://www.gov.cn/">链接</a>&lt;——点它</p><p><ahref="https://www.bilibili.com/video/BV18E4m1d7b7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=da905aeb41d3bbab09f2abf41b856272">不要点我</a></p><p>展示脚注<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a></p><hr /><h1 id="图片">图片</h1><p>图片的插入 网络 <imgsrc="https://patchwiki.biligame.com/images/ys/2/2e/ang2w3cxk8535wicpksvz6pq0xoxbwi.png"alt="图片网络链接" />图片（做了图床用的gitee，但是好像不行。现在是用现成的）</p><p>这个照片不是本人！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p><p><img src="https://pic.imgdb.cn/item/66c86b27d9c307b7e9722e08.jpg"alt="本地图片" /> 用gitee的 <imgsrc="https://gitee.com/Even_lwx/images/raw/master/ymh.jpg"alt="ymh" /></p><hr /><h1 id="表格">表格</h1><table><thead><tr class="header"><th style="text-align: center;">姓名</th><th style="text-align: center;">年龄</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">小明</td><td style="text-align: center;">17</td></tr><tr class="even"><td style="text-align: center;">小豪</td><td style="text-align: center;">18</td></tr></tbody></table><hr /><h1 id="自制html内容">自制HTML内容</h1><p>不会！！！</p><hr /><h1 id="tag插件高亮">Tag插件（高亮）</h1><div class="note warning flat"><p>我是警告色（高亮文本）</p></div><p>方法 <imgsrc="https://pic.imgdb.cn/item/66c88f63d9c307b7e9afbf44.png" /></p><hr /><h1 id="数学公式嵌入需要另外渲染">数学公式嵌入（需要另外渲染）</h1><p><span class="math inline">\(x=1+y\)</span> <spanclass="math display">\[\frac{x+1}{20-x}\]</span> <span class="math display">\[x_2^2\]</span> <span class="math display">\[\sqrt[3]{\{[(4+x)-3]*3\}}\]</span> 符号 <span class="math display">\[\not=         \approx\leq\geq\times\div\pm\sum_0^n\prod\coprod\overline{1+2+3+4}\]</span> 常见表达 <span class="math display">\[\alpha\beta\mu\epsilon180^\circ\sin\pi\cos\cot\tan\in\notin\supset\supseteq\bigcap\bigcup\emptyset\infty\int\iinty\prime\lim\]</span> 排版 <span class="math display">\[\int_0^1x^2dx\]</span> <span class="math display">\[\lim_{n\rightarrow+\infty} \frac{1}{n}\]</span></p><hr /><h1 id="尾声">尾声</h1><p>目前内容的源码稍后上传 持续更新中 ——2024.8.23</p><hr /><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>我是脚注<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客-学习日志</title>
      <link href="/2024/08/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>大家好 明天再学md语法！今天配置网站顶不住了。 ————2024.8.22</p><p>昨天连不上git库的原因时watt tookit没有关 配置的时候一定要注意！！！今天下午学了markdown语法 ————2024.8.23</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
