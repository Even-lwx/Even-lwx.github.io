<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言-期末复习 | Even-lwx的博客</title><meta name="author" content="Li Wenxuan"><meta name="copyright" content="Li Wenxuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文为作者在复习过程中遇到的问题，内容不全，供查漏补缺。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言-期末复习">
<meta property="og:url" content="http://example.com/2025/01/10/C%E8%AF%AD%E8%A8%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Even-lwx的博客">
<meta property="og:description" content="本文为作者在复习过程中遇到的问题，内容不全，供查漏补缺。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/66d4f9dbd9c307b7e943756c.jpg">
<meta property="article:published_time" content="2025-01-10T10:22:00.000Z">
<meta property="article:modified_time" content="2025-06-22T07:02:26.880Z">
<meta property="article:author" content="Li Wenxuan">
<meta property="article:tag" content="c语言">
<meta property="article:tag" content="期末复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66d4f9dbd9c307b7e943756c.jpg"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/66d4f9dbd9c307b7e943756c.jpg"><link rel="canonical" href="http://example.com/2025/01/10/C%E8%AF%AD%E8%A8%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言-期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-22 15:02:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/66d4f9dbd9c307b7e943756c.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Even-lwx的博客"><span class="site-name">Even-lwx的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言-期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-10T10:22:00.000Z" title="发表于 2025-01-10 18:22:00">2025-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-22T07:02:26.880Z" title="更新于 2025-06-22 15:02:26">2025-06-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/01/10/C%E8%AF%AD%E8%A8%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" data-flag-title="C语言-期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据基本类型和输入输出">数据基本类型和输入输出</h1>
<h2
id="c语言将数字和数字字符输入给char型变量会如何">C语言——将数字和数字字符输入给char型变量会如何？</h2>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52005740/article/details/117432826">C语言——将数字和数字字符输入给char型变量会如何？-CSDN博客</a></p>
<h1 id="字符串">字符串</h1>
<h2 id="输入输出函数">输入输出函数</h2>
<h3 id="sscanf">sscanf</h3>
<ol type="1">
<li><p><strong>函数定义与功能</strong></p>
<ul>
<li><strong>sscanf</strong>是 C
语言中的函数，函数原型为<code>int sscanf(const char *str, const char *format,...)</code>。它的主要作用是从字符串<code>str</code>中按照<code>format</code>指定的格式读取数据，并将读取的数据存储到可变参数列表所指定的变量中。</li>
<li>简单来说，它是<code>sprintf</code>的逆操作。<code>sprintf</code>是将数据格式化后写入字符串，而<code>sscanf</code>是从字符串中解析出数据并存储到变量中。</li>
</ul></li>
<li><p><strong>使用示例</strong></p>
<ul>
<li><p><strong>基本数据类型的读取</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;10 3.14 A&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> f_num;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%d %f %c&quot;</span>, &amp;num, &amp;f_num, &amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的整数：%d，浮点数：%f，字符：%c\n&quot;</span>, num, f_num, ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>sscanf</code>从字符串<code>str</code>（"10 3.14
A"）中按照<code>%d %f %c</code>的格式读取数据。它将字符串中的第一个数字<code>10</code>读取并存储到<code>num</code>变量中，第二个数字<code>3.14</code>存储到<code>f_num</code>变量中，最后一个字符<code>A</code>存储到<code>ch</code>变量中。最后输出<code>读取的整数：10，浮点数：3.140000，字符：A</code>。</p></li>
<li><p><strong>字符串部分读取与格式匹配</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="type">char</span> part1[<span class="number">4</span>];</span><br><span class="line">    <span class="type">char</span> part2[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%3s%3s&quot;</span>, part1, part2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的第一部分：%s，第二部分：%s\n&quot;</span>, part1, part2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>sscanf</code>按照<code>%3s%3s</code>的格式从<code>str</code>中读取数据。<code>%3s</code>表示读取最多
3
个字符作为一个字符串。所以<code>part1</code>读取了<code>abc</code>，<code>part2</code>读取了<code>def</code>，输出为<code>读取的第一部分：abc，第二部分：def</code>。</p></li>
</ul></li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><strong>格式匹配与数据类型</strong>：格式控制字符串<code>format</code>的格式必须与要读取的数据类型和格式相匹配。如果不匹配，可能会导致读取的数据错误或者程序异常。例如，如果格式控制字符串中要求读取一个整数，但字符串中对应的部分不是合法的整数格式，就会出现问题。</li>
<li><strong>缓冲区大小</strong>：在读取字符串数据到字符数组变量时，要确保字符数组有足够的大小来容纳读取的数据。如果字符数组过小，可能会导致缓冲区溢出，覆盖其他内存区域的数据。</li>
<li><strong>可变参数列表的正确使用</strong>：传递给<code>sscanf</code>的可变参数必须是正确的变量地址，这样才能将读取的数据正确存储。例如，对于整数变量，要传递其地址<code>&amp;num</code>，而不是变量本身<code>num</code>。</li>
</ul></li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><strong>数据解析与提取</strong>：在处理用户输入、配置文件或者网络数据包等数据时，<code>sscanf</code>可以用于从字符串格式的数据中提取出需要的信息。例如，从用户输入的日期字符串（如<code>"2025-01-10"</code>）中提取出年、月、日等信息。</li>
<li><strong>数据转换与验证</strong>：可以用于验证和转换数据格式。比如，检查一个字符串是否符合某种数字格式，如果符合则将其转换为相应的数字类型存储到变量中，方便后续的计算和处理。</li>
</ul></li>
</ol>
<h3 id="sprintf">sprintf</h3>
<ol type="1">
<li><p><strong>函数定义与功能</strong></p>
<ul>
<li><strong>sprintf</strong>是 C
语言中的一个函数，函数原型为<code>int sprintf(char *str, const char *format,...)</code>。它的主要功能是将格式化的数据写入到字符串<code>str</code>中。</li>
<li>其中，<code>format</code>是格式化字符串，类似于<code>printf</code>函数中的格式控制字符串，它规定了要写入的数据的格式，包括数据类型（如整数、浮点数、字符等）、宽度、精度等信息。后面的省略号<code>...</code>表示可变参数列表，用于传递要格式化的数据。</li>
</ul></li>
<li><p><strong>使用示例</strong></p>
<ul>
<li><p><strong>基本数据类型的格式化输出</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> f_num = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;整数：%d，浮点数：%f，字符：%c&quot;</span>, num, f_num, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>sprintf</code>函数将整数<code>num</code>、浮点数<code>f_num</code>和字符<code>ch</code>按照指定的格式（<code>%d</code>、<code>%f</code>、<code>%c</code>）进行格式化，并写入到<code>buffer</code>字符串中。最后通过<code>printf</code>输出<code>buffer</code>的内容，结果为<code>整数：10，浮点数：3.140000，字符：A</code>。</p></li>
<li><p><strong>格式化字符串拼接</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%s %s&quot;</span>, str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>sprintf</code>将<code>str1</code>和<code>str2</code>两个字符串拼接起来写入到<code>buffer</code>中，输出结果为<code>Hello World</code>。</p></li>
</ul></li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><strong>缓冲区大小</strong>：使用<code>sprintf</code>时，必须确保目标字符串<code>str</code>有足够的空间来容纳格式化后的数据。如果空间不足，会导致缓冲区溢出，可能会引起程序崩溃或产生不可预测的行为。</li>
<li><strong>格式化字符串的正确性</strong>：格式控制字符串<code>format</code>的格式必须与后面传递的参数类型和数量相匹配。否则，可能会得到错误的结果或者程序出现异常。例如，如果格式控制字符串中要求一个整数参数，但实际传递的是一个字符，就会出现问题。</li>
</ul></li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><strong>数据记录与日志记录</strong>：在程序中记录数据或生成日志时，可以使用<code>sprintf</code>将各种数据（如时间、状态信息、数据值等）按照一定的格式组合成一个字符串，方便存储或输出。</li>
<li><strong>数据转换与显示</strong>：可以将不同类型的数据（如二进制数据转换为十六进制字符串显示，整数转换为特定格式的字符串等）进行格式化，用于在用户界面或者数据传输过程中进行合适的展示。</li>
</ul></li>
</ol>
<h2 id="字符串处理函数">字符串处理函数</h2>
<h3 id="strlen-与sizeof">strlen 与sizeof</h3>
<ol type="1">
<li><strong>含义</strong>
<ul>
<li><strong>strlen</strong>：是一个函数，用于计算字符串的长度。它从给定字符串的起始位置开始，一直计数到遇到字符串结束标志
'\0' 为止，并且不包括 '\0' 本身。这个函数定义在 &lt;string.h&gt;
头文件中（在 C 语言中）。</li>
<li><strong>sizeof</strong>：是一个操作符，不是函数。它用于计算变量或数据类型所占用的字节数。在计算数组时，它返回整个数组所占用的字节数；在计算指针时，它返回指针本身所占用的字节数（通常在
32 位系统中是 4 字节，在 64 位系统中是 8 字节）。</li>
</ul></li>
<li><strong>使用示例</strong>
<ul>
<li><p><strong>strlen 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The length of the string is %d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>strlen(str)</code>会计算字符串<code>str</code>中字符的个数，不包括
'\0'。所以输出结果是<code>5</code>。</p></li>
<li><p><strong>sizeof 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size_of_arr = <span class="keyword">sizeof</span>(arr);</span><br><span class="line">    <span class="type">int</span> size_of_int = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> num_elements = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The size of the array is %d bytes\n&quot;</span>, size_of_arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The size of an int is %d bytes\n&quot;</span>, size_of_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of elements in the array is %d\n&quot;</span>, num_elements);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>sizeof(arr)</code>返回整个数组<code>arr</code>所占用的字节数。假设<code>int</code>类型占
4 字节，那么<code>size_of_arr</code>的值为<code>20</code>（因为数组中有
5 个<code>int</code>元素，每个<code>int</code>占 4
字节）。<code>sizeof(int)</code>返回<code>int</code>类型所占用的字节数，这里假设是
4。<code>num_elements</code>通过<code>sizeof(arr)/sizeof(int)</code>计算出数组中元素的个数，结果为<code>5</code>。</p></li>
</ul></li>
<li><strong>对于不同数据类型的应用区别</strong>
<ul>
<li><strong>对于字符数组（字符串）</strong>
<ul>
<li><strong>strlen</strong>：重点关注字符串内容的长度，即字符的个数。例如，对于字符数组<code>char str[] = "abcde"</code>，<code>strlen(str)</code>返回<code>5</code>。</li>
<li><strong>sizeof</strong>：如果是字符数组，它返回数组占用的总字节数。对于<code>char str[] = "abcde"</code>，<code>sizeof(str)</code>返回包括
'\0' 在内的字符数组的大小，通常是 6（假设<code>char</code>占 1
字节）。</li>
</ul></li>
<li><strong>对于普通变量和数据类型</strong>
<ul>
<li><strong>strlen</strong>：不能用于非字符数组类型来获取其长度相关信息。例如，对于<code>int num = 10;</code>，不能使用<code>strlen</code>来计算它的任何长度相关内容。</li>
<li><strong>sizeof</strong>：可以用于任何变量或数据类型。对于<code>int num = 10;</code>，<code>sizeof(num)</code>返回<code>int</code>类型所占用的字节数，通常在
32 位系统中是 4 字节，在 64 位系统中也是 4
字节（<code>int</code>类型大小一般是固定的，但也有一些特殊情况）。对于自定义的结构体等复杂数据类型，<code>sizeof</code>也可以计算其占用的字节数。</li>
</ul></li>
</ul></li>
<li><strong>在指针方面的区别</strong>
<ul>
<li><p><strong>strlen</strong>：当应用于字符指针时，它会从指针所指向的字符开始，一直计数到遇到
'\0' 字符为止。例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(ptr);</span><br></pre></td></tr></table></figure></p>
<p>这里<code>len</code>的值为<code>5</code>，因为<code>strlen</code>会沿着指针<code>ptr</code>所指向的字符串计算长度，直到
'\0'。</p></li>
<li><p><strong>sizeof</strong>：当应用于指针时，不管指针指向什么类型的数据，它只返回指针本身所占用的字节数。例如：</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line"><span class="type">int</span> size = <span class="keyword">sizeof</span>(ptr);</span><br></pre></td></tr></table></figure></p>
<p>在 32 位系统中<code>size</code>为 4 字节，在 64
位系统中<code>size</code>为 8
字节，因为它计算的是指针变量本身的大小，而不是指针所指向的数据的大小。</p></li>
</ul></li>
</ol>
<p>在使用strlen和sizeof时，有哪些需要注意的地方？</p>
<p>除了C语言，其他编程语言中是否有类似strlen和sizeof的函数或操作符？</p>
<p>在计算结构体大小时，sizeof和strlen有什么区别？</p>
<h3 id="strcpy-与strncpy">strcpy 与strncpy</h3>
<ol type="1">
<li><strong>含义</strong>
<ul>
<li><strong>strcpy</strong>：是一个 C
语言中的字符串操作函数，用于将一个字符串（包括结束符
'\0'）复制到另一个字符串中。它的函数原型是<code>char* strcpy(char* destination, const char* source)</code>。它会从<code>source</code>字符串的起始位置开始，逐个字符地将内容复制到<code>destination</code>字符串中，直到遇到<code>source</code>中的
'\0' 字符，然后也会把 '\0'
复制过去，这样<code>destination</code>就成为了<code>source</code>的一个副本。</li>
<li><strong>strncpy</strong>：也是一个用于字符串复制的函数，它的函数原型是<code>char* strncpy(char* destination, const char* source, size_t n)</code>。它会从<code>source</code>字符串中复制最多<code>n</code>个字符到<code>destination</code>字符串中。如果<code>source</code>的长度小于<code>n</code>，则会在<code>destination</code>中剩余的位置填充
'\0'；如果<code>source</code>的长度大于等于<code>n</code>，则不会自动在<code>destination</code>的末尾添加
'\0'。</li>
</ul></li>
<li><strong>使用示例</strong>
<ul>
<li><p><strong>strcpy 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(destination, source);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, destination);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>strcpy</code>函数将<code>source</code>字符串（"Hello"）复制到<code>destination</code>字符串中。最后输出<code>Copied string: Hello</code>。</p></li>
<li><p><strong>strncpy 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> destination2[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 使用strncpy复制部分字符</span></span><br><span class="line">    <span class="built_in">strncpy</span>(destination1, source, <span class="number">5</span>);</span><br><span class="line">    destination1[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">// 如果source长度大于等于n，需要手动添加&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">strncpy</span>(destination2, source, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string 1: %s\n&quot;</span>, destination1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string 2: %s\n&quot;</span>, destination2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>strncpy(destination1, source, 5)</code>会将<code>source</code>中的前
5
个字符（"Hello"）复制到<code>destination1</code>中。由于<code>source</code>的长度大于
5，所以需要手动添加 '\0'
来正确结束字符串。而<code>strncpy(destination2, source, 15)</code>会将<code>source</code>中的前
15
个字符复制到<code>destination2</code>中，因为<code>source</code>的长度小于
15，所以<code>strncpy</code>会自动在剩余位置填充
'\0'，最后输出<code>Copied string 1: Hello</code>和<code>Copied string 2: Hello, world!</code>。</p></li>
</ul></li>
<li><strong>安全风险和注意事项</strong>
<ul>
<li><strong>strcpy</strong>：存在缓冲区溢出的安全风险。如果<code>destination</code>字符串的长度小于<code>source</code>字符串的长度，就会导致缓冲区溢出，可能会覆盖其他内存区域的数据，甚至可能导致程序崩溃或产生安全漏洞。例如，如果<code>destination</code>的大小只有
6 字节，而<code>source</code>是一个长度大于 6
的字符串，如<code>"abcdefg"</code>，使用<code>strcpy</code>就会出现问题。</li>
<li><strong>strncpy</strong>：虽然可以通过指定复制的字符数<code>n</code>来在一定程度上避免缓冲区溢出，但是如果使用不当，也会出现问题。如忘记在<code>source</code>长度大于等于<code>n</code>时手动添加
'\0'，会导致<code>destination</code>字符串可能没有正确结束，从而在后续使用这个字符串时产生意外的结果。</li>
</ul></li>
<li><strong>适用场景</strong>
<ul>
<li><strong>strcpy</strong>：适用于已知<code>destination</code>足够大，能够容纳<code>source</code>字符串的情况，比如在对一些已经初始化好足够空间的字符串进行复制操作时。例如，在处理固定大小且足够大的缓冲区来接收另一个已知长度不会超过它的字符串时可以使用。</li>
<li><strong>strncpy</strong>：适用于对复制字符数量有明确限制的情况，比如只需要复制字符串的前一部分，或者在处理可能会出现缓冲区大小不确定的情况，通过限制复制字符数来防止缓冲区溢出。例如，在从网络接收数据，并且只希望将接收到的前几个字节作为字符串处理时，可以使用<code>strncpy</code>。</li>
</ul></li>
</ol>
<h3 id="strcat-与strncat">strcat 与strncat</h3>
<ol type="1">
<li><strong>含义</strong>
<ul>
<li><strong>strcat</strong>：是 C
语言中的字符串拼接函数。它的函数原型是<code>char* strcat(char* destination, const char* source)</code>。该函数会将<code>source</code>字符串（包括结束符
'\0'）追加到<code>destination</code>字符串的末尾。它首先会找到<code>destination</code>字符串的结束符
'\0'
的位置，然后从这个位置开始，将<code>source</code>字符串的内容逐个字符地复制到<code>destination</code>中，最后在新的<code>destination</code>字符串的末尾添加
'\0'。</li>
<li><strong>strncat</strong>：同样是字符串拼接函数，函数原型为<code>char* strncat(char* destination, const char* source, size_t n)</code>。这个函数会将<code>source</code>字符串中的最多<code>n</code>个字符追加到<code>destination</code>字符串的末尾。它也会先找到<code>destination</code>字符串的结束符
'\0'，然后从这个位置开始复制。如果<code>source</code>字符串的长度小于<code>n</code>，则会将整个<code>source</code>字符串复制过去，并添加
'\0'；如果<code>source</code>字符串的长度大于等于<code>n</code>，则只复制<code>n</code>个字符，然后添加
'\0'。</li>
</ul></li>
<li><strong>使用示例</strong>
<ul>
<li><p><strong>strcat 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">30</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(destination, source);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Concatenated string: %s\n&quot;</span>, destination);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>strcat</code>函数会将<code>source</code>字符串（"world!"）追加到<code>destination</code>字符串（"Hello,"）的末尾，最终输出<code>Concatenated string: Hello, world!</code>。</p></li>
<li><p><strong>strncat 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">30</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;beautiful world!&quot;</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(destination, source, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Concatenated string: %s\n&quot;</span>, destination);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>strncat</code>函数会将<code>source</code>字符串中的前 7
个字符（"beautiful" 中的前 7 个字符，即
"beauti"）追加到<code>destination</code>字符串（"Hello,"）的末尾，最后输出<code>Concatenated string: Hello, beauti</code>。</p></li>
</ul></li>
<li><strong>安全风险和注意事项</strong>
<ul>
<li><strong>strcat</strong>：存在缓冲区溢出的风险。如果<code>destination</code>字符串没有足够的空间来容纳<code>source</code>字符串以及自身原有的内容，就会导致缓冲区溢出。例如，如果<code>destination</code>的长度为
10 字节，已经有内容占用了 6 字节，而<code>source</code>的长度为 5
字节，使用<code>strcat</code>就会超出<code>destination</code>的范围，可能会覆盖其他内存区域的数据。</li>
<li><strong>strncat</strong>：相比<code>strcat</code>，在一定程度上降低了缓冲区溢出的风险。但是如果<code>n</code>的值设置不合理，仍然可能会出现问题。比如，当<code>n</code>设置得过大，使得<code>destination</code>无法容纳追加后的内容，就会出现溢出；当<code>n</code>设置得过小，可能无法完整地追加想要的内容。</li>
</ul></li>
<li><strong>适用场景</strong>
<ul>
<li><strong>strcat</strong>：适用于能够确定<code>destination</code>字符串有足够的空间来容纳拼接后的字符串的情况。例如，在处理一些内部缓冲区大小固定且足够大，并且已经对拼接后的长度有预估的字符串拼接操作时可以使用。</li>
<li><strong>strncat</strong>：更适合用于对拼接字符数量有明确限制的情况，特别是当不确定<code>source</code>字符串的长度或者担心<code>destination</code>的空间不够时。比如，在从用户输入或网络接收数据进行拼接时，为了避免缓冲区溢出，可以使用<code>strncat</code>来限制每次拼接的字符数量。</li>
</ul></li>
</ol>
<h3 id="strcmp-与strncmp">strcmp 与strncmp</h3>
<ol type="1">
<li><p><strong>含义</strong></p>
<ul>
<li><strong>strcmp</strong>：是 C
语言中的字符串比较函数，函数原型为<code>int strcmp(const char* s1, const char* s2)</code>。它用于比较两个字符串<code>s1</code>和<code>s2</code>的内容。比较是基于字符的
ASCII
码值进行的，从两个字符串的第一个字符开始，逐个字符比较。如果<code>s1</code>中的字符的
ASCII 码值小于<code>s2</code>中的相应字符的 ASCII
码值，那么<code>strcmp</code>返回一个负整数；如果<code>s1</code>中的字符的
ASCII 码值大于<code>s2</code>中的相应字符的 ASCII
码值，那么<code>strcmp</code>返回一个正整数；如果两个字符串完全相同（长度相等且每个对应字符都相同），则返回
0。</li>
<li><strong>strncmp</strong>：也是一个字符串比较函数，函数原型是<code>int strncmp(const char* s1, const char* s2, size_t n)</code>。它用于比较两个字符串<code>s1</code>和<code>s2</code>的前<code>n</code>个字符。比较规则和<code>strcmp</code>类似，也是基于字符的
ASCII
码值进行比较。如果在比较的前<code>n</code>个字符中，<code>s1</code>中的字符的
ASCII 码值小于<code>s2</code>中的相应字符的 ASCII
码值，那么<code>strncmp</code>返回一个负整数；如果<code>s1</code>中的字符的
ASCII 码值大于<code>s2</code>中的相应字符的 ASCII
码值，那么<code>strncmp</code>返回一个正整数；如果前<code>n</code>个字符完全相同，则返回
0。</li>
</ul></li>
<li><p><strong>使用示例</strong></p>
<ul>
<li><p><strong>strcmp 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is equal to s2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，因为<code>apple</code>的第一个字符<code>a</code>的
ASCII 码值小于<code>banana</code>的第一个字符<code>b</code>的 ASCII
码值，所以<code>strcmp(s1, s2)</code>返回一个负整数，程序输出<code>s1 is less than s2</code>。</p></li>
<li><p><strong>strncmp 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;abcghi&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">strncmp</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2 (first 3 characters)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2 (first 3 characters)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 is equal to s2 (first 3 characters)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里比较了<code>s1</code>和<code>s2</code>的前 3 个字符，因为这 3
个字符（<code>abc</code>）完全相同，所以<code>strncmp(s1, s2, 3)</code>返回
0，程序输出<code>s1 is equal to s2 (first 3 characters)</code>。</p></li>
</ul></li>
<li><p><strong>区别和注意事项</strong></p>
<ul>
<li><strong>比较范围</strong>：
<ul>
<li><strong>strcmp</strong>：会比较两个字符串的全部内容，直到遇到字符串结束符
'\0'。这意味着它会考虑两个字符串的完整长度来判断是否相等或大小关系。</li>
<li><strong>strncmp</strong>：只比较指定的前<code>n</code>个字符，不考虑字符串后面部分的内容。这种比较方式在只需要关注字符串开头部分是否相同的情况下非常有用，例如比较文件名的前缀或者协议头的部分内容。</li>
</ul></li>
<li><strong>返回值用途</strong>：
<ul>
<li><strong>strcmp</strong>：常用于判断两个完整的字符串是否完全相同。例如，在验证用户输入的密码和存储的密码是否一致时，可以使用<code>strcmp</code>。</li>
<li><strong>strncmp</strong>：可以用于在不需要比较完整字符串的情况下，快速判断部分字符是否相同。比如，在搜索文件系统中以特定前缀开头的文件时，可以使用<code>strncmp</code>来比较文件名的前缀部分。</li>
</ul></li>
<li><strong>安全性和边界情况</strong>：
<ul>
<li><strong>strcmp</strong>：如果两个字符串没有正确地以 '\0'
结束，可能会导致比较结果错误或者程序出现异常行为，因为它会一直比较下去，直到遇到
'\0'。</li>
<li><strong>strncmp</strong>：虽然只比较前<code>n</code>个字符，但也需要注意<code>n</code>的取值。如果<code>n</code>大于字符串的长度，可能会导致访问越界的风险，因为它会尝试读取超出字符串实际长度的字符。同时，如果<code>n</code>取值过小，可能无法得到想要的比较结果。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="strchr-与-strrchr">strchr 与 strrchr</h3>
<ol type="1">
<li><p><strong>含义</strong></p>
<ul>
<li><strong>strchr</strong>：是 C
语言中的字符串处理函数，其函数原型为<code>char* strchr(const char* s, int c)</code>。它的主要功能是在字符串<code>s</code>中查找字符<code>c</code>第一次出现的位置。返回值是一个指向字符<code>c</code>在字符串<code>s</code>中第一次出现位置的指针，如果字符串<code>s</code>中不存在字符<code>c</code>，则返回<code>NULL</code>。这里的字符<code>c</code>可以是普通字符，也可以是字符串结束符<code>'\0'</code>。</li>
<li><strong>strrchr</strong>：也是一个用于字符串查找的函数，函数原型是<code>char* strrchr(const char* s, int c)</code>。它与<code>strchr</code>不同的是，<code>strrchr</code>是在字符串<code>s</code>中查找字符<code>c</code>最后一次出现的位置。返回值同样是一个指向字符<code>c</code>在字符串<code>s</code>中最后一次出现位置的指针，若未找到则返回<code>NULL</code>。</li>
</ul></li>
<li><p><strong>使用示例</strong></p>
<ul>
<li><p><strong>strchr 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">      <span class="type">char</span>* ptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;o&#x27;</span>);<span class="comment">//注意有单引号</span></span><br><span class="line"><span class="keyword">if</span> (ptr!= <span class="literal">NULL</span>)<span class="comment">//表示是空指针</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;The first &#x27;o&#x27; is at position %ld\n&quot;</span>, ptr - str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;o&#x27; not found.\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>strchr(str, 'o')</code>会在字符串<code>str</code>（"hello
world"）中查找字符<code>o</code>第一次出现的位置。如果找到，<code>ptr</code>会指向这个位置，通过<code>ptr - str</code>可以计算出字符<code>o</code>在字符串中的位置索引（从
0 开始）。在这里，第一个<code>o</code>的位置是
4，所以会输出<code>The first 'o' is at position 4</code>。</p></li>
<li><p><strong>strrchr 示例（C 语言）</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* ptr = <span class="built_in">strrchr</span>(str, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The last &#x27;o&#x27; is at position %ld\n&quot;</span>, ptr - str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;o&#x27; not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>strrchr(str, 'o')</code>，它会在字符串<code>str</code>中查找字符<code>o</code>最后一次出现的位置。在这个例子中，最后一个<code>o</code>的位置是
7，所以会输出<code>The last 'o' is at position 7</code>。</p></li>
</ul></li>
<li><p><strong>区别与应用场景</strong></p>
<ul>
<li><strong>查找方向</strong>：
<ul>
<li><strong>strchr</strong>：是从字符串的开头开始查找，一旦找到目标字符就停止查找并返回指针。这种查找方式适用于需要找到某个字符在字符串中首次出现的情况，比如在解析配置文件时，查找某个参数首次出现的位置，以获取其对应的值。</li>
<li><strong>strrchr</strong>：是从字符串的末尾开始往前查找，找到目标字符最后一次出现的位置后返回指针。例如，在处理文件路径时，可能需要找到最后一个目录分隔符（如<code>/</code>或<code>\</code>）的位置，以便提取文件名部分，这时<code>strrchr</code>就非常有用。</li>
</ul></li>
<li><strong>应用场景举例</strong>：
<ul>
<li><strong>strchr</strong>：在处理文本文件中的命令行格式内容时，如果命令格式是<code>command -option value</code>，可以使用<code>strchr</code>来查找<code>-</code>首次出现的位置，从而确定命令选项的开始位置。</li>
<li><strong>strrchr</strong>：当处理 URL
时，比如<code>https://example.com/path/to/file.html</code>，可以使用<code>strrchr</code>来找到最后一个<code>/</code>的位置，进而提取出文件名<code>file.html</code>。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="strstr">strstr</h3>
<ol type="1">
<li><p><strong>函数定义与功能</strong></p>
<ul>
<li><strong>strstr</strong>是 C
语言中的一个字符串处理函数，函数原型为<code>char* strstr(const char* haystack, const char* needle)</code>。它的主要作用是在字符串<code>haystack</code>中查找第一次出现字符串<code>needle</code>的位置。</li>
<li>如果找到了<code>needle</code>，则返回一个指向<code>haystack</code>中<code>needle</code>首次出现位置的指针；如果<code>needle</code>为空字符串，则返回<code>haystack</code>本身；如果在<code>haystack</code>中没有找到<code>needle</code>，则返回<code>NULL</code>。</li>
</ul></li>
<li><p><strong>使用示例</strong></p>
<ul>
<li><p><strong>示例一：简单查找子串</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> haystack[] = <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> needle[] = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">strstr</span>(haystack, needle);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Substring found at position %ld\n&quot;</span>, result - haystack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Substring not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>strstr(haystack, needle)</code>会在<code>haystack</code>（"This
is a test
string"）中查找<code>needle</code>（"test"）第一次出现的位置。如果找到，<code>result</code>会指向这个位置，通过<code>result - haystack</code>可以计算出子串在原字符串中的位置索引（从
0 开始）。在这里，子串 "test" 的位置是
10，所以会输出<code>Substring found at position 10</code>。</p></li>
<li><p><strong>示例二：空字符串作为查找内容</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> haystack[] = <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> needle[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">strstr</span>(haystack, needle);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty substring found, and the pointer is: %p\n&quot;</span>, (<span class="type">void</span>*)result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Substring not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当<code>needle</code>为空字符串时，按照函数定义，<code>strstr</code>会返回<code>haystack</code>本身。这里会输出<code>Empty substring found, and the pointer is: 0x7ffee7c0</code>（地址值可能因运行环境不同而不同）。</p></li>
</ul></li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><strong>文本处理与搜索</strong>：在文本编辑器或者文档处理软件中，可以使用<code>strstr</code>来实现查找功能。例如，在一个长篇文档中查找特定的单词或者短语，确定它们在文档中的位置，方便后续的编辑操作，如替换、标记等。</li>
<li><strong>数据解析</strong>：在解析网络协议、配置文件等数据格式时，<code>strstr</code>可以帮助查找特定的关键字或者标签。比如，在解析
HTML
文件时，通过查找<code>&lt;body&gt;</code>标签来定位文档主体部分的开始位置，或者查找特定的
CSS 类名来提取对应的样式信息。</li>
<li><strong>代码文本分析</strong>：在代码格式化工具或者代码审查工具中，<code>strstr</code>可以用于查找特定的代码结构或者关键字。例如，在
C/C++
代码中查找函数定义的位置，通过查找<code>&#123;</code>和<code>&#125;</code>来确定函数体的范围，或者查找特定的头文件引用等。</li>
</ul></li>
</ol>
<h3 id="strtok">strtok</h3>
<ol type="1">
<li><strong>函数定义与原理</strong>
<ul>
<li><strong>strtok</strong>是 C
语言中用于字符串分割的函数，函数原型为<code>char* strtok(char* str, const char* delimiters)</code>。</li>
<li>它的工作原理是在字符串<code>str</code>中根据<code>delimiters</code>指定的分隔符来分割字符串。第一次调用<code>strtok</code>时，它会在<code>str</code>中查找第一个非分隔符字符，然后从这个字符开始，查找下一个分隔符，将分隔符替换为<code>'\0'</code>，并返回指向这个非分隔符字符的指针。后续调用<code>strtok</code>（传递<code>NULL</code>作为第一个参数）时，它会从上次结束的位置继续，在剩余的字符串中继续按照相同的规则进行分割。</li>
</ul></li>
<li><strong>使用示例</strong>
<ul>
<li><p><strong>简单的字符串分割示例</strong></p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;apple,banana;cherry&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* token = strtok(str, <span class="string">&quot;,;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (token!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,;&quot;</span>);<span class="comment">//从上次结束的位置开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，首先定义了一个包含多种分隔符（<code>,;</code>）的字符串<code>str</code>。第一次调用<code>strtok(str, ",;")</code>时，它会在<code>str</code>中找到第一个非分隔符字符（<code>a</code>），然后找到第一个分隔符（<code>,</code>），将其替换为<code>'\0'</code>，并返回指向<code>apple</code>的指针。在<code>while</code>循环中，每次输出当前的<code>token</code>（即分割后的子字符串），然后再次调用<code>strtok(NULL, ",;")</code>，它会从上次结束的位置（在第一次循环后，是<code>banana;cherry</code>）继续进行分割，直到返回<code>NULL</code>，表示已经分割完所有的子字符串。这个程序会输出：</p>
<p>收起</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">cherry</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><strong>注意事项</strong>
<ul>
<li><strong>修改原字符串</strong>：<code>strtok</code>会修改原始字符串，将分隔符替换为<code>'\0'</code>，这在某些情况下可能会影响原始数据的完整性。如果不希望修改原始字符串，可以先复制一份再进行分割操作。</li>
<li><strong>多线程环境</strong>：<code>strtok</code>不是线程安全的。在多线程环境下，如果多个线程同时调用<code>strtok</code>，可能会导致不可预测的结果。如果需要在多线程环境下进行字符串分割，可以考虑使用可重入的替代函数，如<code>strtok_r</code>（在一些系统中提供）。</li>
<li><strong>分隔符字符串的处理</strong>：分隔符字符串中的每个字符都被视为独立的分隔符。例如，在上面的示例中，<code>,;</code>表示字符串可以被逗号或者分号分割。</li>
</ul></li>
<li><strong>应用场景</strong>
<ul>
<li><strong>命令行参数解析</strong>：在处理命令行输入的程序中，<code>strtok</code>可以用于将命令行字符串分割成各个参数。例如，对于命令<code>cp file1.txt file2.txt</code>，可以使用<code>strtok</code>将其分割为<code>cp</code>、<code>file1.txt</code>和<code>file2.txt</code>，以便进一步处理每个参数。</li>
<li><strong>文本数据提取</strong>：在处理文本文件，如
CSV（逗号分隔值）文件时，<code>strtok</code>可以用于提取每一列的数据。例如，对于一行
CSV
数据<code>"John,Doe,30"</code>，可以使用<code>strtok</code>将其分割为<code>John</code>、<code>Doe</code>和<code>30</code>，方便后续的数据存储和处理。</li>
</ul></li>
</ol>
<h2 id="函数所在标准库必看">函数所在标准库（必看）</h2>
<ol type="1">
<li><strong><code>&lt;string.h&gt;</code>库</strong>
<ul>
<li><strong>strlen</strong>、<strong>strcpy</strong>、<strong>strncpy</strong>、<strong>strcat</strong>、<strong>strncat</strong>、<strong>strcmp</strong>、<strong>strncmp</strong>、<strong>strchr</strong>、<strong>strrchr</strong>、<strong>strstr</strong>、<strong>strtok</strong>这些函数都在
C
语言的<code>&lt;string.h&gt;</code>标准库中。这个库提供了一系列用于处理
C 风格字符串（以<code>'\0'</code>结尾的字符数组）的函数。</li>
<li>例如，在 C
程序中，如果要使用<code>strcpy</code>函数来复制字符串，需要在代码开头包含<code>#include &lt;string.h&gt;</code>头文件，这样编译器才能找到<code>strcpy</code>函数的定义并正确地编译程序。</li>
</ul></li>
<li><strong><code>&lt;stdio.h&gt;</code>库</strong>
<ul>
<li><strong>sprintf</strong>和<strong>sscanf</strong>函数在 C
语言的<code>&lt;stdio.h&gt;</code>标准库中。这个库主要用于输入 /
输出操作，<code>sprintf</code>和<code>sscanf</code>函数在一定程度上与格式化的输入输出有关。<code>sprintf</code>用于将格式化的数据写入字符串，<code>sscanf</code>用于从字符串中读取并解析格式化的数据，它们的功能和<code>printf</code>、<code>scanf</code>类似，只是操作对象是字符串而不是标准输入输出设备。</li>
<li>同样，在使用<code>sprintf</code>或<code>sscanf</code>函数时，需要在程序开头包含<code>#include &lt;stdio.h&gt;</code>头文件，以确保程序能够正确调用这些函数。</li>
</ul></li>
</ol>
<h1 id="文件">文件</h1>
<h2 id="读写函数">读写函数</h2>
<h3 id="fputc-fgetc">fputc fgetc</h3>
<ol type="1">
<li><strong><code>fputc</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>int fputc(int c, FILE *stream);</code></li>
<li><strong>功能描述</strong>：
<ul>
<li>将字符<code>c</code>写入到指定的文件流<code>stream</code>中。其中<code>c</code>是要写入的字符（可以是一个字符常量或字符变量），<code>stream</code>是指向<code>FILE</code>类型的指针，它表示一个文件流，通常是通过<code>fopen</code>函数打开文件后返回的文件指针。</li>
</ul></li>
<li><strong>返回值</strong>：
<ul>
<li>如果写入成功，返回写入的字符（即参数<code>c</code>的值）。</li>
<li>如果发生错误，返回<code>EOF</code>（<code>EOF</code>是在<code>&lt;stdio.h&gt;</code>头文件中定义的一个常量，通常值为
- 1）。</li>
</ul></li>
<li><strong>示例</strong>：</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = fputc(ch, fp);</span><br><span class="line">    <span class="keyword">if</span> (result == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error writing to file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    eclse</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;%c&#x27; written successfully.\n&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，首先打开一个名为<code>test.txt</code>的文件（如果文件不存在则创建，如果存在则截断内容），然后使用<code>fputc</code>函数将字符<code>'A'</code>写入文件。最后关闭文件。如果写入过程中出现错误，<code>fputc</code>会返回<code>EOF</code>，程序会输出错误信息；如果写入成功，会输出成功信息。</li>
</ul>
<ol start="2" type="1">
<li><strong><code>fgetc</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>int fgetc(FILE *stream);</code></li>
<li><strong>功能描述</strong>：
<ul>
<li>从指定的文件流<code>stream</code>中读取一个字符。它会返回读取到的字符（以<code>int</code>类型返回，因为<code>EOF</code>也是一个特殊的返回值，<code>EOF</code>的值不能和任何有效的字符值混淆，所以使用<code>int</code>类型来接收返回值）。</li>
</ul></li>
<li><strong>返回值</strong>：
<ul>
<li>如果读取成功，返回读取到的字符（其值范围是 0 - 255，表示 ASCII
码值）。</li>
<li>如果到达文件末尾或者发生错误，返回<code>EOF</code>。</li>
</ul></li>
<li><strong>示例</strong>：</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = fgetc(fp);</span><br><span class="line">    <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (feof(fp))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;End of file reached.\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          perror(<span class="string">&quot;cError reading file&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Character read: %c\n&quot;</span>, (<span class="type">char</span>)ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，首先尝试打开一个名为<code>test.txt</code>的文件用于读取。然后使用<code>fgetc</code>函数从文件中读取一个字符。如果读取到的是<code>EOF</code>，会进一步判断是因为到达文件末尾（使用<code>feof</code>函数判断）还是发生错误。如果读取成功，则输出读取到的字符。最后关闭文件。</li>
<li><h3 id="fputs-fgets">fputs fgets</h3></li>
</ul>
<ol type="1">
<li><strong><code>fputs</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>int fputs(const char *str, FILE *stream);</code></li>
<li><strong>功能描述</strong>：
<ul>
<li>用于将一个字符串<code>str</code>写入到指定的文件流<code>stream</code>中。这里的字符串<code>str</code>以空字符<code>'\0'</code>作为结束标志，但<code>fputs</code>函数不会将空字符写入文件。它是顺序写入，从字符串的第一个字符开始，直到遇到<code>'\0'</code>结束。</li>
</ul></li>
<li><strong>返回值</strong>：
<ul>
<li>如果写入成功，返回一个非负整数。</li>
<li>如果发生错误，返回<code>EOF</code>。</li>
</ul></li>
<li><strong>示例</strong>：</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fputs</span>(str, fp);</span><br><span class="line">    <span class="keyword">if</span> (result == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error writing to file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elsec</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;String written successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，首先打开一个文件<code>test.txt</code>用于写入。然后使用<code>fputs</code>函数将字符串<code>"Hello, World!"</code>写入文件。如果写入过程没有错误，会输出成功信息；如果出现错误，则会输出错误信息。最后关闭文件。</li>
</ul>
<ol start="2" type="1">
<li><strong><code>fgets</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>char *fgets(char *str, int n, FILE *stream);</code></li>
<li><strong>功能描述</strong>：
<ul>
<li>从指定的文件流<code>stream</code>中读取最多<code>n - 1</code>个字符，并将它们存储到字符数组<code>str</code>中。读取过程会在遇到换行符<code>'\n'</code>、文件末尾或者已经读取了<code>n - 1</code>个字符时停止。最后会在读取的字符数组末尾添加一个空字符<code>'\0'</code>，以形成一个有效的
C 字符串。</li>
</ul></li>
<li><strong>返回值</strong>：
<ul>
<li>如果读取成功，返回指向字符数组<code>str</code>的指针。</li>
<li>如果遇到文件末尾且没有读取到任何字符，返回<code>NULL</code>。</li>
<li>如果发生错误，返回<code>NULL</code>。</li>
</ul></li>
<li><strong>示例</strong>：</li>
</ul></li>
</ol>
<p>c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *result = fgets(str, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (feof(fp))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;End of file reached.\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;String read: %s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，首先打开一个文件<code>test.txt</code>用于读取。然后使用<code>fgets</code>函数从文件中读取最多
99
个字符（因为要预留一个位置给空字符<code>'\0'</code>）到字符数组<code>str</code>中。如果读取成功，会输出读取到的字符串；如果遇到文件末尾或者发生错误，会根据具体情况输出相应的信息。最后关闭文件。</li>
</ul>
<h3 id="fprintf-fscanf">fprintf fscanf</h3>
<ol type="1">
<li>. <strong><code>fprintf</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>int fprintf(FILE *stream, const char *format,...);</code></li>
<li><strong>功能描述</strong>
<ul>
<li>将格式化的数据输出到指定的文件流<code>stream</code>中。<code>format</code>参数是格式化字符串，与<code>printf</code>函数的格式化字符串类似，用于指定输出数据的格式。<code>...</code>表示可变参数列表，包含要输出的数据。例如，可以使用<code>%d</code>输出整数，<code>%f</code>输出浮点数，<code>%s</code>输出字符串等格式。</li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li>成功写入的字符数（不包括结束符<code>'\0'</code>）。如果出现错误，返回一个负数。</li>
</ul></li>
<li><strong>示例</strong></li>
</ul></li>
</ol>
<p>c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> fnum = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Number: %d, Float number: %.2f, String: %s\n&quot;</span>, num, fnum, str);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error writing to file&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data written successfully. %d characters written.\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，打开一个名为<code>output.txt</code>的文件用于写入。然后使用<code>fprintf</code>函数将变量<code>num</code>（整数）、<code>fnum</code>（浮点数）和<code>str</code>（字符串）按照指定的格式输出到文件中。根据<code>fprintf</code>的返回值判断写入是否成功。最后关闭文件。</li>
</ul>
<ol start="2" type="1">
<li><strong><code>fscanf</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>int fscanf(FILE *stream, const char *format,...);</code></li>
<li><strong>功能描述</strong>
<ul>
<li>从指定的文件流<code>stream</code>中按照<code>format</code>指定的格式读取数据。<code>format</code>参数是一个格式化字符串，与<code>scanf</code>函数的格式化字符串类似，用于指定读取数据的类型和格式。例如，<code>%d</code>用于读取整数，<code>%f</code>用于读取浮点数，<code>%s</code>用于读取字符串等。<code>...</code>表示可变参数列表，用于接收从文件中读取的数据并存储到相应的变量中。</li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li>成功读取的输入项的数目。如果在读取任何数据之前到达文件末尾，则返回<code>EOF</code>。如果读取过程中出现错误，返回值是不确定的，可能小于预期读取的项数。</li>
</ul></li>
<li><strong>示例</strong></li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> fnum;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d %f %s&quot;</span>, &amp;num, &amp;fnum, str);</span><br><span class="line">    <span class="keyword">if</span> (result == EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;End of file reached before any data was read.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data read successfully: num = %d, fnum = %.2f, str = %s\n&quot;</span>, num, fnum, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Partial data read. Expected 3 items, but read %d.\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，假设<code>data.txt</code>文件中包含一行数据，格式为
“整数 浮点数
字符串”。通过<code>fscanf</code>函数从文件中读取数据到变量<code>num</code>（整数）、<code>fnum</code>（浮点数）和<code>str</code>（字符串）中。根据<code>fscanf</code>的返回值来判断读取是否成功以及读取的完整程度。最后关闭文件。</li>
</ul>
<h2 id="文件定位">文件定位</h2>
<h3 id="feof">feof</h3>
<ol type="1">
<li><strong>函数原型</strong>
<ul>
<li><code>int feof(FILE *stream);</code></li>
</ul></li>
<li><strong>功能描述</strong>
<ul>
<li><p><code>feof</code>函数用于检测文件流<code>stream</code>是否到达了文件末尾。它通过检查文件结束标志来判断。当文件读取操作已经尝试读取超过文件的最后一个字节时，文件结束标志会被设置，此时<code>feof</code>函数会返回一个非零值（通常为
1），表示已经到达文件末尾。</p></li>
<li><p>例如，在循环读取文件内容时，当<code>fgetc</code>或者<code>fgets</code>等读取函数返回<code>EOF</code>（文件结束符，在<code>&lt;stdio.h&gt;</code>中定义，通常值为
-
1）时，不能简单地认为就是到达了文件末尾。因为<code>EOF</code>也可能是由于读取错误而返回的。这时就需要使用<code>feof</code>函数来进一步确认是否真的是到达了文件末尾。如果<code>feof</code>返回非零值，那就是到达文件末尾；如果<code>feof</code>返回
0，那可能是读取过程中出现了错误。</p></li>
</ul></li>
<li><strong>示例</strong>
<ul>
<li>以下是一个简单的示例，用于读取一个文本文件的内容，直到到达文件末尾。</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环读取文件内容</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(fp))!= EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否是因为到达文件末尾而结束读取</span></span><br><span class="line">    <span class="keyword">if</span> (feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\nEnd of file reached.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，首先打开文件<code>test.txt</code>用于读取。然后通过一个<code>while</code>循环使用<code>fgetc</code>函数逐个字符地读取文件内容，并将读取到的字符输出到控制台。当<code>fgetc</code>返回<code>EOF</code>时，循环结束。接着使用<code>feof</code>函数来检查是否是因为到达文件末尾而结束读取。如果是，就输出相应的提示信息；如果不是，就输出读取错误的提示信息。最后关闭文件。</li>
</ul>
<ol start="4" type="1">
<li><strong>需要注意的地方</strong>
<ul>
<li>只有在尝试读取文件结束后的位置时，<code>feof</code>函数才会返回非零值。也就是说，在最后一次成功读取之后，文件结束标志还没有被设置。当读取函数返回<code>EOF</code>后，再调用<code>feof</code>函数才能正确判断是否到达文件末尾。</li>
<li>不能仅仅依靠<code>feof</code>来控制文件读取的循环，因为如果文件一开始就是空文件，<code>feof</code>函数在还没有进行任何读取操作时是不会返回非零值的。所以通常是结合读取函数（如<code>fgetc</code>或<code>fgets</code>）的返回值和<code>feof</code>函数来准确地判断文件读取的状态。</li>
</ul></li>
</ol>
<h3 id="fseek">fseek</h3>
<ol type="1">
<li><strong>函数原型</strong>
<ul>
<li><code>int fseek(FILE *stream, long int offset, int whence);</code></li>
</ul></li>
<li><strong>参数含义</strong>
<ul>
<li><strong><code>stream</code></strong>：这是一个指向<code>FILE</code>类型的指针，表示已经打开的文件流。例如，通过<code>fopen</code>函数打开文件后得到的文件指针。</li>
<li><strong><code>offset</code></strong>：这是一个长整型的值，表示相对于<code>whence</code>位置的偏移量。它可以是正数、负数或者零。如果是正数，表示向文件末尾方向移动；如果是负数，表示向文件开头方向移动。</li>
<li><strong><code>whence</code></strong>：这是一个整型常量，用于指定偏移量<code>offset</code>的起始位置。它有以下三个可能的值：
<ul>
<li><strong><code>SEEK_SET</code>（0）</strong>：文件开头。此时<code>offset</code>是从文件开头开始计算的字节数。例如，如果<code>offset</code>为
0，那么文件指针将定位到文件的第一个字节；如果<code>offset</code>为
5，文件指针将定位到文件的第 6 个字节（因为字节索引从 0 开始）。</li>
<li><strong><code>SEEK_CUR</code>（1）</strong>：文件当前位置。<code>offset</code>是相对于当前文件指针位置的字节数。例如，如果当前文件指针在第
10 个字节处，<code>offset</code>为 3，那么文件指针将移动到第 13
个字节处。</li>
<li><strong><code>SEEK_END</code>（2）</strong>：文件末尾。<code>offset</code>是相对于文件末尾的字节数。需要注意的是，当<code>offset</code>为
0 时，文件指针将定位到文件的最后一个字节；如果<code>offset</code>为 -
5，文件指针将定位到倒数第 5 个字节。</li>
</ul></li>
</ul></li>
<li><strong>功能描述</strong>
<ul>
<li><code>fseek</code>函数主要用于移动文件内部的读写指针。通过调整指针的位置，可以实现对文件中任意位置的数据进行读写操作。例如，在处理大型文件时，可能需要跳转到文件中间的某个位置读取特定的数据块，或者在文件末尾添加新的数据之前先将指针移动到文件末尾。</li>
</ul></li>
<li><strong>返回值</strong>
<ul>
<li>如果成功移动文件指针，<code>fseek</code>函数返回 0。</li>
<li>如果发生错误，例如试图移动到文件范围之外的位置或者文件不支持定位操作（如某些特殊的管道文件或设备文件），则返回非零值。</li>
</ul></li>
<li><strong>示例</strong>
<ul>
<li>以下示例展示了如何使用<code>fseek</code>函数。假设存在一个文本文件<code>test.txt</code>，文件内容为
“Hello World”。</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将文件指针移动到文件的第6个字节（索引为5）</span></span><br><span class="line">    <span class="type">int</span> result = fseek(fp, <span class="number">5</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error seeking in file&quot;</span>);</span><br><span class="line">       fclose(fp);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = fgetc(fp);</span><br><span class="line">    <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (feof(fp))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;End of file reached.\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          perror(<span class="string">&quot;Error reading file&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Character read after seeking: %c\n&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，首先打开文件<code>test.txt</code>用于读取。然后使用<code>fseek</code>函数将文件指针从文件开头（<code>SEEK_SET</code>）移动到第
6 个字节（偏移量为
5）。如果<code>fseek</code>操作成功，接着使用<code>fgetc</code>函数读取文件指针当前位置的字符，并输出该字符。最后关闭文件。</li>
</ul>
<h3 id="rewind">rewind</h3>
<ol type="1">
<li><strong>函数原型</strong>
<ul>
<li><code>void rewind(FILE *stream);</code></li>
</ul></li>
<li><strong>功能描述</strong>
<ul>
<li><code>rewind</code>函数用于将文件指针重新定位到文件的开头。当对一个文件进行了多次读写操作，且读写指针已经移动到文件中的其他位置后，使用<code>rewind</code>函数可以快速地将指针重置，以便重新从文件的开头进行读取或写入操作。</li>
<li>这个函数实际上等价于<code>fseek(stream, 0L, SEEK_SET)</code>，也就是将文件指针相对于文件开头（<code>SEEK_SET</code>）移动
0 个字节，从而达到将文件指针定位到文件起始位置的目的。</li>
</ul></li>
<li><strong>示例</strong>
<ul>
<li>假设我们有一个文件<code>data.txt</code>，里面包含一些文本内容。以下示例展示了如何先读取一部分内容，然后使用<code>rewind</code>函数重新回到文件开头再次读取。</li>
</ul></li>
</ol>
<p>c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次读取部分内容</span></span><br><span class="line">    fgets(buffer, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First read: %s&quot;</span>, buffer);</span><br><span class="line">    <span class="comment">// 将文件指针重置到文件开头</span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">// 第二次读取部分内容</span></span><br><span class="line">    fgets(buffer, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second read after rewind: %s&quot;</span>, buffer);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，首先打开文件<code>data.txt</code>用于读取。通过<code>fgets</code>函数第一次读取文件中的一部分内容并打印出来。然后使用<code>rewind</code>函数将文件指针重新定位到文件开头。接着再次使用<code>fgets</code>函数读取文件内容并打印，此时读取的内容和第一次开始读取的内容是相同的（如果文件内容没有被修改），这展示了<code>rewind</code>函数将文件指针复位的功能。</li>
</ul>
<h1 id="stdlib库中常见函数">stdlib库中常见函数</h1>
<ol type="1">
<li><strong>内存分配与释放相关函数</strong>
<ul>
<li><strong>malloc</strong>：
<ul>
<li>功能：用于动态分配指定字节数的内存空间。函数原型为<code>void* malloc(size_t size)</code>，它返回一个指向所分配内存空间起始地址的指针。例如，<code>int* ptr = (int*)malloc(10 * sizeof(int));</code>会分配可以存储
10
个<code>int</code>类型数据的内存空间，返回的指针需要进行类型转换后存储在<code>ptr</code>中。</li>
<li>应用场景：当程序运行时不确定需要多少内存来存储数据，比如读取一个文件，文件大小事先未知，就可以使用<code>malloc</code>来动态分配足够的内存空间来存储文件内容。</li>
</ul></li>
<li><strong>calloc</strong>：
<ul>
<li>功能：用于动态分配内存空间并将其初始化为
0。函数原型是<code>void* calloc(size_t num, size_t size)</code>，它会分配<code>num</code>个大小为<code>size</code>字节的内存块，并将这些内存块的内容初始化为
0。例如，<code>float* arr = (float*)calloc(5, sizeof(float));</code>会分配可以存储
5 个<code>float</code>类型数据的内存空间，并且这些空间初始化为 0。</li>
<li>应用场景：在创建数组时，如果希望数组元素初始值为
0，使用<code>calloc</code>会很方便。比如在统计数据的程序中，初始化一个计数器数组。</li>
</ul></li>
<li><strong>realloc</strong>：
<ul>
<li>功能：用于重新分配已经通过<code>malloc</code>或<code>calloc</code>等函数分配的内存空间的大小。函数原型为<code>void* realloc(void* ptr, size_t size)</code>，它会尝试调整<code>ptr</code>所指向的内存块的大小为<code>size</code>字节。如果调整成功，返回一个指向重新分配后的内存块起始地址的指针；如果无法调整（比如没有足够的连续内存），返回<code>NULL</code>，并且原来的内存块不会被释放。例如，<code>int* new_ptr = (int*)realloc(ptr, 20 * sizeof(int));</code>尝试将<code>ptr</code>指向的内存空间大小调整为可以存储
20 个<code>int</code>类型数据的空间。</li>
<li>应用场景：当程序对数据的需求发生变化，比如需要存储更多的数据时，可以使用<code>realloc</code>来扩展已经分配的内存空间，而不是重新分配一块全新的内存，这样可以避免浪费之前已经存储的数据。</li>
</ul></li>
<li><strong>free</strong>：
<ul>
<li>功能：用于释放通过<code>malloc</code>、<code>calloc</code>或<code>realloc</code>等函数分配的内存空间。函数原型为<code>void free(void* ptr)</code>。例如，<code>free(ptr);</code>会释放<code>ptr</code>所指向的内存空间，之后这块内存可以被操作系统重新分配给其他程序或进程使用。</li>
<li>应用场景：在动态分配的内存不再需要时，必须使用<code>free</code>释放，以避免内存泄漏。比如一个函数中动态分配了内存来存储临时数据，当函数执行完毕，这些内存应该被释放。</li>
</ul></li>
</ul></li>
<li><strong>数值转换函数</strong>
<ul>
<li><strong>atoi</strong>：
<ul>
<li>功能：将字符串转换为整数。函数原型为<code>int atoi(const char* str)</code>，它会扫描字符串<code>str</code>，跳过前面的空白字符（空格、制表符、换行符等），然后从第一个非空白字符开始解析整数。如果字符串无法正确解析为整数，返回
0。例如，<code>int num = atoi("123");</code>会将字符串<code>"123"</code>转换为整数
123。</li>
<li>应用场景：在处理用户输入或读取配置文件中的数字字符串时很有用。比如用户在命令行输入一个数字作为参数，程序可以使用<code>atoi</code>将这个字符串参数转换为整数进行后续计算。</li>
</ul></li>
<li><strong>atol</strong>：
<ul>
<li>功能：将字符串转换为长整数。函数原型为<code>long atol(const char* str)</code>，其工作原理和<code>atoi</code>类似，只是转换的结果是长整数类型。例如，<code>long num = atol("1234567890");</code>会将字符串<code>"1234567890"</code>转换为长整数
1234567890。</li>
<li>应用场景：当需要处理可能超出<code>int</code>范围的整数字符串时可以使用<code>atol</code>，比如处理文件大小等可能是较大整数的情况。</li>
</ul></li>
<li><strong>atof</strong>：
<ul>
<li>功能：将字符串转换为浮点数。函数原型为<code>float atof(const char* str)</code>，它会扫描字符串<code>str</code>，跳过空白字符，然后从第一个非空白字符开始解析浮点数。例如，<code>float num = atof("3.14");</code>会将字符串<code>"3.14"</code>转换为浮点数
3.14。</li>
<li>应用场景：在读取包含浮点数信息的文本文件或者用户输入的浮点数字符串时，用于将字符串转换为浮点数进行数学运算。</li>
</ul></li>
</ul></li>
<li><strong>随机数生成相关函数（以 srand 和 rand 为例）</strong>
<ul>
<li><strong>srand</strong>：
<ul>
<li>功能：用于初始化随机数生成器。函数原型为<code>void srand(unsigned int seed)</code>，它接受一个无符号整数<code>seed</code>作为种子，不同的种子会导致<code>rand</code>函数（下面介绍）生成不同序列的随机数。例如，<code>srand((unsigned int)time(NULL));</code>使用当前时间作为种子来初始化随机数生成器，这样每次程序运行时由于时间不同，生成的随机数序列也会不同。</li>
<li>应用场景：在需要生成伪随机数的程序中，如游戏中的随机事件（怪物掉落物品的概率、随机地图生成等）、模拟实验中的随机样本等场景下，需要先使用<code>srand</code>初始化随机数生成器。</li>
</ul></li>
<li><strong>rand</strong>：
<ul>
<li>功能：用于生成伪随机数。函数原型为<code>int rand(void)</code>，它会返回一个介于
0
和<code>RAND_MAX</code>（一个在<code>&lt;stdlib.h&gt;</code>中定义的常量，通常是一个较大的整数）之间的整数。例如，<code>int random_num = rand();</code>会生成一个随机整数。</li>
<li>应用场景：结合<code>srand</code>使用，可以在很多需要随机元素的程序中生成随机数。比如在抽奖程序中，使用<code>rand</code>来确定中奖号码；在生成随机测试数据时，使用<code>rand</code>来生成各种数值。</li>
</ul></li>
</ul></li>
<li><strong>程序终止相关函数（以 exit 为例）</strong>
<ul>
<li><strong>exit</strong>：
<ul>
<li>功能：用于立即终止程序的执行。函数原型为<code>void exit(int status)</code>，其中<code>status</code>是程序的退出状态码，0
表示正常退出，非 0
值表示异常退出。例如，<code>exit(0);</code>会正常结束程序，而<code>exit(1);</code>会以错误状态结束程序。</li>
<li>应用场景：当程序遇到无法恢复的错误，如无法打开关键的配置文件、内存分配失败等情况时，可以使用<code>exit</code>来终止程序，以避免程序继续执行产生不可预测的结果。同时，在一些脚本或简单的命令行工具中，完成任务后可以使用<code>exit</code>正常退出。</li>
</ul></li>
</ul></li>
</ol>
<h1 id="math库中常见函数">math库中常见函数</h1>
<h2 id="三角函数相关函数"><strong>三角函数相关函数</strong></h2>
<ol type="1">
<li><ul>
<li><strong><code>sin</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double sin(double x);</code></li>
<li><strong>功能描述</strong>：计算弧度为<code>x</code>的正弦值。返回值的范围是<code>[-1,1]</code>。例如，<code>sin(0)</code>返回<code>0</code>，<code>sin(M_PI/2)</code>（假设已经定义了<code>M_PI</code>为圆周率<code>π</code>的值）返回<code>1</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>cos</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double cos(double x);</code></li>
<li><strong>功能描述</strong>：计算弧度为<code>x</code>的余弦值。返回值范围也是<code>[-1,1]</code>。例如，<code>cos(0)</code>返回<code>1</code>，<code>cos(M_PI)</code>返回 <code>- 1</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>tan</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double tan(double x);</code></li>
<li><strong>功能描述</strong>：计算弧度为<code>x</code>的正切值。当<code>x</code>是<code>π/2 + kπ</code>（<code>k</code>为整数）时，函数值趋近于无穷大，此时可能会产生溢出等错误。例如，<code>tan(M_PI/4)</code>返回<code>1</code>。</li>
<li><h2
id="反三角函数相关函数"><strong>反三角函数相关函数</strong></h2></li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>asin</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double asin(double x);</code></li>
<li><strong>功能描述</strong>：计算<code>x</code>的反正弦值，返回值的范围是<code>[-π/2,π/2]</code>。<code>x</code>的取值范围是<code>[-1,1]</code>，如果<code>x</code>不在这个范围内，函数会产生定义域错误。例如，<code>asin(0.5)</code>返回约<code>0.5236</code>（弧度，即<code>π/6</code>）。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>acos</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double acos(double x);</code></li>
<li><strong>功能描述</strong>：计算<code>x</code>的反余弦值，返回值范围是<code>[0,π]</code>。<code>x</code>的取值范围是<code>[-1,1]</code>。例如，<code>acos(0.5)</code>返回约<code>1.0472</code>（弧度，即<code>π/3</code>）。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>atan</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double atan(double x);</code></li>
<li><strong>功能描述</strong>：计算<code>x</code>的反正切值，返回值范围是<code>(-π/2,π/2)</code>。例如，<code>atan(1)</code>返回约<code>0.7854</code>（弧度，即<code>π/4</code>）。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>atan2</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double atan2(double y, double x);</code></li>
<li><strong>功能描述</strong>：计算<code>y/x</code>的反正切值，但它会考虑<code>x</code>和<code>y</code>的符号来确定正确的象限。返回值范围是<code>(-π,π]</code>。这个函数在计算向量的角度等场景中非常有用，例如，<code>atan2(1,1)</code>返回约<code>0.7854</code>（弧度，即<code>π/4</code>）。</li>
<li><h2 id="指数和对数函数"><strong>指数和对数函数</strong></h2></li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>exp</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double exp(double x);</code></li>
<li><strong>功能描述</strong>：计算自然常数<code>e</code>（约为<code>2.71828</code>）的<code>x</code>次幂。例如，<code>exp(1)</code>返回<code>e</code>的值，<code>exp(0)</code>返回<code>1</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>log</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double log(double x);</code></li>
<li><strong>功能描述</strong>：计算以自然常数<code>e</code>为底<code>x</code>的对数。<code>x</code>必须大于<code>0</code>，否则会产生定义域错误。例如，<code>log(exp(1))</code>返回<code>1</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>log10</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double log10(double x);</code></li>
<li><strong>功能描述</strong>：计算以<code>10</code>为底<code>x</code>的对数。<code>x</code>同样必须大于<code>0</code>。例如，<code>log10(100)</code>返回<code>2</code>。
## <strong>幂函数和开方函数</strong></li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>pow</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double pow(double x, double y);</code></li>
<li><strong>功能描述</strong>：计算<code>x</code>的<code>y</code>次幂。例如，<code>pow(2,3)</code>计算<code>2</code>的<code>3</code>次方，返回<code>8</code>。需要注意的是，当<code>x</code>为负数且<code>y</code>不是整数时，结果可能是复数，在这种情况下可能会产生错误或者不符合预期的结果。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>sqrt</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double sqrt(double x);</code></li>
<li><strong>功能描述</strong>：计算<code>x</code>的平方根。<code>x</code>必须大于等于<code>0</code>，否则会产生定义域错误。例如，<code>sqrt(4)</code>返回<code>2</code>。</li>
<li><h2
id="绝对值和取整函数等辅助函数"><strong>绝对值和取整函数等辅助函数</strong></h2></li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>fabs</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double fabs(double x);</code></li>
<li><strong>功能描述</strong>：计算实数<code>x</code>的绝对值。例如，<code>fabs(-3.14)</code>返回<code>3.14</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>ceil</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double ceil(double x);</code></li>
<li><strong>功能描述</strong>：向上取整函数，返回不小于<code>x</code>的最小整数。例如，<code>ceil(3.14)</code>返回<code>4</code>，<code>ceil(-3.14)</code>返回 <code>- 3</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>floor</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double floor(double x);</code></li>
<li><strong>功能描述</strong>：向下取整函数，返回不大于<code>x</code>的最大整数。例如，<code>floor(3.14)</code>返回<code>3</code>，<code>floor(-3.14)</code>返回 <code>- 4</code>。</li>
</ul></li>
</ul></li>
<li><ul>
<li><strong><code>round</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double round(double x);</code></li>
<li><strong>功能描述</strong>：将<code>x</code>四舍五入到最接近的整数。例如，<code>round(3.4)</code>返回<code>3</code>，<code>round(3.6)</code>返回<code>4</code>。</li>
</ul></li>
</ul></li>
<li><strong><code>fmod</code>函数</strong>
<ul>
<li><strong>函数原型</strong>：<code>double fmod(double x, double y);</code></li>
<li><strong>功能描述</strong>：
<ul>
<li>该函数用于计算<code>x</code>除以<code>y</code>的浮点数余数。它与整数取余运算<code>%</code>在浮点数环境下的功能类似，但<code>%</code>通常用于整数运算，而<code>fmod</code>用于双精度浮点数运算。</li>
<li>计算结果的符号与<code>x</code>的符号相同。例如，<code>fmod(7.5, 2.0)</code>的结果是<code>1.5</code>，因为<code>7.5</code>除以<code>2.0</code>商为<code>3</code>，余数为<code>1.5</code>；<code>fmod(-7.5, 2.0)</code>的结果是<code>-1.5</code>，这是因为计算过程是<code>-7.5 = -4*2.0+(-1.5)</code>。</li>
</ul></li>
<li><strong>应用场景示例</strong>：
<ul>
<li>在周期性的计算中很有用。比如在计算角度的周期性变化时，假设有一个角度变量<code>theta</code>，它的取值范围应该是<code>[0, 2*PI)</code>（以弧度为单位），如果<code>theta</code>的值超过了这个范围，可以使用<code>fmod</code>函数来将其调整回这个范围内。</li>
</ul></li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265358979323846</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> angle = <span class="number">7.0</span> * PI;</span><br><span class="line">    <span class="type">double</span> adjusted_angle = <span class="built_in">fmod</span>(angle, <span class="number">2</span> * PI);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始角度: %lf\n&quot;</span>, angle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调整后的角度: %lf\n&quot;</span>, adjusted_angle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个示例中，首先定义了一个角度<code>angle</code>，它的值大于<code>2*PI</code>。然后使用<code>fmod</code>函数将其调整到<code>[0, 2*PI)</code>范围内，这对于处理周期性的角度变化（如在三角函数相关的计算中）是非常有用的。</li>
</ul>
<h1 id="函数题练习">函数题练习</h1>
<h1 id="编程题练习">编程题练习</h1>
<h2 id="大笨钟">7-10 大笨钟</h2>
<p>微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。</p>
<p>下面就请你写个程序，根据当前时间替大笨钟敲钟。</p>
<h3 id="输入格式">输入格式：</h3>
<p>输入第一行按照<code>hh:mm</code>的格式给出当前时间。其中<code>hh</code>是小时，在00到23之间；<code>mm</code>是分钟，在00到59之间。</p>
<h3 id="输出格式">输出格式：</h3>
<p>根据当前时间替大笨钟敲钟，即在一行中输出相应数量个<code>Dang</code>。如果不是敲钟期，则输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Only</span> hh:mm.  Too early <span class="keyword">to</span> Dang.</span><br></pre></td></tr></table></figure>
<p>其中<code>hh:mm</code>是输入的时间。</p>
<h3 id="输入样例1">输入样例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19:05</span><br></pre></td></tr></table></figure>
<h3 id="输出样例1">输出样例1：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DangDangDangDangDangDangDangDang</span><br></pre></td></tr></table></figure>
<h3 id="输入样例2">输入样例2：</h3>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">07</span>:<span class="number">05</span></span><br></pre></td></tr></table></figure>
<h3 id="输出样例2">输出样例2：</h3>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Only</span> <span class="number">07</span>:<span class="number">05</span>.  Too early to Dang.</span><br></pre></td></tr></table></figure>
<p>code： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> h,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d:%d&quot;</span>,&amp;h,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>((h==<span class="number">12</span>&amp;&amp;m!=<span class="number">0</span>)||(h&gt;<span class="number">12</span>&amp;&amp;h&lt;<span class="number">24</span>))<span class="comment">//12点临界值不包括</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h<span class="number">-12</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Dang&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Dang&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Only %0.2d:%0.2d.  Too early to Dang.&quot;</span>,h,m);<span class="comment">//注意这里的格式化输出%0.2d:%0.2d</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="求整数的位数及各位数字之和">7-19 求整数的位数及各位数字之和</h2>
<p>对于给定的非负整数N，求它的位数及其各位数字之和。</p>
<h3 id="输入格式-1">输入格式:</h3>
<p>输入在一行中给出一个非负整数N。</p>
<h3 id="输出格式-1">输出格式:</h3>
<p>在一行中输出N的位数及其各位数字之和，中间用一个空格隔开。</p>
<h3 id="输入样例">输入样例:</h3>
<p>在这里给出一组输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">321</span><br></pre></td></tr></table></figure>
<h3 id="输出样例">输出样例:</h3>
<p>在这里给出相应的输出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6</span><br></pre></td></tr></table></figure>
<p>code: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> num[<span class="number">21</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;num);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(num);</span><br><span class="line">	<span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a+=num[i]-<span class="string">&#x27;0&#x27;</span>;		<span class="comment">//减去0的ASCII码值完成转换</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,len,a);</span><br><span class="line">&#125;</span><br><span class="line">                             </span><br></pre></td></tr></table></figure></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Li Wenxuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/10/C%E8%AF%AD%E8%A8%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">http://example.com/2025/01/10/C%E8%AF%AD%E8%A8%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Even-lwx的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66d4f9dbd9c307b7e943756c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="高等数学A1-期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高等数学A1-期末复习</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="线性代数-期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线性代数-期末复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/08/24/24%E7%BA%A7%E6%9D%AD%E7%94%B5%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%85%88%E4%BF%AE%E8%AF%BE-mooc%E4%BD%9C%E4%B8%9A/" title="24级杭电《C语言程序设计》先修课-mooc作业"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-24</div><div class="title">24级杭电《C语言程序设计》先修课-mooc作业</div></div></a></div><div><a href="/2024/08/24/24%E7%BA%A7%E6%9D%AD%E7%94%B5%E5%85%88%E4%BF%AE%E8%AF%BEPTA%E4%BD%9C%E4%B8%9A/" title="24级杭电先修课PTA作业"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-24</div><div class="title">24级杭电先修课PTA作业</div></div></a></div><div><a href="/2024/09/13/stm32%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/" title="stm32单片机学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-13</div><div class="title">stm32单片机学习</div></div></a></div><div><a href="/2024/09/08/%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86/" title="团体程序设计天梯赛-练习集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-08</div><div class="title">团体程序设计天梯赛-练习集</div></div></a></div><div><a href="/2024/09/23/%E5%B8%B8%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0+%E7%AE%97%E6%B3%95/" title="常用自定义函数+算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="title">常用自定义函数+算法</div></div></a></div><div><a href="/2025/12/31/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="《最优化理论与算法》期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-31</div><div class="title">《最优化理论与算法》期末复习</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/66d4f9dbd9c307b7e943756c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Li Wenxuan</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Even-lwx"><i class="fab fa-github"></i><span>前往GitHub主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">数据基本类型和输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%B0%86%E6%95%B0%E5%AD%97%E5%92%8C%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E7%BB%99char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%BC%9A%E5%A6%82%E4%BD%95"><span class="toc-text">C语言——将数字和数字字符输入给char型变量会如何？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">输入输出函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sscanf"><span class="toc-text">sscanf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sprintf"><span class="toc-text">sprintf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">字符串处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen-%E4%B8%8Esizeof"><span class="toc-text">strlen 与sizeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy-%E4%B8%8Estrncpy"><span class="toc-text">strcpy 与strncpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcat-%E4%B8%8Estrncat"><span class="toc-text">strcat 与strncat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcmp-%E4%B8%8Estrncmp"><span class="toc-text">strcmp 与strncmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strchr-%E4%B8%8E-strrchr"><span class="toc-text">strchr 与 strrchr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strstr"><span class="toc-text">strstr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strtok"><span class="toc-text">strtok</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%80%E5%9C%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%BF%85%E7%9C%8B"><span class="toc-text">函数所在标准库（必看）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text">读写函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fputc-fgetc"><span class="toc-text">fputc fgetc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fputs-fgets"><span class="toc-text">fputs fgets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fprintf-fscanf"><span class="toc-text">fprintf fscanf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-text">文件定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#feof"><span class="toc-text">feof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fseek"><span class="toc-text">fseek</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewind"><span class="toc-text">rewind</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stdlib%E5%BA%93%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-text">stdlib库中常见函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#math%E5%BA%93%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-text">math库中常见函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">三角函数相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">反三角函数相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E5%92%8C%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-text">指数和对数函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%92%8C%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0%E7%AD%89%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-text">绝对值和取整函数等辅助函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%A2%98%E7%BB%83%E4%B9%A0"><span class="toc-text">函数题练习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98%E7%BB%83%E4%B9%A0"><span class="toc-text">编程题练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%AC%A8%E9%92%9F"><span class="toc-text">7-10 大笨钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">输入格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">输出格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1"><span class="toc-text">输入样例1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1"><span class="toc-text">输出样例1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2"><span class="toc-text">输入样例2：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2"><span class="toc-text">输出样例2：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8D%E6%95%B0%E5%8F%8A%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-text">7-19 求整数的位数及各位数字之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">输入格式:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">输出格式:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B"><span class="toc-text">输入样例:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B"><span class="toc-text">输出样例:</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/06/%E6%99%BA%E8%83%BD%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BC%A0%E6%84%9F%E5%99%A8-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="智能检测技术与传感器-期末复习">智能检测技术与传感器-期末复习</a><time datetime="2026-01-06T08:08:00.000Z" title="发表于 2026-01-06 16:08:00">2026-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/%E3%80%8A%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="《最优化理论与算法》期末复习">《最优化理论与算法》期末复习</a><time datetime="2025-12-30T17:01:00.000Z" title="发表于 2025-12-31 01:01:00">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/12/%E5%85%B3%E4%BA%8E%E9%A3%9E%E8%B7%83%E9%9B%B7%E5%8C%BA%E7%BB%84%E5%88%AB%E7%9A%84%E5%BB%BA%E8%AE%AE2/" title="关于飞跃雷区组别的建议2">关于飞跃雷区组别的建议2</a><time datetime="2025-11-12T08:54:00.000Z" title="发表于 2025-11-12 16:54:00">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/" title="概率论与数理统计期中复习">概率论与数理统计期中复习</a><time datetime="2025-11-12T08:54:00.000Z" title="发表于 2025-11-12 16:54:00">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/26/%E5%85%B3%E4%BA%8E%E9%A3%9E%E8%B7%83%E9%9B%B7%E5%8C%BA%E7%BB%84%E5%88%AB%E7%9A%84%E5%BB%BA%E8%AE%AE/" title="关于飞跃雷区组别的建议">关于飞跃雷区组别的建议</a><time datetime="2025-10-25T21:00:00.000Z" title="发表于 2025-10-26 05:00:00">2025-10-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By Li Wenxuan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'dFkdHcfZtGwzsfiaHd6S1NZH-gzGzoHsz',
      appKey: '2s0nGdaJH0jYvQviwPMlTF2O',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>